/*
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file was automatically generated by the code_generation module.
 * Any changes made to this file will be lost when regenerated.
 *
 * To modify this file, edit the corresponding template in:
 * code_generation/templates/server/function_handlers_impl.mako
 */

#include "function_handlers.h"

#include "xrtransport/server/function_loader.h"
#include "xrtransport/transport/transport.h"
#include "xrtransport/serialization/serializer.h"
#include "xrtransport/serialization/deserializer.h"
#include "xrtransport/util.h"

#include "openxr/openxr.h"

#include <spdlog/spdlog.h>

#include <unordered_map>
#include <string>

using std::uint32_t;

namespace xrtransport {


#ifdef XRTRANSPORT_EXT_XR_KHR_android_thread_settings

void handle_xrSetAndroidApplicationThreadKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetAndroidApplicationThreadKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetAndroidApplicationThreadKHR));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrAndroidThreadTypeKHR threadType;
    

    deserialize(&threadType, msg_in.stream, false);

    uint32_t threadId;
    

    deserialize(&threadId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetAndroidApplicationThreadKHR(session, threadType, threadId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_KHR_android_thread_settings
#ifdef XRTRANSPORT_EXT_XR_KHR_android_surface_swapchain

void handle_xrCreateSwapchainAndroidSurfaceKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSwapchainAndroidSurfaceKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSwapchainAndroidSurfaceKHR));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSwapchainCreateInfo* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrSwapchain* swapchain;
    

    deserialize_ptr(&swapchain, msg_in.stream, false);

    jobject* surface;
    

    deserialize_ptr(&surface, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSwapchainAndroidSurfaceKHR(session, info, swapchain, surface);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(swapchain, 1, msg_out.buffer);

    
    serialize_ptr(surface, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_KHR_android_surface_swapchain
#ifdef XRTRANSPORT_EXT_XR_KHR_composition_layer_cube
#endif // XRTRANSPORT_EXT_XR_KHR_composition_layer_cube
#ifdef XRTRANSPORT_EXT_XR_KHR_android_create_instance
#endif // XRTRANSPORT_EXT_XR_KHR_android_create_instance
#ifdef XRTRANSPORT_EXT_XR_KHR_composition_layer_depth
#endif // XRTRANSPORT_EXT_XR_KHR_composition_layer_depth
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_swapchain_format_list
#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_swapchain_format_list
#ifdef XRTRANSPORT_EXT_XR_EXT_performance_settings

void handle_xrPerfSettingsSetPerformanceLevelEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPerfSettingsSetPerformanceLevelEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPerfSettingsSetPerformanceLevelEXT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrPerfSettingsDomainEXT domain;
    

    deserialize(&domain, msg_in.stream, false);

    XrPerfSettingsLevelEXT level;
    

    deserialize(&level, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPerfSettingsSetPerformanceLevelEXT(session, domain, level);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_EXT_performance_settings
#ifdef XRTRANSPORT_EXT_XR_EXT_thermal_query

void handle_xrThermalGetTemperatureTrendEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrThermalGetTemperatureTrendEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrThermalGetTemperatureTrendEXT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrPerfSettingsDomainEXT domain;
    

    deserialize(&domain, msg_in.stream, false);

    XrPerfSettingsNotificationLevelEXT* notificationLevel;
    

    deserialize_ptr(&notificationLevel, msg_in.stream, false);

    float* tempHeadroom;
    

    deserialize_ptr(&tempHeadroom, msg_in.stream, false);

    float* tempSlope;
    

    deserialize_ptr(&tempSlope, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrThermalGetTemperatureTrendEXT(session, domain, notificationLevel, tempHeadroom, tempSlope);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(notificationLevel, 1, msg_out.buffer);

    
    serialize_ptr(tempHeadroom, 1, msg_out.buffer);

    
    serialize_ptr(tempSlope, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_EXT_thermal_query
#ifdef XRTRANSPORT_EXT_XR_KHR_composition_layer_cylinder
#endif // XRTRANSPORT_EXT_XR_KHR_composition_layer_cylinder
#ifdef XRTRANSPORT_EXT_XR_KHR_composition_layer_equirect
#endif // XRTRANSPORT_EXT_XR_KHR_composition_layer_equirect
#ifdef XRTRANSPORT_EXT_XR_EXT_debug_utils

void handle_xrSetDebugUtilsObjectNameEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetDebugUtilsObjectNameEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetDebugUtilsObjectNameEXT));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrDebugUtilsObjectNameInfoEXT* nameInfo;
    

    deserialize_ptr(&nameInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetDebugUtilsObjectNameEXT(instance, nameInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrCreateDebugUtilsMessengerEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateDebugUtilsMessengerEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateDebugUtilsMessengerEXT));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrDebugUtilsMessengerCreateInfoEXT* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrDebugUtilsMessengerEXT* messenger;
    

    deserialize_ptr(&messenger, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateDebugUtilsMessengerEXT(instance, createInfo, messenger);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(createInfo->userData, 1, msg_out.buffer);

    
    serialize_ptr(messenger, 1, msg_out.buffer);

}


void handle_xrDestroyDebugUtilsMessengerEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyDebugUtilsMessengerEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyDebugUtilsMessengerEXT));
    // by this point, the function id has already been read, now read the params
    XrDebugUtilsMessengerEXT messenger;
    

    deserialize(&messenger, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyDebugUtilsMessengerEXT(messenger);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrSubmitDebugUtilsMessageEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSubmitDebugUtilsMessageEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSubmitDebugUtilsMessageEXT));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrDebugUtilsMessageSeverityFlagsEXT messageSeverity;
    

    deserialize(&messageSeverity, msg_in.stream, false);

    XrDebugUtilsMessageTypeFlagsEXT messageTypes;
    

    deserialize(&messageTypes, msg_in.stream, false);

    const XrDebugUtilsMessengerCallbackDataEXT* callbackData;
    

    deserialize_ptr(&callbackData, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, callbackData);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(callbackData->objects, callbackData->objectCount, msg_out.buffer);

    
    serialize_ptr(callbackData->sessionLabels, callbackData->sessionLabelCount, msg_out.buffer);

}


void handle_xrSessionBeginDebugUtilsLabelRegionEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSessionBeginDebugUtilsLabelRegionEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSessionBeginDebugUtilsLabelRegionEXT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrDebugUtilsLabelEXT* labelInfo;
    

    deserialize_ptr(&labelInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSessionBeginDebugUtilsLabelRegionEXT(session, labelInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrSessionEndDebugUtilsLabelRegionEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSessionEndDebugUtilsLabelRegionEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSessionEndDebugUtilsLabelRegionEXT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSessionEndDebugUtilsLabelRegionEXT(session);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrSessionInsertDebugUtilsLabelEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSessionInsertDebugUtilsLabelEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSessionInsertDebugUtilsLabelEXT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrDebugUtilsLabelEXT* labelInfo;
    

    deserialize_ptr(&labelInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSessionInsertDebugUtilsLabelEXT(session, labelInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_EXT_debug_utils
#ifdef XRTRANSPORT_EXT_XR_KHR_opengl_enable

void handle_xrGetOpenGLGraphicsRequirementsKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetOpenGLGraphicsRequirementsKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetOpenGLGraphicsRequirementsKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    XrGraphicsRequirementsOpenGLKHR* graphicsRequirements;
    

    deserialize_ptr(&graphicsRequirements, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetOpenGLGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(graphicsRequirements, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_KHR_opengl_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_opengl_es_enable

void handle_xrGetOpenGLESGraphicsRequirementsKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetOpenGLESGraphicsRequirementsKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetOpenGLESGraphicsRequirementsKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    XrGraphicsRequirementsOpenGLESKHR* graphicsRequirements;
    

    deserialize_ptr(&graphicsRequirements, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetOpenGLESGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(graphicsRequirements, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_KHR_opengl_es_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_enable

void handle_xrGetVulkanInstanceExtensionsKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetVulkanInstanceExtensionsKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetVulkanInstanceExtensionsKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    uint32_t bufferCapacityInput;
    

    deserialize(&bufferCapacityInput, msg_in.stream, false);

    uint32_t* bufferCountOutput;
    

    deserialize_ptr(&bufferCountOutput, msg_in.stream, false);

    char* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetVulkanInstanceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(bufferCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(buffer, bufferCapacityInput, msg_out.buffer);

}


void handle_xrGetVulkanDeviceExtensionsKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetVulkanDeviceExtensionsKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetVulkanDeviceExtensionsKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    uint32_t bufferCapacityInput;
    

    deserialize(&bufferCapacityInput, msg_in.stream, false);

    uint32_t* bufferCountOutput;
    

    deserialize_ptr(&bufferCountOutput, msg_in.stream, false);

    char* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetVulkanDeviceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(bufferCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(buffer, bufferCapacityInput, msg_out.buffer);

}


void handle_xrGetVulkanGraphicsDeviceKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetVulkanGraphicsDeviceKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetVulkanGraphicsDeviceKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    VkInstance vkInstance;
    

    deserialize(&vkInstance, msg_in.stream, false);

    VkPhysicalDevice* vkPhysicalDevice;
    

    deserialize_ptr(&vkPhysicalDevice, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetVulkanGraphicsDeviceKHR(instance, systemId, vkInstance, vkPhysicalDevice);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(vkPhysicalDevice, 1, msg_out.buffer);

}


void handle_xrGetVulkanGraphicsRequirementsKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetVulkanGraphicsRequirementsKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetVulkanGraphicsRequirementsKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    XrGraphicsRequirementsVulkanKHR* graphicsRequirements;
    

    deserialize_ptr(&graphicsRequirements, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetVulkanGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(graphicsRequirements, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_D3D11_enable

void handle_xrGetD3D11GraphicsRequirementsKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetD3D11GraphicsRequirementsKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetD3D11GraphicsRequirementsKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    XrGraphicsRequirementsD3D11KHR* graphicsRequirements;
    

    deserialize_ptr(&graphicsRequirements, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetD3D11GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(graphicsRequirements, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_KHR_D3D11_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_D3D12_enable

void handle_xrGetD3D12GraphicsRequirementsKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetD3D12GraphicsRequirementsKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetD3D12GraphicsRequirementsKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    XrGraphicsRequirementsD3D12KHR* graphicsRequirements;
    

    deserialize_ptr(&graphicsRequirements, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetD3D12GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(graphicsRequirements, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_KHR_D3D12_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_metal_enable

void handle_xrGetMetalGraphicsRequirementsKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetMetalGraphicsRequirementsKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetMetalGraphicsRequirementsKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    XrGraphicsRequirementsMetalKHR* graphicsRequirements;
    

    deserialize_ptr(&graphicsRequirements, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetMetalGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(graphicsRequirements, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_KHR_metal_enable
#ifdef XRTRANSPORT_EXT_XR_EXT_eye_gaze_interaction
#endif // XRTRANSPORT_EXT_XR_EXT_eye_gaze_interaction
#ifdef XRTRANSPORT_EXT_XR_KHR_visibility_mask

void handle_xrGetVisibilityMaskKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetVisibilityMaskKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetVisibilityMaskKHR));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrViewConfigurationType viewConfigurationType;
    

    deserialize(&viewConfigurationType, msg_in.stream, false);

    uint32_t viewIndex;
    

    deserialize(&viewIndex, msg_in.stream, false);

    XrVisibilityMaskTypeKHR visibilityMaskType;
    

    deserialize(&visibilityMaskType, msg_in.stream, false);

    XrVisibilityMaskKHR* visibilityMask;
    

    deserialize_ptr(&visibilityMask, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetVisibilityMaskKHR(session, viewConfigurationType, viewIndex, visibilityMaskType, visibilityMask);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(visibilityMask, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_KHR_visibility_mask
#ifdef XRTRANSPORT_EXT_XR_EXTX_overlay
#endif // XRTRANSPORT_EXT_XR_EXTX_overlay
#ifdef XRTRANSPORT_EXT_XR_KHR_composition_layer_color_scale_bias
#endif // XRTRANSPORT_EXT_XR_KHR_composition_layer_color_scale_bias
#ifdef XRTRANSPORT_EXT_XR_KHR_win32_convert_performance_counter_time

void handle_xrConvertWin32PerformanceCounterToTimeKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrConvertWin32PerformanceCounterToTimeKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrConvertWin32PerformanceCounterToTimeKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const LARGE_INTEGER* performanceCounter;
    

    deserialize_ptr(&performanceCounter, msg_in.stream, false);

    XrTime* time;
    

    deserialize_ptr(&time, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrConvertWin32PerformanceCounterToTimeKHR(instance, performanceCounter, time);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(time, 1, msg_out.buffer);

}


void handle_xrConvertTimeToWin32PerformanceCounterKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrConvertTimeToWin32PerformanceCounterKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrConvertTimeToWin32PerformanceCounterKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrTime time;
    

    deserialize(&time, msg_in.stream, false);

    LARGE_INTEGER* performanceCounter;
    

    deserialize_ptr(&performanceCounter, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrConvertTimeToWin32PerformanceCounterKHR(instance, time, performanceCounter);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(performanceCounter, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_KHR_win32_convert_performance_counter_time
#ifdef XRTRANSPORT_EXT_XR_KHR_convert_timespec_time

void handle_xrConvertTimespecTimeToTimeKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrConvertTimespecTimeToTimeKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrConvertTimespecTimeToTimeKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const struct timespec* timespecTime;
    

    deserialize_ptr(&timespecTime, msg_in.stream, false);

    XrTime* time;
    

    deserialize_ptr(&time, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrConvertTimespecTimeToTimeKHR(instance, timespecTime, time);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(timespecTime, 1, msg_out.buffer);

    
    serialize_ptr(time, 1, msg_out.buffer);

}


void handle_xrConvertTimeToTimespecTimeKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrConvertTimeToTimespecTimeKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrConvertTimeToTimespecTimeKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrTime time;
    

    deserialize(&time, msg_in.stream, false);

    struct timespec* timespecTime;
    

    deserialize_ptr(&timespecTime, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrConvertTimeToTimespecTimeKHR(instance, time, timespecTime);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(timespecTime, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_KHR_convert_timespec_time
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_anchor

void handle_xrCreateSpatialAnchorMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialAnchorMSFT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpatialAnchorCreateInfoMSFT* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpatialAnchorMSFT* anchor;
    

    deserialize_ptr(&anchor, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorMSFT(session, createInfo, anchor);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(anchor, 1, msg_out.buffer);

}


void handle_xrCreateSpatialAnchorSpaceMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorSpaceMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialAnchorSpaceMSFT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpatialAnchorSpaceCreateInfoMSFT* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpace* space;
    

    deserialize_ptr(&space, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorSpaceMSFT(session, createInfo, space);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(space, 1, msg_out.buffer);

}


void handle_xrDestroySpatialAnchorMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroySpatialAnchorMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroySpatialAnchorMSFT));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorMSFT anchor;
    

    deserialize(&anchor, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroySpatialAnchorMSFT(anchor);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_anchor
#ifdef XRTRANSPORT_EXT_XR_FB_composition_layer_image_layout
#endif // XRTRANSPORT_EXT_XR_FB_composition_layer_image_layout
#ifdef XRTRANSPORT_EXT_XR_FB_composition_layer_alpha_blend
#endif // XRTRANSPORT_EXT_XR_FB_composition_layer_alpha_blend
#ifdef XRTRANSPORT_EXT_XR_EXT_view_configuration_depth_range
#endif // XRTRANSPORT_EXT_XR_EXT_view_configuration_depth_range
#ifdef XRTRANSPORT_EXT_XR_EXT_conformance_automation

void handle_xrSetInputDeviceActiveEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetInputDeviceActiveEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetInputDeviceActiveEXT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrPath interactionProfile;
    

    deserialize(&interactionProfile, msg_in.stream, false);

    XrPath topLevelPath;
    

    deserialize(&topLevelPath, msg_in.stream, false);

    XrBool32 isActive;
    

    deserialize(&isActive, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetInputDeviceActiveEXT(session, interactionProfile, topLevelPath, isActive);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrSetInputDeviceStateBoolEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetInputDeviceStateBoolEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetInputDeviceStateBoolEXT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrPath topLevelPath;
    

    deserialize(&topLevelPath, msg_in.stream, false);

    XrPath inputSourcePath;
    

    deserialize(&inputSourcePath, msg_in.stream, false);

    XrBool32 state;
    

    deserialize(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetInputDeviceStateBoolEXT(session, topLevelPath, inputSourcePath, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrSetInputDeviceStateFloatEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetInputDeviceStateFloatEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetInputDeviceStateFloatEXT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrPath topLevelPath;
    

    deserialize(&topLevelPath, msg_in.stream, false);

    XrPath inputSourcePath;
    

    deserialize(&inputSourcePath, msg_in.stream, false);

    float state;
    

    deserialize(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetInputDeviceStateFloatEXT(session, topLevelPath, inputSourcePath, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrSetInputDeviceStateVector2fEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetInputDeviceStateVector2fEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetInputDeviceStateVector2fEXT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrPath topLevelPath;
    

    deserialize(&topLevelPath, msg_in.stream, false);

    XrPath inputSourcePath;
    

    deserialize(&inputSourcePath, msg_in.stream, false);

    XrVector2f state;
    

    deserialize(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetInputDeviceStateVector2fEXT(session, topLevelPath, inputSourcePath, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrSetInputDeviceLocationEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetInputDeviceLocationEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetInputDeviceLocationEXT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrPath topLevelPath;
    

    deserialize(&topLevelPath, msg_in.stream, false);

    XrPath inputSourcePath;
    

    deserialize(&inputSourcePath, msg_in.stream, false);

    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);

    XrPosef pose;
    

    deserialize(&pose, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetInputDeviceLocationEXT(session, topLevelPath, inputSourcePath, space, pose);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_EXT_conformance_automation
#ifdef XRTRANSPORT_EXT_XR_MNDX_egl_enable
#endif // XRTRANSPORT_EXT_XR_MNDX_egl_enable
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_graph_bridge

void handle_xrCreateSpatialGraphNodeSpaceMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialGraphNodeSpaceMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialGraphNodeSpaceMSFT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpatialGraphNodeSpaceCreateInfoMSFT* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpace* space;
    

    deserialize_ptr(&space, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialGraphNodeSpaceMSFT(session, createInfo, space);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(space, 1, msg_out.buffer);

}


void handle_xrTryCreateSpatialGraphStaticNodeBindingMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrTryCreateSpatialGraphStaticNodeBindingMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrTryCreateSpatialGraphStaticNodeBindingMSFT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpatialGraphStaticNodeBindingCreateInfoMSFT* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpatialGraphNodeBindingMSFT* nodeBinding;
    

    deserialize_ptr(&nodeBinding, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrTryCreateSpatialGraphStaticNodeBindingMSFT(session, createInfo, nodeBinding);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(nodeBinding, 1, msg_out.buffer);

}


void handle_xrDestroySpatialGraphNodeBindingMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroySpatialGraphNodeBindingMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroySpatialGraphNodeBindingMSFT));
    // by this point, the function id has already been read, now read the params
    XrSpatialGraphNodeBindingMSFT nodeBinding;
    

    deserialize(&nodeBinding, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroySpatialGraphNodeBindingMSFT(nodeBinding);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetSpatialGraphNodeBindingPropertiesMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpatialGraphNodeBindingPropertiesMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpatialGraphNodeBindingPropertiesMSFT));
    // by this point, the function id has already been read, now read the params
    XrSpatialGraphNodeBindingMSFT nodeBinding;
    

    deserialize(&nodeBinding, msg_in.stream, false);

    const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    XrSpatialGraphNodeBindingPropertiesMSFT* properties;
    

    deserialize_ptr(&properties, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpatialGraphNodeBindingPropertiesMSFT(nodeBinding, getInfo, properties);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(properties, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_graph_bridge
#ifdef XRTRANSPORT_EXT_XR_EXT_hand_tracking

void handle_xrCreateHandTrackerEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateHandTrackerEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateHandTrackerEXT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrHandTrackerCreateInfoEXT* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrHandTrackerEXT* handTracker;
    

    deserialize_ptr(&handTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateHandTrackerEXT(session, createInfo, handTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(handTracker, 1, msg_out.buffer);

}


void handle_xrDestroyHandTrackerEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyHandTrackerEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyHandTrackerEXT));
    // by this point, the function id has already been read, now read the params
    XrHandTrackerEXT handTracker;
    

    deserialize(&handTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyHandTrackerEXT(handTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrLocateHandJointsEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrLocateHandJointsEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrLocateHandJointsEXT));
    // by this point, the function id has already been read, now read the params
    XrHandTrackerEXT handTracker;
    

    deserialize(&handTracker, msg_in.stream, false);

    const XrHandJointsLocateInfoEXT* locateInfo;
    

    deserialize_ptr(&locateInfo, msg_in.stream, false);

    XrHandJointLocationsEXT* locations;
    

    deserialize_ptr(&locations, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrLocateHandJointsEXT(handTracker, locateInfo, locations);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(locations, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_EXT_hand_tracking
#ifdef XRTRANSPORT_EXT_XR_MSFT_hand_tracking_mesh

void handle_xrCreateHandMeshSpaceMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateHandMeshSpaceMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateHandMeshSpaceMSFT));
    // by this point, the function id has already been read, now read the params
    XrHandTrackerEXT handTracker;
    

    deserialize(&handTracker, msg_in.stream, false);

    const XrHandMeshSpaceCreateInfoMSFT* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpace* space;
    

    deserialize_ptr(&space, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateHandMeshSpaceMSFT(handTracker, createInfo, space);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(space, 1, msg_out.buffer);

}


void handle_xrUpdateHandMeshMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrUpdateHandMeshMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrUpdateHandMeshMSFT));
    // by this point, the function id has already been read, now read the params
    XrHandTrackerEXT handTracker;
    

    deserialize(&handTracker, msg_in.stream, false);

    const XrHandMeshUpdateInfoMSFT* updateInfo;
    

    deserialize_ptr(&updateInfo, msg_in.stream, false);

    XrHandMeshMSFT* handMesh;
    

    deserialize_ptr(&handMesh, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrUpdateHandMeshMSFT(handTracker, updateInfo, handMesh);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(handMesh, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_MSFT_hand_tracking_mesh
#ifdef XRTRANSPORT_EXT_XR_MSFT_secondary_view_configuration
#endif // XRTRANSPORT_EXT_XR_MSFT_secondary_view_configuration
#ifdef XRTRANSPORT_EXT_XR_MSFT_controller_model

void handle_xrGetControllerModelKeyMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetControllerModelKeyMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetControllerModelKeyMSFT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrPath topLevelUserPath;
    

    deserialize(&topLevelUserPath, msg_in.stream, false);

    XrControllerModelKeyStateMSFT* controllerModelKeyState;
    

    deserialize_ptr(&controllerModelKeyState, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetControllerModelKeyMSFT(session, topLevelUserPath, controllerModelKeyState);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(controllerModelKeyState, 1, msg_out.buffer);

}


void handle_xrLoadControllerModelMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrLoadControllerModelMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrLoadControllerModelMSFT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrControllerModelKeyMSFT modelKey;
    

    deserialize(&modelKey, msg_in.stream, false);

    uint32_t bufferCapacityInput;
    

    deserialize(&bufferCapacityInput, msg_in.stream, false);

    uint32_t* bufferCountOutput;
    

    deserialize_ptr(&bufferCountOutput, msg_in.stream, false);

    uint8_t* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrLoadControllerModelMSFT(session, modelKey, bufferCapacityInput, bufferCountOutput, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(bufferCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(buffer, bufferCapacityInput, msg_out.buffer);

}


void handle_xrGetControllerModelPropertiesMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetControllerModelPropertiesMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetControllerModelPropertiesMSFT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrControllerModelKeyMSFT modelKey;
    

    deserialize(&modelKey, msg_in.stream, false);

    XrControllerModelPropertiesMSFT* properties;
    

    deserialize_ptr(&properties, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetControllerModelPropertiesMSFT(session, modelKey, properties);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(properties, 1, msg_out.buffer);

}


void handle_xrGetControllerModelStateMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetControllerModelStateMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetControllerModelStateMSFT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrControllerModelKeyMSFT modelKey;
    

    deserialize(&modelKey, msg_in.stream, false);

    XrControllerModelStateMSFT* state;
    

    deserialize_ptr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetControllerModelStateMSFT(session, modelKey, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(state, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_MSFT_controller_model
#ifdef XRTRANSPORT_EXT_XR_MSFT_perception_anchor_interop

void handle_xrCreateSpatialAnchorFromPerceptionAnchorMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorFromPerceptionAnchorMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialAnchorFromPerceptionAnchorMSFT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    IUnknown* perceptionAnchor;
    

    deserialize_ptr(&perceptionAnchor, msg_in.stream, false);

    XrSpatialAnchorMSFT* anchor;
    

    deserialize_ptr(&anchor, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorFromPerceptionAnchorMSFT(session, perceptionAnchor, anchor);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(perceptionAnchor, 1, msg_out.buffer);

    
    serialize_ptr(anchor, 1, msg_out.buffer);

}


void handle_xrTryGetPerceptionAnchorFromSpatialAnchorMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrTryGetPerceptionAnchorFromSpatialAnchorMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrTryGetPerceptionAnchorFromSpatialAnchorMSFT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrSpatialAnchorMSFT anchor;
    

    deserialize(&anchor, msg_in.stream, false);

    IUnknown** perceptionAnchor;
    

    #error "auto-generator doesn't support double pointers (perceptionAnchor)"
    None

    XrResult _result = function_loader.pfn_xrTryGetPerceptionAnchorFromSpatialAnchorMSFT(session, anchor, perceptionAnchor);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(perceptionAnchor, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_MSFT_perception_anchor_interop
#ifdef XRTRANSPORT_EXT_XR_EPIC_view_configuration_fov
#endif // XRTRANSPORT_EXT_XR_EPIC_view_configuration_fov
#ifdef XRTRANSPORT_EXT_XR_MSFT_holographic_window_attachment
#endif // XRTRANSPORT_EXT_XR_MSFT_holographic_window_attachment
#ifdef XRTRANSPORT_EXT_XR_MSFT_composition_layer_reprojection

void handle_xrEnumerateReprojectionModesMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateReprojectionModesMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateReprojectionModesMSFT));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    XrViewConfigurationType viewConfigurationType;
    

    deserialize(&viewConfigurationType, msg_in.stream, false);

    uint32_t modeCapacityInput;
    

    deserialize(&modeCapacityInput, msg_in.stream, false);

    uint32_t* modeCountOutput;
    

    deserialize_ptr(&modeCountOutput, msg_in.stream, false);

    XrReprojectionModeMSFT* modes;
    

    deserialize_ptr(&modes, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateReprojectionModesMSFT(instance, systemId, viewConfigurationType, modeCapacityInput, modeCountOutput, modes);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(modeCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(modes, modeCapacityInput, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_MSFT_composition_layer_reprojection
#ifdef XRTRANSPORT_EXT_XR_FB_android_surface_swapchain_create
#endif // XRTRANSPORT_EXT_XR_FB_android_surface_swapchain_create
#ifdef XRTRANSPORT_EXT_XR_FB_swapchain_update_state

void handle_xrUpdateSwapchainFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrUpdateSwapchainFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrUpdateSwapchainFB));
    // by this point, the function id has already been read, now read the params
    XrSwapchain swapchain;
    

    deserialize(&swapchain, msg_in.stream, false);

    const XrSwapchainStateBaseHeaderFB* state;
    

    deserialize_xr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrUpdateSwapchainFB(swapchain, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetSwapchainStateFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSwapchainStateFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSwapchainStateFB));
    // by this point, the function id has already been read, now read the params
    XrSwapchain swapchain;
    

    deserialize(&swapchain, msg_in.stream, false);

    XrSwapchainStateBaseHeaderFB* state;
    

    deserialize_xr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSwapchainStateFB(swapchain, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_xr(state, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_swapchain_update_state
#ifdef XRTRANSPORT_EXT_XR_FB_composition_layer_secure_content
#endif // XRTRANSPORT_EXT_XR_FB_composition_layer_secure_content
#ifdef XRTRANSPORT_EXT_XR_FB_body_tracking

void handle_xrCreateBodyTrackerFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateBodyTrackerFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateBodyTrackerFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrBodyTrackerCreateInfoFB* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrBodyTrackerFB* bodyTracker;
    

    deserialize_ptr(&bodyTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateBodyTrackerFB(session, createInfo, bodyTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(bodyTracker, 1, msg_out.buffer);

}


void handle_xrDestroyBodyTrackerFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyBodyTrackerFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyBodyTrackerFB));
    // by this point, the function id has already been read, now read the params
    XrBodyTrackerFB bodyTracker;
    

    deserialize(&bodyTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyBodyTrackerFB(bodyTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrLocateBodyJointsFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrLocateBodyJointsFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrLocateBodyJointsFB));
    // by this point, the function id has already been read, now read the params
    XrBodyTrackerFB bodyTracker;
    

    deserialize(&bodyTracker, msg_in.stream, false);

    const XrBodyJointsLocateInfoFB* locateInfo;
    

    deserialize_ptr(&locateInfo, msg_in.stream, false);

    XrBodyJointLocationsFB* locations;
    

    deserialize_ptr(&locations, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrLocateBodyJointsFB(bodyTracker, locateInfo, locations);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(locations, 1, msg_out.buffer);

}


void handle_xrGetBodySkeletonFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetBodySkeletonFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetBodySkeletonFB));
    // by this point, the function id has already been read, now read the params
    XrBodyTrackerFB bodyTracker;
    

    deserialize(&bodyTracker, msg_in.stream, false);

    XrBodySkeletonFB* skeleton;
    

    deserialize_ptr(&skeleton, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetBodySkeletonFB(bodyTracker, skeleton);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(skeleton, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_body_tracking
#ifdef XRTRANSPORT_EXT_XR_EXT_dpad_binding
#endif // XRTRANSPORT_EXT_XR_EXT_dpad_binding
#ifdef XRTRANSPORT_EXT_XR_VALVE_analog_threshold
#endif // XRTRANSPORT_EXT_XR_VALVE_analog_threshold
#ifdef XRTRANSPORT_EXT_XR_EXT_hand_joints_motion_range
#endif // XRTRANSPORT_EXT_XR_EXT_hand_joints_motion_range
#ifdef XRTRANSPORT_EXT_XR_KHR_loader_init

void handle_xrInitializeLoaderKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrInitializeLoaderKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrInitializeLoaderKHR));
    // by this point, the function id has already been read, now read the params
    const XrLoaderInitInfoBaseHeaderKHR* loaderInitInfo;
    

    deserialize_xr(&loaderInitInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrInitializeLoaderKHR(loaderInitInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_KHR_loader_init
#ifdef XRTRANSPORT_EXT_XR_KHR_loader_init_android
#endif // XRTRANSPORT_EXT_XR_KHR_loader_init_android
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_enable2

void handle_xrCreateVulkanInstanceKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateVulkanInstanceKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateVulkanInstanceKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrVulkanInstanceCreateInfoKHR* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    VkInstance* vulkanInstance;
    

    deserialize_ptr(&vulkanInstance, msg_in.stream, false);

    VkResult* vulkanResult;
    

    deserialize_ptr(&vulkanResult, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateVulkanInstanceKHR(instance, createInfo, vulkanInstance, vulkanResult);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(vulkanInstance, 1, msg_out.buffer);

    
    serialize_ptr(vulkanResult, 1, msg_out.buffer);

}


void handle_xrCreateVulkanDeviceKHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateVulkanDeviceKHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateVulkanDeviceKHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrVulkanDeviceCreateInfoKHR* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    VkDevice* vulkanDevice;
    

    deserialize_ptr(&vulkanDevice, msg_in.stream, false);

    VkResult* vulkanResult;
    

    deserialize_ptr(&vulkanResult, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateVulkanDeviceKHR(instance, createInfo, vulkanDevice, vulkanResult);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(vulkanDevice, 1, msg_out.buffer);

    
    serialize_ptr(vulkanResult, 1, msg_out.buffer);

}


void handle_xrGetVulkanGraphicsDevice2KHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetVulkanGraphicsDevice2KHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetVulkanGraphicsDevice2KHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrVulkanGraphicsDeviceGetInfoKHR* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    VkPhysicalDevice* vulkanPhysicalDevice;
    

    deserialize_ptr(&vulkanPhysicalDevice, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetVulkanGraphicsDevice2KHR(instance, getInfo, vulkanPhysicalDevice);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(vulkanPhysicalDevice, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_enable2
#ifdef XRTRANSPORT_EXT_XR_KHR_composition_layer_equirect2
#endif // XRTRANSPORT_EXT_XR_KHR_composition_layer_equirect2
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_understanding

void handle_xrEnumerateSceneComputeFeaturesMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateSceneComputeFeaturesMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateSceneComputeFeaturesMSFT));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    uint32_t featureCapacityInput;
    

    deserialize(&featureCapacityInput, msg_in.stream, false);

    uint32_t* featureCountOutput;
    

    deserialize_ptr(&featureCountOutput, msg_in.stream, false);

    XrSceneComputeFeatureMSFT* features;
    

    deserialize_ptr(&features, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateSceneComputeFeaturesMSFT(instance, systemId, featureCapacityInput, featureCountOutput, features);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(featureCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(features, featureCapacityInput, msg_out.buffer);

}


void handle_xrCreateSceneObserverMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSceneObserverMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSceneObserverMSFT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSceneObserverCreateInfoMSFT* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSceneObserverMSFT* sceneObserver;
    

    deserialize_ptr(&sceneObserver, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSceneObserverMSFT(session, createInfo, sceneObserver);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(sceneObserver, 1, msg_out.buffer);

}


void handle_xrDestroySceneObserverMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroySceneObserverMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroySceneObserverMSFT));
    // by this point, the function id has already been read, now read the params
    XrSceneObserverMSFT sceneObserver;
    

    deserialize(&sceneObserver, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroySceneObserverMSFT(sceneObserver);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrCreateSceneMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSceneMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSceneMSFT));
    // by this point, the function id has already been read, now read the params
    XrSceneObserverMSFT sceneObserver;
    

    deserialize(&sceneObserver, msg_in.stream, false);

    const XrSceneCreateInfoMSFT* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSceneMSFT* scene;
    

    deserialize_ptr(&scene, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSceneMSFT(sceneObserver, createInfo, scene);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(scene, 1, msg_out.buffer);

}


void handle_xrDestroySceneMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroySceneMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroySceneMSFT));
    // by this point, the function id has already been read, now read the params
    XrSceneMSFT scene;
    

    deserialize(&scene, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroySceneMSFT(scene);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrComputeNewSceneMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrComputeNewSceneMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrComputeNewSceneMSFT));
    // by this point, the function id has already been read, now read the params
    XrSceneObserverMSFT sceneObserver;
    

    deserialize(&sceneObserver, msg_in.stream, false);

    const XrNewSceneComputeInfoMSFT* computeInfo;
    

    deserialize_ptr(&computeInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrComputeNewSceneMSFT(sceneObserver, computeInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetSceneComputeStateMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSceneComputeStateMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSceneComputeStateMSFT));
    // by this point, the function id has already been read, now read the params
    XrSceneObserverMSFT sceneObserver;
    

    deserialize(&sceneObserver, msg_in.stream, false);

    XrSceneComputeStateMSFT* state;
    

    deserialize_ptr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSceneComputeStateMSFT(sceneObserver, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(state, 1, msg_out.buffer);

}


void handle_xrGetSceneComponentsMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSceneComponentsMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSceneComponentsMSFT));
    // by this point, the function id has already been read, now read the params
    XrSceneMSFT scene;
    

    deserialize(&scene, msg_in.stream, false);

    const XrSceneComponentsGetInfoMSFT* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    XrSceneComponentsMSFT* components;
    

    deserialize_ptr(&components, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSceneComponentsMSFT(scene, getInfo, components);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(components, 1, msg_out.buffer);

}


void handle_xrLocateSceneComponentsMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrLocateSceneComponentsMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrLocateSceneComponentsMSFT));
    // by this point, the function id has already been read, now read the params
    XrSceneMSFT scene;
    

    deserialize(&scene, msg_in.stream, false);

    const XrSceneComponentsLocateInfoMSFT* locateInfo;
    

    deserialize_ptr(&locateInfo, msg_in.stream, false);

    XrSceneComponentLocationsMSFT* locations;
    

    deserialize_ptr(&locations, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrLocateSceneComponentsMSFT(scene, locateInfo, locations);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(locations, 1, msg_out.buffer);

}


void handle_xrGetSceneMeshBuffersMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSceneMeshBuffersMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSceneMeshBuffersMSFT));
    // by this point, the function id has already been read, now read the params
    XrSceneMSFT scene;
    

    deserialize(&scene, msg_in.stream, false);

    const XrSceneMeshBuffersGetInfoMSFT* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    XrSceneMeshBuffersMSFT* buffers;
    

    deserialize_ptr(&buffers, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSceneMeshBuffersMSFT(scene, getInfo, buffers);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(buffers, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_MSFT_scene_understanding
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_understanding_serialization

void handle_xrDeserializeSceneMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDeserializeSceneMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDeserializeSceneMSFT));
    // by this point, the function id has already been read, now read the params
    XrSceneObserverMSFT sceneObserver;
    

    deserialize(&sceneObserver, msg_in.stream, false);

    const XrSceneDeserializeInfoMSFT* deserializeInfo;
    

    deserialize_ptr(&deserializeInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDeserializeSceneMSFT(sceneObserver, deserializeInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetSerializedSceneFragmentDataMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSerializedSceneFragmentDataMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSerializedSceneFragmentDataMSFT));
    // by this point, the function id has already been read, now read the params
    XrSceneMSFT scene;
    

    deserialize(&scene, msg_in.stream, false);

    const XrSerializedSceneFragmentDataGetInfoMSFT* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    uint32_t countInput;
    

    deserialize(&countInput, msg_in.stream, false);

    uint32_t* readOutput;
    

    deserialize_ptr(&readOutput, msg_in.stream, false);

    uint8_t* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSerializedSceneFragmentDataMSFT(scene, getInfo, countInput, readOutput, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(readOutput, 1, msg_out.buffer);

    
    serialize_ptr(buffer, countInput, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_MSFT_scene_understanding_serialization
#ifdef XRTRANSPORT_EXT_XR_FB_display_refresh_rate

void handle_xrEnumerateDisplayRefreshRatesFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateDisplayRefreshRatesFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateDisplayRefreshRatesFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    uint32_t displayRefreshRateCapacityInput;
    

    deserialize(&displayRefreshRateCapacityInput, msg_in.stream, false);

    uint32_t* displayRefreshRateCountOutput;
    

    deserialize_ptr(&displayRefreshRateCountOutput, msg_in.stream, false);

    float* displayRefreshRates;
    

    deserialize_ptr(&displayRefreshRates, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateDisplayRefreshRatesFB(session, displayRefreshRateCapacityInput, displayRefreshRateCountOutput, displayRefreshRates);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(displayRefreshRateCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(displayRefreshRates, displayRefreshRateCapacityInput, msg_out.buffer);

}


void handle_xrGetDisplayRefreshRateFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetDisplayRefreshRateFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetDisplayRefreshRateFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    float* displayRefreshRate;
    

    deserialize_ptr(&displayRefreshRate, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetDisplayRefreshRateFB(session, displayRefreshRate);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(displayRefreshRate, 1, msg_out.buffer);

}


void handle_xrRequestDisplayRefreshRateFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrRequestDisplayRefreshRateFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrRequestDisplayRefreshRateFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    float displayRefreshRate;
    

    deserialize(&displayRefreshRate, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrRequestDisplayRefreshRateFB(session, displayRefreshRate);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_FB_display_refresh_rate
#ifdef XRTRANSPORT_EXT_XR_HTCX_vive_tracker_interaction

void handle_xrEnumerateViveTrackerPathsHTCX(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateViveTrackerPathsHTCX", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateViveTrackerPathsHTCX));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    uint32_t pathCapacityInput;
    

    deserialize(&pathCapacityInput, msg_in.stream, false);

    uint32_t* pathCountOutput;
    

    deserialize_ptr(&pathCountOutput, msg_in.stream, false);

    XrViveTrackerPathsHTCX* paths;
    

    deserialize_ptr(&paths, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateViveTrackerPathsHTCX(instance, pathCapacityInput, pathCountOutput, paths);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(pathCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(paths, pathCapacityInput, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_HTCX_vive_tracker_interaction
#ifdef XRTRANSPORT_EXT_XR_HTC_facial_tracking

void handle_xrCreateFacialTrackerHTC(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateFacialTrackerHTC", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateFacialTrackerHTC));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrFacialTrackerCreateInfoHTC* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrFacialTrackerHTC* facialTracker;
    

    deserialize_ptr(&facialTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateFacialTrackerHTC(session, createInfo, facialTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(facialTracker, 1, msg_out.buffer);

}


void handle_xrDestroyFacialTrackerHTC(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyFacialTrackerHTC", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyFacialTrackerHTC));
    // by this point, the function id has already been read, now read the params
    XrFacialTrackerHTC facialTracker;
    

    deserialize(&facialTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyFacialTrackerHTC(facialTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetFacialExpressionsHTC(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetFacialExpressionsHTC", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetFacialExpressionsHTC));
    // by this point, the function id has already been read, now read the params
    XrFacialTrackerHTC facialTracker;
    

    deserialize(&facialTracker, msg_in.stream, false);

    XrFacialExpressionsHTC* facialExpressions;
    

    deserialize_ptr(&facialExpressions, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetFacialExpressionsHTC(facialTracker, facialExpressions);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(facialExpressions, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_HTC_facial_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_color_space

void handle_xrEnumerateColorSpacesFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateColorSpacesFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateColorSpacesFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    uint32_t colorSpaceCapacityInput;
    

    deserialize(&colorSpaceCapacityInput, msg_in.stream, false);

    uint32_t* colorSpaceCountOutput;
    

    deserialize_ptr(&colorSpaceCountOutput, msg_in.stream, false);

    XrColorSpaceFB* colorSpaces;
    

    deserialize_ptr(&colorSpaces, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateColorSpacesFB(session, colorSpaceCapacityInput, colorSpaceCountOutput, colorSpaces);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(colorSpaceCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(colorSpaces, colorSpaceCapacityInput, msg_out.buffer);

}


void handle_xrSetColorSpaceFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetColorSpaceFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetColorSpaceFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrColorSpaceFB colorSpace;
    

    deserialize(&colorSpace, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetColorSpaceFB(session, colorSpace);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_FB_color_space
#ifdef XRTRANSPORT_EXT_XR_FB_hand_tracking_mesh

void handle_xrGetHandMeshFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetHandMeshFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetHandMeshFB));
    // by this point, the function id has already been read, now read the params
    XrHandTrackerEXT handTracker;
    

    deserialize(&handTracker, msg_in.stream, false);

    XrHandTrackingMeshFB* mesh;
    

    deserialize_ptr(&mesh, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetHandMeshFB(handTracker, mesh);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(mesh, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_hand_tracking_mesh
#ifdef XRTRANSPORT_EXT_XR_FB_hand_tracking_aim
#endif // XRTRANSPORT_EXT_XR_FB_hand_tracking_aim
#ifdef XRTRANSPORT_EXT_XR_FB_hand_tracking_capsules
#endif // XRTRANSPORT_EXT_XR_FB_hand_tracking_capsules
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity

void handle_xrCreateSpatialAnchorFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialAnchorFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpatialAnchorCreateInfoFB* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrAsyncRequestIdFB* requestId;
    

    deserialize_ptr(&requestId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorFB(session, info, requestId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(requestId, 1, msg_out.buffer);

}


void handle_xrGetSpaceUuidFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpaceUuidFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpaceUuidFB));
    // by this point, the function id has already been read, now read the params
    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);

    XrUuidEXT* uuid;
    

    deserialize_ptr(&uuid, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpaceUuidFB(space, uuid);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(uuid, 1, msg_out.buffer);

}


void handle_xrEnumerateSpaceSupportedComponentsFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateSpaceSupportedComponentsFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateSpaceSupportedComponentsFB));
    // by this point, the function id has already been read, now read the params
    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);

    uint32_t componentTypeCapacityInput;
    

    deserialize(&componentTypeCapacityInput, msg_in.stream, false);

    uint32_t* componentTypeCountOutput;
    

    deserialize_ptr(&componentTypeCountOutput, msg_in.stream, false);

    XrSpaceComponentTypeFB* componentTypes;
    

    deserialize_ptr(&componentTypes, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateSpaceSupportedComponentsFB(space, componentTypeCapacityInput, componentTypeCountOutput, componentTypes);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(componentTypeCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(componentTypes, componentTypeCapacityInput, msg_out.buffer);

}


void handle_xrSetSpaceComponentStatusFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetSpaceComponentStatusFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetSpaceComponentStatusFB));
    // by this point, the function id has already been read, now read the params
    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);

    const XrSpaceComponentStatusSetInfoFB* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrAsyncRequestIdFB* requestId;
    

    deserialize_ptr(&requestId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetSpaceComponentStatusFB(space, info, requestId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(requestId, 1, msg_out.buffer);

}


void handle_xrGetSpaceComponentStatusFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpaceComponentStatusFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpaceComponentStatusFB));
    // by this point, the function id has already been read, now read the params
    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);

    XrSpaceComponentTypeFB componentType;
    

    deserialize(&componentType, msg_in.stream, false);

    XrSpaceComponentStatusFB* status;
    

    deserialize_ptr(&status, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpaceComponentStatusFB(space, componentType, status);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(status, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity
#ifdef XRTRANSPORT_EXT_XR_FB_foveation

void handle_xrCreateFoveationProfileFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateFoveationProfileFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateFoveationProfileFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrFoveationProfileCreateInfoFB* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrFoveationProfileFB* profile;
    

    deserialize_ptr(&profile, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateFoveationProfileFB(session, createInfo, profile);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_xr(createInfo->next, msg_out.buffer);

    
    serialize_ptr(profile, 1, msg_out.buffer);

}


void handle_xrDestroyFoveationProfileFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyFoveationProfileFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyFoveationProfileFB));
    // by this point, the function id has already been read, now read the params
    XrFoveationProfileFB profile;
    

    deserialize(&profile, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyFoveationProfileFB(profile);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_FB_foveation
#ifdef XRTRANSPORT_EXT_XR_FB_foveation_configuration
#endif // XRTRANSPORT_EXT_XR_FB_foveation_configuration
#ifdef XRTRANSPORT_EXT_XR_FB_keyboard_tracking

void handle_xrQuerySystemTrackedKeyboardFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrQuerySystemTrackedKeyboardFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrQuerySystemTrackedKeyboardFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrKeyboardTrackingQueryFB* queryInfo;
    

    deserialize_ptr(&queryInfo, msg_in.stream, false);

    XrKeyboardTrackingDescriptionFB* keyboard;
    

    deserialize_ptr(&keyboard, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrQuerySystemTrackedKeyboardFB(session, queryInfo, keyboard);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_xr(queryInfo->next, msg_out.buffer);

    
    serialize_ptr(keyboard, 1, msg_out.buffer);

}


void handle_xrCreateKeyboardSpaceFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateKeyboardSpaceFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateKeyboardSpaceFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrKeyboardSpaceCreateInfoFB* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpace* keyboardSpace;
    

    deserialize_ptr(&keyboardSpace, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateKeyboardSpaceFB(session, createInfo, keyboardSpace);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_xr(createInfo->next, msg_out.buffer);

    
    serialize_ptr(keyboardSpace, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_keyboard_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_triangle_mesh

void handle_xrCreateTriangleMeshFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateTriangleMeshFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateTriangleMeshFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrTriangleMeshCreateInfoFB* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrTriangleMeshFB* outTriangleMesh;
    

    deserialize_ptr(&outTriangleMesh, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateTriangleMeshFB(session, createInfo, outTriangleMesh);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(outTriangleMesh, 1, msg_out.buffer);

}


void handle_xrDestroyTriangleMeshFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyTriangleMeshFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyTriangleMeshFB));
    // by this point, the function id has already been read, now read the params
    XrTriangleMeshFB mesh;
    

    deserialize(&mesh, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyTriangleMeshFB(mesh);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrTriangleMeshGetVertexBufferFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrTriangleMeshGetVertexBufferFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrTriangleMeshGetVertexBufferFB));
    // by this point, the function id has already been read, now read the params
    XrTriangleMeshFB mesh;
    

    deserialize(&mesh, msg_in.stream, false);

    XrVector3f** outVertexBuffer;
    

    #error "auto-generator doesn't support double pointers (outVertexBuffer)"
    None

    XrResult _result = function_loader.pfn_xrTriangleMeshGetVertexBufferFB(mesh, outVertexBuffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(outVertexBuffer, 1, msg_out.buffer);

}


void handle_xrTriangleMeshGetIndexBufferFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrTriangleMeshGetIndexBufferFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrTriangleMeshGetIndexBufferFB));
    // by this point, the function id has already been read, now read the params
    XrTriangleMeshFB mesh;
    

    deserialize(&mesh, msg_in.stream, false);

    uint32_t** outIndexBuffer;
    

    #error "auto-generator doesn't support double pointers (outIndexBuffer)"
    None

    XrResult _result = function_loader.pfn_xrTriangleMeshGetIndexBufferFB(mesh, outIndexBuffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(outIndexBuffer, 1, msg_out.buffer);

}


void handle_xrTriangleMeshBeginUpdateFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrTriangleMeshBeginUpdateFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrTriangleMeshBeginUpdateFB));
    // by this point, the function id has already been read, now read the params
    XrTriangleMeshFB mesh;
    

    deserialize(&mesh, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrTriangleMeshBeginUpdateFB(mesh);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrTriangleMeshEndUpdateFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrTriangleMeshEndUpdateFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrTriangleMeshEndUpdateFB));
    // by this point, the function id has already been read, now read the params
    XrTriangleMeshFB mesh;
    

    deserialize(&mesh, msg_in.stream, false);

    uint32_t vertexCount;
    

    deserialize(&vertexCount, msg_in.stream, false);

    uint32_t triangleCount;
    

    deserialize(&triangleCount, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrTriangleMeshEndUpdateFB(mesh, vertexCount, triangleCount);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrTriangleMeshBeginVertexBufferUpdateFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrTriangleMeshBeginVertexBufferUpdateFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrTriangleMeshBeginVertexBufferUpdateFB));
    // by this point, the function id has already been read, now read the params
    XrTriangleMeshFB mesh;
    

    deserialize(&mesh, msg_in.stream, false);

    uint32_t* outVertexCount;
    

    deserialize_ptr(&outVertexCount, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrTriangleMeshBeginVertexBufferUpdateFB(mesh, outVertexCount);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(outVertexCount, 1, msg_out.buffer);

}


void handle_xrTriangleMeshEndVertexBufferUpdateFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrTriangleMeshEndVertexBufferUpdateFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrTriangleMeshEndVertexBufferUpdateFB));
    // by this point, the function id has already been read, now read the params
    XrTriangleMeshFB mesh;
    

    deserialize(&mesh, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrTriangleMeshEndVertexBufferUpdateFB(mesh);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_FB_triangle_mesh
#ifdef XRTRANSPORT_EXT_XR_FB_passthrough

void handle_xrCreatePassthroughFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreatePassthroughFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreatePassthroughFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrPassthroughCreateInfoFB* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrPassthroughFB* outPassthrough;
    

    deserialize_ptr(&outPassthrough, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreatePassthroughFB(session, createInfo, outPassthrough);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(outPassthrough, 1, msg_out.buffer);

}


void handle_xrDestroyPassthroughFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyPassthroughFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyPassthroughFB));
    // by this point, the function id has already been read, now read the params
    XrPassthroughFB passthrough;
    

    deserialize(&passthrough, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyPassthroughFB(passthrough);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrPassthroughStartFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPassthroughStartFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPassthroughStartFB));
    // by this point, the function id has already been read, now read the params
    XrPassthroughFB passthrough;
    

    deserialize(&passthrough, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPassthroughStartFB(passthrough);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrPassthroughPauseFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPassthroughPauseFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPassthroughPauseFB));
    // by this point, the function id has already been read, now read the params
    XrPassthroughFB passthrough;
    

    deserialize(&passthrough, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPassthroughPauseFB(passthrough);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrCreatePassthroughLayerFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreatePassthroughLayerFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreatePassthroughLayerFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrPassthroughLayerCreateInfoFB* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrPassthroughLayerFB* outLayer;
    

    deserialize_ptr(&outLayer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreatePassthroughLayerFB(session, createInfo, outLayer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(outLayer, 1, msg_out.buffer);

}


void handle_xrDestroyPassthroughLayerFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyPassthroughLayerFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyPassthroughLayerFB));
    // by this point, the function id has already been read, now read the params
    XrPassthroughLayerFB layer;
    

    deserialize(&layer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyPassthroughLayerFB(layer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrPassthroughLayerPauseFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPassthroughLayerPauseFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPassthroughLayerPauseFB));
    // by this point, the function id has already been read, now read the params
    XrPassthroughLayerFB layer;
    

    deserialize(&layer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPassthroughLayerPauseFB(layer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrPassthroughLayerResumeFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPassthroughLayerResumeFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPassthroughLayerResumeFB));
    // by this point, the function id has already been read, now read the params
    XrPassthroughLayerFB layer;
    

    deserialize(&layer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPassthroughLayerResumeFB(layer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrPassthroughLayerSetStyleFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPassthroughLayerSetStyleFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPassthroughLayerSetStyleFB));
    // by this point, the function id has already been read, now read the params
    XrPassthroughLayerFB layer;
    

    deserialize(&layer, msg_in.stream, false);

    const XrPassthroughStyleFB* style;
    

    deserialize_ptr(&style, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPassthroughLayerSetStyleFB(layer, style);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrCreateGeometryInstanceFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateGeometryInstanceFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateGeometryInstanceFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrGeometryInstanceCreateInfoFB* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrGeometryInstanceFB* outGeometryInstance;
    

    deserialize_ptr(&outGeometryInstance, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateGeometryInstanceFB(session, createInfo, outGeometryInstance);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(outGeometryInstance, 1, msg_out.buffer);

}


void handle_xrDestroyGeometryInstanceFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyGeometryInstanceFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyGeometryInstanceFB));
    // by this point, the function id has already been read, now read the params
    XrGeometryInstanceFB instance;
    

    deserialize(&instance, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyGeometryInstanceFB(instance);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGeometryInstanceSetTransformFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGeometryInstanceSetTransformFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGeometryInstanceSetTransformFB));
    // by this point, the function id has already been read, now read the params
    XrGeometryInstanceFB instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrGeometryInstanceTransformFB* transformation;
    

    deserialize_ptr(&transformation, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGeometryInstanceSetTransformFB(instance, transformation);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_FB_passthrough
#ifdef XRTRANSPORT_EXT_XR_FB_render_model

void handle_xrEnumerateRenderModelPathsFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateRenderModelPathsFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateRenderModelPathsFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    uint32_t pathCapacityInput;
    

    deserialize(&pathCapacityInput, msg_in.stream, false);

    uint32_t* pathCountOutput;
    

    deserialize_ptr(&pathCountOutput, msg_in.stream, false);

    XrRenderModelPathInfoFB* paths;
    

    deserialize_ptr(&paths, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateRenderModelPathsFB(session, pathCapacityInput, pathCountOutput, paths);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(pathCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(paths, pathCapacityInput, msg_out.buffer);

}


void handle_xrGetRenderModelPropertiesFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetRenderModelPropertiesFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetRenderModelPropertiesFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrPath path;
    

    deserialize(&path, msg_in.stream, false);

    XrRenderModelPropertiesFB* properties;
    

    deserialize_ptr(&properties, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetRenderModelPropertiesFB(session, path, properties);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(properties, 1, msg_out.buffer);

}


void handle_xrLoadRenderModelFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrLoadRenderModelFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrLoadRenderModelFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrRenderModelLoadInfoFB* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrRenderModelBufferFB* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrLoadRenderModelFB(session, info, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_xr(info->next, msg_out.buffer);

    
    serialize_ptr(buffer, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_render_model
#ifdef XRTRANSPORT_EXT_XR_KHR_binding_modification
#endif // XRTRANSPORT_EXT_XR_KHR_binding_modification
#ifdef XRTRANSPORT_EXT_XR_VARJO_foveated_rendering
#endif // XRTRANSPORT_EXT_XR_VARJO_foveated_rendering
#ifdef XRTRANSPORT_EXT_XR_VARJO_composition_layer_depth_test
#endif // XRTRANSPORT_EXT_XR_VARJO_composition_layer_depth_test
#ifdef XRTRANSPORT_EXT_XR_VARJO_environment_depth_estimation

void handle_xrSetEnvironmentDepthEstimationVARJO(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetEnvironmentDepthEstimationVARJO", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetEnvironmentDepthEstimationVARJO));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrBool32 enabled;
    

    deserialize(&enabled, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetEnvironmentDepthEstimationVARJO(session, enabled);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_VARJO_environment_depth_estimation
#ifdef XRTRANSPORT_EXT_XR_VARJO_marker_tracking

void handle_xrSetMarkerTrackingVARJO(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetMarkerTrackingVARJO", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetMarkerTrackingVARJO));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrBool32 enabled;
    

    deserialize(&enabled, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetMarkerTrackingVARJO(session, enabled);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrSetMarkerTrackingTimeoutVARJO(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetMarkerTrackingTimeoutVARJO", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetMarkerTrackingTimeoutVARJO));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    uint64_t markerId;
    

    deserialize(&markerId, msg_in.stream, false);

    XrDuration timeout;
    

    deserialize(&timeout, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetMarkerTrackingTimeoutVARJO(session, markerId, timeout);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrSetMarkerTrackingPredictionVARJO(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetMarkerTrackingPredictionVARJO", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetMarkerTrackingPredictionVARJO));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    uint64_t markerId;
    

    deserialize(&markerId, msg_in.stream, false);

    XrBool32 enable;
    

    deserialize(&enable, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetMarkerTrackingPredictionVARJO(session, markerId, enable);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetMarkerSizeVARJO(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetMarkerSizeVARJO", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetMarkerSizeVARJO));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    uint64_t markerId;
    

    deserialize(&markerId, msg_in.stream, false);

    XrExtent2Df* size;
    

    deserialize_ptr(&size, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetMarkerSizeVARJO(session, markerId, size);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(size, 1, msg_out.buffer);

}


void handle_xrCreateMarkerSpaceVARJO(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateMarkerSpaceVARJO", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateMarkerSpaceVARJO));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrMarkerSpaceCreateInfoVARJO* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpace* space;
    

    deserialize_ptr(&space, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateMarkerSpaceVARJO(session, createInfo, space);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(space, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_VARJO_marker_tracking
#ifdef XRTRANSPORT_EXT_XR_VARJO_view_offset

void handle_xrSetViewOffsetVARJO(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetViewOffsetVARJO", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetViewOffsetVARJO));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    float offset;
    

    deserialize(&offset, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetViewOffsetVARJO(session, offset);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_VARJO_view_offset
#ifdef XRTRANSPORT_EXT_XR_ML_frame_end_info
#endif // XRTRANSPORT_EXT_XR_ML_frame_end_info
#ifdef XRTRANSPORT_EXT_XR_ML_global_dimmer
#endif // XRTRANSPORT_EXT_XR_ML_global_dimmer
#ifdef XRTRANSPORT_EXT_XR_ML_compat

void handle_xrCreateSpaceFromCoordinateFrameUIDML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpaceFromCoordinateFrameUIDML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpaceFromCoordinateFrameUIDML));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrCoordinateSpaceCreateInfoML* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpace* space;
    

    deserialize_ptr(&space, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpaceFromCoordinateFrameUIDML(session, createInfo, space);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(space, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_ML_compat
#ifdef XRTRANSPORT_EXT_XR_ML_marker_understanding

void handle_xrCreateMarkerDetectorML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateMarkerDetectorML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateMarkerDetectorML));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrMarkerDetectorCreateInfoML* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrMarkerDetectorML* markerDetector;
    

    deserialize_ptr(&markerDetector, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateMarkerDetectorML(session, createInfo, markerDetector);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(markerDetector, 1, msg_out.buffer);

}


void handle_xrDestroyMarkerDetectorML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyMarkerDetectorML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyMarkerDetectorML));
    // by this point, the function id has already been read, now read the params
    XrMarkerDetectorML markerDetector;
    

    deserialize(&markerDetector, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyMarkerDetectorML(markerDetector);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrSnapshotMarkerDetectorML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSnapshotMarkerDetectorML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSnapshotMarkerDetectorML));
    // by this point, the function id has already been read, now read the params
    XrMarkerDetectorML markerDetector;
    

    deserialize(&markerDetector, msg_in.stream, false);

    XrMarkerDetectorSnapshotInfoML* snapshotInfo;
    

    deserialize_ptr(&snapshotInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSnapshotMarkerDetectorML(markerDetector, snapshotInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(snapshotInfo, 1, msg_out.buffer);

}


void handle_xrGetMarkerDetectorStateML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetMarkerDetectorStateML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetMarkerDetectorStateML));
    // by this point, the function id has already been read, now read the params
    XrMarkerDetectorML markerDetector;
    

    deserialize(&markerDetector, msg_in.stream, false);

    XrMarkerDetectorStateML* state;
    

    deserialize_ptr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetMarkerDetectorStateML(markerDetector, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(state, 1, msg_out.buffer);

}


void handle_xrGetMarkersML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetMarkersML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetMarkersML));
    // by this point, the function id has already been read, now read the params
    XrMarkerDetectorML markerDetector;
    

    deserialize(&markerDetector, msg_in.stream, false);

    uint32_t markerCapacityInput;
    

    deserialize(&markerCapacityInput, msg_in.stream, false);

    uint32_t* markerCountOutput;
    

    deserialize_ptr(&markerCountOutput, msg_in.stream, false);

    XrMarkerML* markers;
    

    deserialize_ptr(&markers, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetMarkersML(markerDetector, markerCapacityInput, markerCountOutput, markers);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(markerCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(markers, markerCapacityInput, msg_out.buffer);

}


void handle_xrGetMarkerReprojectionErrorML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetMarkerReprojectionErrorML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetMarkerReprojectionErrorML));
    // by this point, the function id has already been read, now read the params
    XrMarkerDetectorML markerDetector;
    

    deserialize(&markerDetector, msg_in.stream, false);

    XrMarkerML marker;
    

    deserialize(&marker, msg_in.stream, false);

    float* reprojectionErrorMeters;
    

    deserialize_ptr(&reprojectionErrorMeters, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetMarkerReprojectionErrorML(markerDetector, marker, reprojectionErrorMeters);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(reprojectionErrorMeters, 1, msg_out.buffer);

}


void handle_xrGetMarkerLengthML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetMarkerLengthML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetMarkerLengthML));
    // by this point, the function id has already been read, now read the params
    XrMarkerDetectorML markerDetector;
    

    deserialize(&markerDetector, msg_in.stream, false);

    XrMarkerML marker;
    

    deserialize(&marker, msg_in.stream, false);

    float* meters;
    

    deserialize_ptr(&meters, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetMarkerLengthML(markerDetector, marker, meters);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(meters, 1, msg_out.buffer);

}


void handle_xrGetMarkerNumberML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetMarkerNumberML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetMarkerNumberML));
    // by this point, the function id has already been read, now read the params
    XrMarkerDetectorML markerDetector;
    

    deserialize(&markerDetector, msg_in.stream, false);

    XrMarkerML marker;
    

    deserialize(&marker, msg_in.stream, false);

    uint64_t* number;
    

    deserialize_ptr(&number, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetMarkerNumberML(markerDetector, marker, number);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(number, 1, msg_out.buffer);

}


void handle_xrGetMarkerStringML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetMarkerStringML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetMarkerStringML));
    // by this point, the function id has already been read, now read the params
    XrMarkerDetectorML markerDetector;
    

    deserialize(&markerDetector, msg_in.stream, false);

    XrMarkerML marker;
    

    deserialize(&marker, msg_in.stream, false);

    uint32_t bufferCapacityInput;
    

    deserialize(&bufferCapacityInput, msg_in.stream, false);

    uint32_t* bufferCountOutput;
    

    deserialize_ptr(&bufferCountOutput, msg_in.stream, false);

    char* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetMarkerStringML(markerDetector, marker, bufferCapacityInput, bufferCountOutput, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(bufferCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(buffer, bufferCapacityInput, msg_out.buffer);

}


void handle_xrCreateMarkerSpaceML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateMarkerSpaceML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateMarkerSpaceML));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrMarkerSpaceCreateInfoML* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpace* space;
    

    deserialize_ptr(&space, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateMarkerSpaceML(session, createInfo, space);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(space, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_ML_marker_understanding
#ifdef XRTRANSPORT_EXT_XR_ML_localization_map

void handle_xrEnableLocalizationEventsML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnableLocalizationEventsML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnableLocalizationEventsML));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrLocalizationEnableEventsInfoML* info;
    

    deserialize_ptr(&info, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnableLocalizationEventsML(session, info);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrQueryLocalizationMapsML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrQueryLocalizationMapsML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrQueryLocalizationMapsML));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrLocalizationMapQueryInfoBaseHeaderML* queryInfo;
    

    deserialize_xr(&queryInfo, msg_in.stream, false);

    uint32_t mapCapacityInput;
    

    deserialize(&mapCapacityInput, msg_in.stream, false);

    uint32_t* mapCountOutput;
    

    deserialize_ptr(&mapCountOutput, msg_in.stream, false);

    XrLocalizationMapML* maps;
    

    deserialize_ptr(&maps, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrQueryLocalizationMapsML(session, queryInfo, mapCapacityInput, mapCountOutput, maps);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(mapCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(maps, mapCapacityInput, msg_out.buffer);

}


void handle_xrRequestMapLocalizationML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrRequestMapLocalizationML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrRequestMapLocalizationML));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrMapLocalizationRequestInfoML* requestInfo;
    

    deserialize_ptr(&requestInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrRequestMapLocalizationML(session, requestInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrImportLocalizationMapML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrImportLocalizationMapML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrImportLocalizationMapML));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrLocalizationMapImportInfoML* importInfo;
    

    deserialize_ptr(&importInfo, msg_in.stream, false);

    XrUuidEXT* mapUuid;
    

    deserialize_ptr(&mapUuid, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrImportLocalizationMapML(session, importInfo, mapUuid);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(importInfo->data, importInfo->size, msg_out.buffer);

    
    serialize_ptr(mapUuid, 1, msg_out.buffer);

}


void handle_xrCreateExportedLocalizationMapML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateExportedLocalizationMapML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateExportedLocalizationMapML));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrUuidEXT* mapUuid;
    

    deserialize_ptr(&mapUuid, msg_in.stream, false);

    XrExportedLocalizationMapML* map;
    

    deserialize_ptr(&map, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateExportedLocalizationMapML(session, mapUuid, map);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(map, 1, msg_out.buffer);

}


void handle_xrDestroyExportedLocalizationMapML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyExportedLocalizationMapML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyExportedLocalizationMapML));
    // by this point, the function id has already been read, now read the params
    XrExportedLocalizationMapML map;
    

    deserialize(&map, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyExportedLocalizationMapML(map);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetExportedLocalizationMapDataML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetExportedLocalizationMapDataML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetExportedLocalizationMapDataML));
    // by this point, the function id has already been read, now read the params
    XrExportedLocalizationMapML map;
    

    deserialize(&map, msg_in.stream, false);

    uint32_t bufferCapacityInput;
    

    deserialize(&bufferCapacityInput, msg_in.stream, false);

    uint32_t* bufferCountOutput;
    

    deserialize_ptr(&bufferCountOutput, msg_in.stream, false);

    char* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetExportedLocalizationMapDataML(map, bufferCapacityInput, bufferCountOutput, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(bufferCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(buffer, bufferCapacityInput, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_ML_localization_map
#ifdef XRTRANSPORT_EXT_XR_ML_spatial_anchors

void handle_xrCreateSpatialAnchorsAsyncML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorsAsyncML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialAnchorsAsyncML));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpatialAnchorsCreateInfoBaseHeaderML* createInfo;
    

    deserialize_xr(&createInfo, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorsAsyncML(session, createInfo, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrCreateSpatialAnchorsCompleteML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorsCompleteML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialAnchorsCompleteML));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrCreateSpatialAnchorsCompletionML* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorsCompleteML(session, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}


void handle_xrGetSpatialAnchorStateML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpatialAnchorStateML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpatialAnchorStateML));
    // by this point, the function id has already been read, now read the params
    XrSpace anchor;
    

    deserialize(&anchor, msg_in.stream, false);

    XrSpatialAnchorStateML* state;
    

    deserialize_ptr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpatialAnchorStateML(anchor, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(state, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_ML_spatial_anchors
#ifdef XRTRANSPORT_EXT_XR_ML_spatial_anchors_storage

void handle_xrCreateSpatialAnchorsStorageML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorsStorageML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialAnchorsStorageML));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpatialAnchorsCreateStorageInfoML* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpatialAnchorsStorageML* storage;
    

    deserialize_ptr(&storage, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorsStorageML(session, createInfo, storage);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(storage, 1, msg_out.buffer);

}


void handle_xrDestroySpatialAnchorsStorageML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroySpatialAnchorsStorageML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroySpatialAnchorsStorageML));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorsStorageML storage;
    

    deserialize(&storage, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroySpatialAnchorsStorageML(storage);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrQuerySpatialAnchorsAsyncML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrQuerySpatialAnchorsAsyncML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrQuerySpatialAnchorsAsyncML));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorsStorageML storage;
    

    deserialize(&storage, msg_in.stream, false);

    const XrSpatialAnchorsQueryInfoBaseHeaderML* queryInfo;
    

    deserialize_xr(&queryInfo, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrQuerySpatialAnchorsAsyncML(storage, queryInfo, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrQuerySpatialAnchorsCompleteML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrQuerySpatialAnchorsCompleteML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrQuerySpatialAnchorsCompleteML));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorsStorageML storage;
    

    deserialize(&storage, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrSpatialAnchorsQueryCompletionML* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrQuerySpatialAnchorsCompleteML(storage, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}


void handle_xrPublishSpatialAnchorsAsyncML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPublishSpatialAnchorsAsyncML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPublishSpatialAnchorsAsyncML));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorsStorageML storage;
    

    deserialize(&storage, msg_in.stream, false);

    const XrSpatialAnchorsPublishInfoML* publishInfo;
    

    deserialize_ptr(&publishInfo, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPublishSpatialAnchorsAsyncML(storage, publishInfo, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrPublishSpatialAnchorsCompleteML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPublishSpatialAnchorsCompleteML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPublishSpatialAnchorsCompleteML));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorsStorageML storage;
    

    deserialize(&storage, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrSpatialAnchorsPublishCompletionML* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPublishSpatialAnchorsCompleteML(storage, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}


void handle_xrDeleteSpatialAnchorsAsyncML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDeleteSpatialAnchorsAsyncML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDeleteSpatialAnchorsAsyncML));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorsStorageML storage;
    

    deserialize(&storage, msg_in.stream, false);

    const XrSpatialAnchorsDeleteInfoML* deleteInfo;
    

    deserialize_ptr(&deleteInfo, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDeleteSpatialAnchorsAsyncML(storage, deleteInfo, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrDeleteSpatialAnchorsCompleteML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDeleteSpatialAnchorsCompleteML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDeleteSpatialAnchorsCompleteML));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorsStorageML storage;
    

    deserialize(&storage, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrSpatialAnchorsDeleteCompletionML* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDeleteSpatialAnchorsCompleteML(storage, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}


void handle_xrUpdateSpatialAnchorsExpirationAsyncML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrUpdateSpatialAnchorsExpirationAsyncML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrUpdateSpatialAnchorsExpirationAsyncML));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorsStorageML storage;
    

    deserialize(&storage, msg_in.stream, false);

    const XrSpatialAnchorsUpdateExpirationInfoML* updateInfo;
    

    deserialize_ptr(&updateInfo, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrUpdateSpatialAnchorsExpirationAsyncML(storage, updateInfo, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrUpdateSpatialAnchorsExpirationCompleteML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrUpdateSpatialAnchorsExpirationCompleteML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrUpdateSpatialAnchorsExpirationCompleteML));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorsStorageML storage;
    

    deserialize(&storage, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrSpatialAnchorsUpdateExpirationCompletionML* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrUpdateSpatialAnchorsExpirationCompleteML(storage, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_ML_spatial_anchors_storage
#ifdef XRTRANSPORT_EXT_XR_ML_user_calibration

void handle_xrEnableUserCalibrationEventsML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnableUserCalibrationEventsML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnableUserCalibrationEventsML));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrUserCalibrationEnableEventsInfoML* enableInfo;
    

    deserialize_ptr(&enableInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnableUserCalibrationEventsML(instance, enableInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_ML_user_calibration
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_anchor_persistence

void handle_xrCreateSpatialAnchorStoreConnectionMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorStoreConnectionMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialAnchorStoreConnectionMSFT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrSpatialAnchorStoreConnectionMSFT* spatialAnchorStore;
    

    deserialize_ptr(&spatialAnchorStore, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorStoreConnectionMSFT(session, spatialAnchorStore);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(spatialAnchorStore, 1, msg_out.buffer);

}


void handle_xrDestroySpatialAnchorStoreConnectionMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroySpatialAnchorStoreConnectionMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroySpatialAnchorStoreConnectionMSFT));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore;
    

    deserialize(&spatialAnchorStore, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroySpatialAnchorStoreConnectionMSFT(spatialAnchorStore);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrPersistSpatialAnchorMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPersistSpatialAnchorMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPersistSpatialAnchorMSFT));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore;
    

    deserialize(&spatialAnchorStore, msg_in.stream, false);

    const XrSpatialAnchorPersistenceInfoMSFT* spatialAnchorPersistenceInfo;
    

    deserialize_ptr(&spatialAnchorPersistenceInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrEnumeratePersistedSpatialAnchorNamesMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumeratePersistedSpatialAnchorNamesMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumeratePersistedSpatialAnchorNamesMSFT));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore;
    

    deserialize(&spatialAnchorStore, msg_in.stream, false);

    uint32_t spatialAnchorNameCapacityInput;
    

    deserialize(&spatialAnchorNameCapacityInput, msg_in.stream, false);

    uint32_t* spatialAnchorNameCountOutput;
    

    deserialize_ptr(&spatialAnchorNameCountOutput, msg_in.stream, false);

    XrSpatialAnchorPersistenceNameMSFT* spatialAnchorNames;
    

    deserialize_ptr(&spatialAnchorNames, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumeratePersistedSpatialAnchorNamesMSFT(spatialAnchorStore, spatialAnchorNameCapacityInput, spatialAnchorNameCountOutput, spatialAnchorNames);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(spatialAnchorNameCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(spatialAnchorNames, spatialAnchorNameCapacityInput, msg_out.buffer);

}


void handle_xrCreateSpatialAnchorFromPersistedNameMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorFromPersistedNameMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialAnchorFromPersistedNameMSFT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* spatialAnchorCreateInfo;
    

    deserialize_ptr(&spatialAnchorCreateInfo, msg_in.stream, false);

    XrSpatialAnchorMSFT* spatialAnchor;
    

    deserialize_ptr(&spatialAnchor, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorFromPersistedNameMSFT(session, spatialAnchorCreateInfo, spatialAnchor);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(spatialAnchor, 1, msg_out.buffer);

}


void handle_xrUnpersistSpatialAnchorMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrUnpersistSpatialAnchorMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrUnpersistSpatialAnchorMSFT));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore;
    

    deserialize(&spatialAnchorStore, msg_in.stream, false);

    const XrSpatialAnchorPersistenceNameMSFT* spatialAnchorPersistenceName;
    

    deserialize_ptr(&spatialAnchorPersistenceName, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrUnpersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceName);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrClearSpatialAnchorStoreMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrClearSpatialAnchorStoreMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrClearSpatialAnchorStoreMSFT));
    // by this point, the function id has already been read, now read the params
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore;
    

    deserialize(&spatialAnchorStore, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrClearSpatialAnchorStoreMSFT(spatialAnchorStore);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_anchor_persistence
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_marker

void handle_xrGetSceneMarkerRawDataMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSceneMarkerRawDataMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSceneMarkerRawDataMSFT));
    // by this point, the function id has already been read, now read the params
    XrSceneMSFT scene;
    

    deserialize(&scene, msg_in.stream, false);

    const XrUuidMSFT* markerId;
    

    deserialize_ptr(&markerId, msg_in.stream, false);

    uint32_t bufferCapacityInput;
    

    deserialize(&bufferCapacityInput, msg_in.stream, false);

    uint32_t* bufferCountOutput;
    

    deserialize_ptr(&bufferCountOutput, msg_in.stream, false);

    uint8_t* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSceneMarkerRawDataMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(bufferCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(buffer, bufferCapacityInput, msg_out.buffer);

}


void handle_xrGetSceneMarkerDecodedStringMSFT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSceneMarkerDecodedStringMSFT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSceneMarkerDecodedStringMSFT));
    // by this point, the function id has already been read, now read the params
    XrSceneMSFT scene;
    

    deserialize(&scene, msg_in.stream, false);

    const XrUuidMSFT* markerId;
    

    deserialize_ptr(&markerId, msg_in.stream, false);

    uint32_t bufferCapacityInput;
    

    deserialize(&bufferCapacityInput, msg_in.stream, false);

    uint32_t* bufferCountOutput;
    

    deserialize_ptr(&bufferCountOutput, msg_in.stream, false);

    char* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSceneMarkerDecodedStringMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(bufferCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(buffer, bufferCapacityInput, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_MSFT_scene_marker
#ifdef XRTRANSPORT_EXT_XR_KHR_extended_struct_name_lengths

void handle_xrStructureTypeToString2KHR(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrStructureTypeToString2KHR", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrStructureTypeToString2KHR));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrStructureType value;
    

    deserialize(&value, msg_in.stream, false);

    char buffer[XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR];
    

    deserialize_array(buffer, XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrStructureTypeToString2KHR(instance, value, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(buffer, XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_KHR_extended_struct_name_lengths
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_query

void handle_xrQuerySpacesFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrQuerySpacesFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrQuerySpacesFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpaceQueryInfoBaseHeaderFB* info;
    

    deserialize_xr(&info, msg_in.stream, false);

    XrAsyncRequestIdFB* requestId;
    

    deserialize_ptr(&requestId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrQuerySpacesFB(session, info, requestId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(requestId, 1, msg_out.buffer);

}


void handle_xrRetrieveSpaceQueryResultsFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrRetrieveSpaceQueryResultsFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrRetrieveSpaceQueryResultsFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrAsyncRequestIdFB requestId;
    

    deserialize(&requestId, msg_in.stream, false);

    XrSpaceQueryResultsFB* results;
    

    deserialize_ptr(&results, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrRetrieveSpaceQueryResultsFB(session, requestId, results);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(results, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_query
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_storage

void handle_xrSaveSpaceFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSaveSpaceFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSaveSpaceFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpaceSaveInfoFB* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrAsyncRequestIdFB* requestId;
    

    deserialize_ptr(&requestId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSaveSpaceFB(session, info, requestId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(requestId, 1, msg_out.buffer);

}


void handle_xrEraseSpaceFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEraseSpaceFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEraseSpaceFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpaceEraseInfoFB* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrAsyncRequestIdFB* requestId;
    

    deserialize_ptr(&requestId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEraseSpaceFB(session, info, requestId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(requestId, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_storage
#ifdef XRTRANSPORT_EXT_XR_OCULUS_audio_device_guid

void handle_xrGetAudioOutputDeviceGuidOculus(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetAudioOutputDeviceGuidOculus", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetAudioOutputDeviceGuidOculus));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS];
    

    deserialize_array(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetAudioOutputDeviceGuidOculus(instance, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS, msg_out.buffer);

}


void handle_xrGetAudioInputDeviceGuidOculus(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetAudioInputDeviceGuidOculus", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetAudioInputDeviceGuidOculus));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS];
    

    deserialize_array(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetAudioInputDeviceGuidOculus(instance, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_OCULUS_audio_device_guid
#ifdef XRTRANSPORT_EXT_XR_FB_foveation_vulkan
#endif // XRTRANSPORT_EXT_XR_FB_foveation_vulkan
#ifdef XRTRANSPORT_EXT_XR_FB_swapchain_update_state_android_surface
#endif // XRTRANSPORT_EXT_XR_FB_swapchain_update_state_android_surface
#ifdef XRTRANSPORT_EXT_XR_FB_swapchain_update_state_opengl_es
#endif // XRTRANSPORT_EXT_XR_FB_swapchain_update_state_opengl_es
#ifdef XRTRANSPORT_EXT_XR_FB_swapchain_update_state_vulkan
#endif // XRTRANSPORT_EXT_XR_FB_swapchain_update_state_vulkan
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_sharing

void handle_xrShareSpacesFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrShareSpacesFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrShareSpacesFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpaceShareInfoFB* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrAsyncRequestIdFB* requestId;
    

    deserialize_ptr(&requestId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrShareSpacesFB(session, info, requestId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(info->spaces, info->spaceCount, msg_out.buffer);

    
    serialize_ptr(info->users, info->userCount, msg_out.buffer);

    
    serialize_ptr(requestId, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_sharing
#ifdef XRTRANSPORT_EXT_XR_FB_space_warp
#endif // XRTRANSPORT_EXT_XR_FB_space_warp
#ifdef XRTRANSPORT_EXT_XR_FB_haptic_amplitude_envelope
#endif // XRTRANSPORT_EXT_XR_FB_haptic_amplitude_envelope
#ifdef XRTRANSPORT_EXT_XR_FB_scene

void handle_xrGetSpaceBoundingBox2DFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpaceBoundingBox2DFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpaceBoundingBox2DFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);

    XrRect2Df* boundingBox2DOutput;
    

    deserialize_ptr(&boundingBox2DOutput, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpaceBoundingBox2DFB(session, space, boundingBox2DOutput);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(boundingBox2DOutput, 1, msg_out.buffer);

}


void handle_xrGetSpaceBoundingBox3DFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpaceBoundingBox3DFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpaceBoundingBox3DFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);

    XrRect3DfFB* boundingBox3DOutput;
    

    deserialize_ptr(&boundingBox3DOutput, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpaceBoundingBox3DFB(session, space, boundingBox3DOutput);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(boundingBox3DOutput, 1, msg_out.buffer);

}


void handle_xrGetSpaceSemanticLabelsFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpaceSemanticLabelsFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpaceSemanticLabelsFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);

    XrSemanticLabelsFB* semanticLabelsOutput;
    

    deserialize_ptr(&semanticLabelsOutput, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpaceSemanticLabelsFB(session, space, semanticLabelsOutput);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(semanticLabelsOutput, 1, msg_out.buffer);

}


void handle_xrGetSpaceBoundary2DFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpaceBoundary2DFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpaceBoundary2DFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);

    XrBoundary2DFB* boundary2DOutput;
    

    deserialize_ptr(&boundary2DOutput, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpaceBoundary2DFB(session, space, boundary2DOutput);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(boundary2DOutput, 1, msg_out.buffer);

}


void handle_xrGetSpaceRoomLayoutFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpaceRoomLayoutFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpaceRoomLayoutFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);

    XrRoomLayoutFB* roomLayoutOutput;
    

    deserialize_ptr(&roomLayoutOutput, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpaceRoomLayoutFB(session, space, roomLayoutOutput);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(roomLayoutOutput, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_scene
#ifdef XRTRANSPORT_EXT_XR_ALMALENCE_digital_lens_control

void handle_xrSetDigitalLensControlALMALENCE(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetDigitalLensControlALMALENCE", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetDigitalLensControlALMALENCE));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrDigitalLensControlALMALENCE* digitalLensControl;
    

    deserialize_ptr(&digitalLensControl, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetDigitalLensControlALMALENCE(session, digitalLensControl);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_ALMALENCE_digital_lens_control
#ifdef XRTRANSPORT_EXT_XR_FB_scene_capture

void handle_xrRequestSceneCaptureFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrRequestSceneCaptureFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrRequestSceneCaptureFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSceneCaptureRequestInfoFB* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrAsyncRequestIdFB* requestId;
    

    deserialize_ptr(&requestId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrRequestSceneCaptureFB(session, info, requestId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(requestId, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_scene_capture
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_container

void handle_xrGetSpaceContainerFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpaceContainerFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpaceContainerFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);

    XrSpaceContainerFB* spaceContainerOutput;
    

    deserialize_ptr(&spaceContainerOutput, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpaceContainerFB(session, space, spaceContainerOutput);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(spaceContainerOutput, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_container
#ifdef XRTRANSPORT_EXT_XR_META_foveation_eye_tracked

void handle_xrGetFoveationEyeTrackedStateMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetFoveationEyeTrackedStateMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetFoveationEyeTrackedStateMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrFoveationEyeTrackedStateMETA* foveationState;
    

    deserialize_ptr(&foveationState, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetFoveationEyeTrackedStateMETA(session, foveationState);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(foveationState, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_META_foveation_eye_tracked
#ifdef XRTRANSPORT_EXT_XR_FB_face_tracking

void handle_xrCreateFaceTrackerFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateFaceTrackerFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateFaceTrackerFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrFaceTrackerCreateInfoFB* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrFaceTrackerFB* faceTracker;
    

    deserialize_ptr(&faceTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateFaceTrackerFB(session, createInfo, faceTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(faceTracker, 1, msg_out.buffer);

}


void handle_xrDestroyFaceTrackerFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyFaceTrackerFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyFaceTrackerFB));
    // by this point, the function id has already been read, now read the params
    XrFaceTrackerFB faceTracker;
    

    deserialize(&faceTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyFaceTrackerFB(faceTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetFaceExpressionWeightsFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetFaceExpressionWeightsFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetFaceExpressionWeightsFB));
    // by this point, the function id has already been read, now read the params
    XrFaceTrackerFB faceTracker;
    

    deserialize(&faceTracker, msg_in.stream, false);

    const XrFaceExpressionInfoFB* expressionInfo;
    

    deserialize_ptr(&expressionInfo, msg_in.stream, false);

    XrFaceExpressionWeightsFB* expressionWeights;
    

    deserialize_ptr(&expressionWeights, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetFaceExpressionWeightsFB(faceTracker, expressionInfo, expressionWeights);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(expressionWeights, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_face_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_eye_tracking_social

void handle_xrCreateEyeTrackerFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateEyeTrackerFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateEyeTrackerFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrEyeTrackerCreateInfoFB* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrEyeTrackerFB* eyeTracker;
    

    deserialize_ptr(&eyeTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateEyeTrackerFB(session, createInfo, eyeTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(eyeTracker, 1, msg_out.buffer);

}


void handle_xrDestroyEyeTrackerFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyEyeTrackerFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyEyeTrackerFB));
    // by this point, the function id has already been read, now read the params
    XrEyeTrackerFB eyeTracker;
    

    deserialize(&eyeTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyEyeTrackerFB(eyeTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetEyeGazesFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetEyeGazesFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetEyeGazesFB));
    // by this point, the function id has already been read, now read the params
    XrEyeTrackerFB eyeTracker;
    

    deserialize(&eyeTracker, msg_in.stream, false);

    const XrEyeGazesInfoFB* gazeInfo;
    

    deserialize_ptr(&gazeInfo, msg_in.stream, false);

    XrEyeGazesFB* eyeGazes;
    

    deserialize_ptr(&eyeGazes, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetEyeGazesFB(eyeTracker, gazeInfo, eyeGazes);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(eyeGazes, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_eye_tracking_social
#ifdef XRTRANSPORT_EXT_XR_FB_passthrough_keyboard_hands

void handle_xrPassthroughLayerSetKeyboardHandsIntensityFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPassthroughLayerSetKeyboardHandsIntensityFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPassthroughLayerSetKeyboardHandsIntensityFB));
    // by this point, the function id has already been read, now read the params
    XrPassthroughLayerFB layer;
    

    deserialize(&layer, msg_in.stream, false);

    const XrPassthroughKeyboardHandsIntensityFB* intensity;
    

    deserialize_ptr(&intensity, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPassthroughLayerSetKeyboardHandsIntensityFB(layer, intensity);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_FB_passthrough_keyboard_hands
#ifdef XRTRANSPORT_EXT_XR_FB_composition_layer_settings
#endif // XRTRANSPORT_EXT_XR_FB_composition_layer_settings
#ifdef XRTRANSPORT_EXT_XR_FB_haptic_pcm

void handle_xrGetDeviceSampleRateFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetDeviceSampleRateFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetDeviceSampleRateFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrHapticActionInfo* hapticActionInfo;
    

    deserialize_ptr(&hapticActionInfo, msg_in.stream, false);

    XrDevicePcmSampleRateGetInfoFB* deviceSampleRate;
    

    deserialize_ptr(&deviceSampleRate, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetDeviceSampleRateFB(session, hapticActionInfo, deviceSampleRate);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(deviceSampleRate, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_haptic_pcm
#ifdef XRTRANSPORT_EXT_XR_EXT_frame_synthesis
#endif // XRTRANSPORT_EXT_XR_EXT_frame_synthesis
#ifdef XRTRANSPORT_EXT_XR_FB_composition_layer_depth_test
#endif // XRTRANSPORT_EXT_XR_FB_composition_layer_depth_test
#ifdef XRTRANSPORT_EXT_XR_META_local_dimming
#endif // XRTRANSPORT_EXT_XR_META_local_dimming
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_preferences

void handle_xrGetPassthroughPreferencesMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetPassthroughPreferencesMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetPassthroughPreferencesMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrPassthroughPreferencesMETA* preferences;
    

    deserialize_ptr(&preferences, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetPassthroughPreferencesMETA(session, preferences);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(preferences, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_META_passthrough_preferences
#ifdef XRTRANSPORT_EXT_XR_META_virtual_keyboard

void handle_xrCreateVirtualKeyboardMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateVirtualKeyboardMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateVirtualKeyboardMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrVirtualKeyboardCreateInfoMETA* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrVirtualKeyboardMETA* keyboard;
    

    deserialize_ptr(&keyboard, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateVirtualKeyboardMETA(session, createInfo, keyboard);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(keyboard, 1, msg_out.buffer);

}


void handle_xrDestroyVirtualKeyboardMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyVirtualKeyboardMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyVirtualKeyboardMETA));
    // by this point, the function id has already been read, now read the params
    XrVirtualKeyboardMETA keyboard;
    

    deserialize(&keyboard, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyVirtualKeyboardMETA(keyboard);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrCreateVirtualKeyboardSpaceMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateVirtualKeyboardSpaceMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateVirtualKeyboardSpaceMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrVirtualKeyboardMETA keyboard;
    

    deserialize(&keyboard, msg_in.stream, false);

    const XrVirtualKeyboardSpaceCreateInfoMETA* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpace* keyboardSpace;
    

    deserialize_ptr(&keyboardSpace, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateVirtualKeyboardSpaceMETA(session, keyboard, createInfo, keyboardSpace);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(keyboardSpace, 1, msg_out.buffer);

}


void handle_xrSuggestVirtualKeyboardLocationMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSuggestVirtualKeyboardLocationMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSuggestVirtualKeyboardLocationMETA));
    // by this point, the function id has already been read, now read the params
    XrVirtualKeyboardMETA keyboard;
    

    deserialize(&keyboard, msg_in.stream, false);

    const XrVirtualKeyboardLocationInfoMETA* locationInfo;
    

    deserialize_ptr(&locationInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSuggestVirtualKeyboardLocationMETA(keyboard, locationInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetVirtualKeyboardScaleMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetVirtualKeyboardScaleMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetVirtualKeyboardScaleMETA));
    // by this point, the function id has already been read, now read the params
    XrVirtualKeyboardMETA keyboard;
    

    deserialize(&keyboard, msg_in.stream, false);

    float* scale;
    

    deserialize_ptr(&scale, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetVirtualKeyboardScaleMETA(keyboard, scale);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(scale, 1, msg_out.buffer);

}


void handle_xrSetVirtualKeyboardModelVisibilityMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetVirtualKeyboardModelVisibilityMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetVirtualKeyboardModelVisibilityMETA));
    // by this point, the function id has already been read, now read the params
    XrVirtualKeyboardMETA keyboard;
    

    deserialize(&keyboard, msg_in.stream, false);

    const XrVirtualKeyboardModelVisibilitySetInfoMETA* modelVisibility;
    

    deserialize_ptr(&modelVisibility, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetVirtualKeyboardModelVisibilityMETA(keyboard, modelVisibility);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetVirtualKeyboardModelAnimationStatesMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetVirtualKeyboardModelAnimationStatesMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetVirtualKeyboardModelAnimationStatesMETA));
    // by this point, the function id has already been read, now read the params
    XrVirtualKeyboardMETA keyboard;
    

    deserialize(&keyboard, msg_in.stream, false);

    XrVirtualKeyboardModelAnimationStatesMETA* animationStates;
    

    deserialize_ptr(&animationStates, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetVirtualKeyboardModelAnimationStatesMETA(keyboard, animationStates);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(animationStates, 1, msg_out.buffer);

}


void handle_xrGetVirtualKeyboardDirtyTexturesMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetVirtualKeyboardDirtyTexturesMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetVirtualKeyboardDirtyTexturesMETA));
    // by this point, the function id has already been read, now read the params
    XrVirtualKeyboardMETA keyboard;
    

    deserialize(&keyboard, msg_in.stream, false);

    uint32_t textureIdCapacityInput;
    

    deserialize(&textureIdCapacityInput, msg_in.stream, false);

    uint32_t* textureIdCountOutput;
    

    deserialize_ptr(&textureIdCountOutput, msg_in.stream, false);

    uint64_t* textureIds;
    

    deserialize_ptr(&textureIds, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetVirtualKeyboardDirtyTexturesMETA(keyboard, textureIdCapacityInput, textureIdCountOutput, textureIds);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(textureIdCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(textureIds, textureIdCapacityInput, msg_out.buffer);

}


void handle_xrGetVirtualKeyboardTextureDataMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetVirtualKeyboardTextureDataMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetVirtualKeyboardTextureDataMETA));
    // by this point, the function id has already been read, now read the params
    XrVirtualKeyboardMETA keyboard;
    

    deserialize(&keyboard, msg_in.stream, false);

    uint64_t textureId;
    

    deserialize(&textureId, msg_in.stream, false);

    XrVirtualKeyboardTextureDataMETA* textureData;
    

    deserialize_ptr(&textureData, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetVirtualKeyboardTextureDataMETA(keyboard, textureId, textureData);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(textureData, 1, msg_out.buffer);

}


void handle_xrSendVirtualKeyboardInputMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSendVirtualKeyboardInputMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSendVirtualKeyboardInputMETA));
    // by this point, the function id has already been read, now read the params
    XrVirtualKeyboardMETA keyboard;
    

    deserialize(&keyboard, msg_in.stream, false);

    const XrVirtualKeyboardInputInfoMETA* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrPosef* interactorRootPose;
    

    deserialize_ptr(&interactorRootPose, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSendVirtualKeyboardInputMETA(keyboard, info, interactorRootPose);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(interactorRootPose, 1, msg_out.buffer);

}


void handle_xrChangeVirtualKeyboardTextContextMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrChangeVirtualKeyboardTextContextMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrChangeVirtualKeyboardTextContextMETA));
    // by this point, the function id has already been read, now read the params
    XrVirtualKeyboardMETA keyboard;
    

    deserialize(&keyboard, msg_in.stream, false);

    const XrVirtualKeyboardTextContextChangeInfoMETA* changeInfo;
    

    deserialize_ptr(&changeInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrChangeVirtualKeyboardTextContextMETA(keyboard, changeInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_META_virtual_keyboard
#ifdef XRTRANSPORT_EXT_XR_OCULUS_external_camera

void handle_xrEnumerateExternalCamerasOCULUS(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateExternalCamerasOCULUS", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateExternalCamerasOCULUS));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    uint32_t cameraCapacityInput;
    

    deserialize(&cameraCapacityInput, msg_in.stream, false);

    uint32_t* cameraCountOutput;
    

    deserialize_ptr(&cameraCountOutput, msg_in.stream, false);

    XrExternalCameraOCULUS* cameras;
    

    deserialize_ptr(&cameras, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateExternalCamerasOCULUS(session, cameraCapacityInput, cameraCountOutput, cameras);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(cameraCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(cameras, cameraCapacityInput, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_OCULUS_external_camera
#ifdef XRTRANSPORT_EXT_XR_META_vulkan_swapchain_create_info
#endif // XRTRANSPORT_EXT_XR_META_vulkan_swapchain_create_info
#ifdef XRTRANSPORT_EXT_XR_META_performance_metrics

void handle_xrEnumeratePerformanceMetricsCounterPathsMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumeratePerformanceMetricsCounterPathsMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumeratePerformanceMetricsCounterPathsMETA));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    uint32_t counterPathCapacityInput;
    

    deserialize(&counterPathCapacityInput, msg_in.stream, false);

    uint32_t* counterPathCountOutput;
    

    deserialize_ptr(&counterPathCountOutput, msg_in.stream, false);

    XrPath* counterPaths;
    

    deserialize_ptr(&counterPaths, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumeratePerformanceMetricsCounterPathsMETA(instance, counterPathCapacityInput, counterPathCountOutput, counterPaths);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(counterPathCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(counterPaths, counterPathCapacityInput, msg_out.buffer);

}


void handle_xrSetPerformanceMetricsStateMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetPerformanceMetricsStateMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetPerformanceMetricsStateMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrPerformanceMetricsStateMETA* state;
    

    deserialize_ptr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetPerformanceMetricsStateMETA(session, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetPerformanceMetricsStateMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetPerformanceMetricsStateMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetPerformanceMetricsStateMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrPerformanceMetricsStateMETA* state;
    

    deserialize_ptr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetPerformanceMetricsStateMETA(session, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(state, 1, msg_out.buffer);

}


void handle_xrQueryPerformanceMetricsCounterMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrQueryPerformanceMetricsCounterMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrQueryPerformanceMetricsCounterMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrPath counterPath;
    

    deserialize(&counterPath, msg_in.stream, false);

    XrPerformanceMetricsCounterMETA* counter;
    

    deserialize_ptr(&counter, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrQueryPerformanceMetricsCounterMETA(session, counterPath, counter);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(counter, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_META_performance_metrics
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_storage_batch

void handle_xrSaveSpaceListFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSaveSpaceListFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSaveSpaceListFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpaceListSaveInfoFB* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrAsyncRequestIdFB* requestId;
    

    deserialize_ptr(&requestId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSaveSpaceListFB(session, info, requestId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(info->spaces, info->spaceCount, msg_out.buffer);

    
    serialize_ptr(requestId, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_storage_batch
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_user

void handle_xrCreateSpaceUserFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpaceUserFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpaceUserFB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpaceUserCreateInfoFB* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrSpaceUserFB* user;
    

    deserialize_ptr(&user, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpaceUserFB(session, info, user);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(user, 1, msg_out.buffer);

}


void handle_xrGetSpaceUserIdFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpaceUserIdFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpaceUserIdFB));
    // by this point, the function id has already been read, now read the params
    XrSpaceUserFB user;
    

    deserialize(&user, msg_in.stream, false);

    XrSpaceUserIdFB* userId;
    

    deserialize_ptr(&userId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpaceUserIdFB(user, userId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(userId, 1, msg_out.buffer);

}


void handle_xrDestroySpaceUserFB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroySpaceUserFB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroySpaceUserFB));
    // by this point, the function id has already been read, now read the params
    XrSpaceUserFB user;
    

    deserialize(&user, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroySpaceUserFB(user);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_user
#ifdef XRTRANSPORT_EXT_XR_META_headset_id
#endif // XRTRANSPORT_EXT_XR_META_headset_id
#ifdef XRTRANSPORT_EXT_XR_META_recommended_layer_resolution

void handle_xrGetRecommendedLayerResolutionMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetRecommendedLayerResolutionMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetRecommendedLayerResolutionMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrRecommendedLayerResolutionGetInfoMETA* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrRecommendedLayerResolutionMETA* resolution;
    

    deserialize_ptr(&resolution, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetRecommendedLayerResolutionMETA(session, info, resolution);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(resolution, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_META_recommended_layer_resolution
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_color_lut

void handle_xrCreatePassthroughColorLutMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreatePassthroughColorLutMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreatePassthroughColorLutMETA));
    // by this point, the function id has already been read, now read the params
    XrPassthroughFB passthrough;
    

    deserialize(&passthrough, msg_in.stream, false);

    const XrPassthroughColorLutCreateInfoMETA* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrPassthroughColorLutMETA* colorLut;
    

    deserialize_ptr(&colorLut, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreatePassthroughColorLutMETA(passthrough, createInfo, colorLut);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(colorLut, 1, msg_out.buffer);

}


void handle_xrDestroyPassthroughColorLutMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyPassthroughColorLutMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyPassthroughColorLutMETA));
    // by this point, the function id has already been read, now read the params
    XrPassthroughColorLutMETA colorLut;
    

    deserialize(&colorLut, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyPassthroughColorLutMETA(colorLut);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrUpdatePassthroughColorLutMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrUpdatePassthroughColorLutMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrUpdatePassthroughColorLutMETA));
    // by this point, the function id has already been read, now read the params
    XrPassthroughColorLutMETA colorLut;
    

    deserialize(&colorLut, msg_in.stream, false);

    const XrPassthroughColorLutUpdateInfoMETA* updateInfo;
    

    deserialize_ptr(&updateInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrUpdatePassthroughColorLutMETA(colorLut, updateInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_META_passthrough_color_lut
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_mesh

void handle_xrGetSpaceTriangleMeshMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpaceTriangleMeshMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpaceTriangleMeshMETA));
    // by this point, the function id has already been read, now read the params
    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);

    const XrSpaceTriangleMeshGetInfoMETA* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    XrSpaceTriangleMeshMETA* triangleMeshOutput;
    

    deserialize_ptr(&triangleMeshOutput, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpaceTriangleMeshMETA(space, getInfo, triangleMeshOutput);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(triangleMeshOutput, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_mesh
#ifdef XRTRANSPORT_EXT_XR_META_body_tracking_full_body
#endif // XRTRANSPORT_EXT_XR_META_body_tracking_full_body
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_layer_resumed_event
#endif // XRTRANSPORT_EXT_XR_META_passthrough_layer_resumed_event
#ifdef XRTRANSPORT_EXT_XR_FB_face_tracking2

void handle_xrCreateFaceTracker2FB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateFaceTracker2FB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateFaceTracker2FB));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrFaceTrackerCreateInfo2FB* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrFaceTracker2FB* faceTracker;
    

    deserialize_ptr(&faceTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateFaceTracker2FB(session, createInfo, faceTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(createInfo->requestedDataSources, createInfo->requestedDataSourceCount, msg_out.buffer);

    
    serialize_ptr(faceTracker, 1, msg_out.buffer);

}


void handle_xrDestroyFaceTracker2FB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyFaceTracker2FB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyFaceTracker2FB));
    // by this point, the function id has already been read, now read the params
    XrFaceTracker2FB faceTracker;
    

    deserialize(&faceTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyFaceTracker2FB(faceTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetFaceExpressionWeights2FB(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetFaceExpressionWeights2FB", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetFaceExpressionWeights2FB));
    // by this point, the function id has already been read, now read the params
    XrFaceTracker2FB faceTracker;
    

    deserialize(&faceTracker, msg_in.stream, false);

    const XrFaceExpressionInfo2FB* expressionInfo;
    

    deserialize_ptr(&expressionInfo, msg_in.stream, false);

    XrFaceExpressionWeights2FB* expressionWeights;
    

    deserialize_ptr(&expressionWeights, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetFaceExpressionWeights2FB(faceTracker, expressionInfo, expressionWeights);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(expressionWeights, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_FB_face_tracking2
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_sharing

void handle_xrShareSpacesMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrShareSpacesMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrShareSpacesMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrShareSpacesInfoMETA* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrAsyncRequestIdFB* requestId;
    

    deserialize_ptr(&requestId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrShareSpacesMETA(session, info, requestId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(info->spaces, info->spaceCount, msg_out.buffer);

    
    serialize_ptr(requestId, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_sharing
#ifdef XRTRANSPORT_EXT_XR_META_environment_depth

void handle_xrCreateEnvironmentDepthProviderMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateEnvironmentDepthProviderMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateEnvironmentDepthProviderMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrEnvironmentDepthProviderCreateInfoMETA* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrEnvironmentDepthProviderMETA* environmentDepthProvider;
    

    deserialize_ptr(&environmentDepthProvider, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateEnvironmentDepthProviderMETA(session, createInfo, environmentDepthProvider);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(environmentDepthProvider, 1, msg_out.buffer);

}


void handle_xrDestroyEnvironmentDepthProviderMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyEnvironmentDepthProviderMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyEnvironmentDepthProviderMETA));
    // by this point, the function id has already been read, now read the params
    XrEnvironmentDepthProviderMETA environmentDepthProvider;
    

    deserialize(&environmentDepthProvider, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyEnvironmentDepthProviderMETA(environmentDepthProvider);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrStartEnvironmentDepthProviderMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrStartEnvironmentDepthProviderMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrStartEnvironmentDepthProviderMETA));
    // by this point, the function id has already been read, now read the params
    XrEnvironmentDepthProviderMETA environmentDepthProvider;
    

    deserialize(&environmentDepthProvider, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrStartEnvironmentDepthProviderMETA(environmentDepthProvider);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrStopEnvironmentDepthProviderMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrStopEnvironmentDepthProviderMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrStopEnvironmentDepthProviderMETA));
    // by this point, the function id has already been read, now read the params
    XrEnvironmentDepthProviderMETA environmentDepthProvider;
    

    deserialize(&environmentDepthProvider, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrStopEnvironmentDepthProviderMETA(environmentDepthProvider);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrCreateEnvironmentDepthSwapchainMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateEnvironmentDepthSwapchainMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateEnvironmentDepthSwapchainMETA));
    // by this point, the function id has already been read, now read the params
    XrEnvironmentDepthProviderMETA environmentDepthProvider;
    

    deserialize(&environmentDepthProvider, msg_in.stream, false);

    const XrEnvironmentDepthSwapchainCreateInfoMETA* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrEnvironmentDepthSwapchainMETA* swapchain;
    

    deserialize_ptr(&swapchain, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateEnvironmentDepthSwapchainMETA(environmentDepthProvider, createInfo, swapchain);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(swapchain, 1, msg_out.buffer);

}


void handle_xrDestroyEnvironmentDepthSwapchainMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyEnvironmentDepthSwapchainMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyEnvironmentDepthSwapchainMETA));
    // by this point, the function id has already been read, now read the params
    XrEnvironmentDepthSwapchainMETA swapchain;
    

    deserialize(&swapchain, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyEnvironmentDepthSwapchainMETA(swapchain);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrEnumerateEnvironmentDepthSwapchainImagesMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateEnvironmentDepthSwapchainImagesMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateEnvironmentDepthSwapchainImagesMETA));
    // by this point, the function id has already been read, now read the params
    XrEnvironmentDepthSwapchainMETA swapchain;
    

    deserialize(&swapchain, msg_in.stream, false);

    uint32_t imageCapacityInput;
    

    deserialize(&imageCapacityInput, msg_in.stream, false);

    uint32_t* imageCountOutput;
    

    deserialize_ptr(&imageCountOutput, msg_in.stream, false);

    XrSwapchainImageBaseHeader* images;
    

    deserialize_xr_array(&images, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateEnvironmentDepthSwapchainImagesMETA(swapchain, imageCapacityInput, imageCountOutput, images);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(imageCountOutput, 1, msg_out.buffer);

    
    serialize_xr_array(images, imageCapacityInput, msg_out.buffer);

}


void handle_xrGetEnvironmentDepthSwapchainStateMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetEnvironmentDepthSwapchainStateMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetEnvironmentDepthSwapchainStateMETA));
    // by this point, the function id has already been read, now read the params
    XrEnvironmentDepthSwapchainMETA swapchain;
    

    deserialize(&swapchain, msg_in.stream, false);

    XrEnvironmentDepthSwapchainStateMETA* state;
    

    deserialize_ptr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetEnvironmentDepthSwapchainStateMETA(swapchain, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(state, 1, msg_out.buffer);

}


void handle_xrAcquireEnvironmentDepthImageMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrAcquireEnvironmentDepthImageMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrAcquireEnvironmentDepthImageMETA));
    // by this point, the function id has already been read, now read the params
    XrEnvironmentDepthProviderMETA environmentDepthProvider;
    

    deserialize(&environmentDepthProvider, msg_in.stream, false);

    const XrEnvironmentDepthImageAcquireInfoMETA* acquireInfo;
    

    deserialize_ptr(&acquireInfo, msg_in.stream, false);

    XrEnvironmentDepthImageMETA* environmentDepthImage;
    

    deserialize_ptr(&environmentDepthImage, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrAcquireEnvironmentDepthImageMETA(environmentDepthProvider, acquireInfo, environmentDepthImage);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(environmentDepthImage, 1, msg_out.buffer);

}


void handle_xrSetEnvironmentDepthHandRemovalMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetEnvironmentDepthHandRemovalMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetEnvironmentDepthHandRemovalMETA));
    // by this point, the function id has already been read, now read the params
    XrEnvironmentDepthProviderMETA environmentDepthProvider;
    

    deserialize(&environmentDepthProvider, msg_in.stream, false);

    const XrEnvironmentDepthHandRemovalSetInfoMETA* setInfo;
    

    deserialize_ptr(&setInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetEnvironmentDepthHandRemovalMETA(environmentDepthProvider, setInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_META_environment_depth
#ifdef XRTRANSPORT_EXT_XR_QCOM_tracking_optimization_settings

void handle_xrSetTrackingOptimizationSettingsHintQCOM(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetTrackingOptimizationSettingsHintQCOM", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetTrackingOptimizationSettingsHintQCOM));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrTrackingOptimizationSettingsDomainQCOM domain;
    

    deserialize(&domain, msg_in.stream, false);

    XrTrackingOptimizationSettingsHintQCOM hint;
    

    deserialize(&hint, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetTrackingOptimizationSettingsHintQCOM(session, domain, hint);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_QCOM_tracking_optimization_settings
#ifdef XRTRANSPORT_EXT_XR_HTC_passthrough

void handle_xrCreatePassthroughHTC(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreatePassthroughHTC", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreatePassthroughHTC));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrPassthroughCreateInfoHTC* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrPassthroughHTC* passthrough;
    

    deserialize_ptr(&passthrough, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreatePassthroughHTC(session, createInfo, passthrough);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(passthrough, 1, msg_out.buffer);

}


void handle_xrDestroyPassthroughHTC(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyPassthroughHTC", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyPassthroughHTC));
    // by this point, the function id has already been read, now read the params
    XrPassthroughHTC passthrough;
    

    deserialize(&passthrough, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyPassthroughHTC(passthrough);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_HTC_passthrough
#ifdef XRTRANSPORT_EXT_XR_HTC_foveation

void handle_xrApplyFoveationHTC(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrApplyFoveationHTC", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrApplyFoveationHTC));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrFoveationApplyInfoHTC* applyInfo;
    

    deserialize_ptr(&applyInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrApplyFoveationHTC(session, applyInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(applyInfo->subImages, applyInfo->subImageCount, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_HTC_foveation
#ifdef XRTRANSPORT_EXT_XR_HTC_anchor

void handle_xrCreateSpatialAnchorHTC(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorHTC", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialAnchorHTC));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpatialAnchorCreateInfoHTC* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpace* anchor;
    

    deserialize_ptr(&anchor, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorHTC(session, createInfo, anchor);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(anchor, 1, msg_out.buffer);

}


void handle_xrGetSpatialAnchorNameHTC(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpatialAnchorNameHTC", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpatialAnchorNameHTC));
    // by this point, the function id has already been read, now read the params
    XrSpace anchor;
    

    deserialize(&anchor, msg_in.stream, false);

    XrSpatialAnchorNameHTC* name;
    

    deserialize_ptr(&name, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpatialAnchorNameHTC(anchor, name);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(name, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_HTC_anchor
#ifdef XRTRANSPORT_EXT_XR_HTC_body_tracking

void handle_xrCreateBodyTrackerHTC(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateBodyTrackerHTC", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateBodyTrackerHTC));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrBodyTrackerCreateInfoHTC* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrBodyTrackerHTC* bodyTracker;
    

    deserialize_ptr(&bodyTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateBodyTrackerHTC(session, createInfo, bodyTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(bodyTracker, 1, msg_out.buffer);

}


void handle_xrDestroyBodyTrackerHTC(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyBodyTrackerHTC", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyBodyTrackerHTC));
    // by this point, the function id has already been read, now read the params
    XrBodyTrackerHTC bodyTracker;
    

    deserialize(&bodyTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyBodyTrackerHTC(bodyTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrLocateBodyJointsHTC(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrLocateBodyJointsHTC", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrLocateBodyJointsHTC));
    // by this point, the function id has already been read, now read the params
    XrBodyTrackerHTC bodyTracker;
    

    deserialize(&bodyTracker, msg_in.stream, false);

    const XrBodyJointsLocateInfoHTC* locateInfo;
    

    deserialize_ptr(&locateInfo, msg_in.stream, false);

    XrBodyJointLocationsHTC* locations;
    

    deserialize_ptr(&locations, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrLocateBodyJointsHTC(bodyTracker, locateInfo, locations);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(locations, 1, msg_out.buffer);

}


void handle_xrGetBodySkeletonHTC(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetBodySkeletonHTC", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetBodySkeletonHTC));
    // by this point, the function id has already been read, now read the params
    XrBodyTrackerHTC bodyTracker;
    

    deserialize(&bodyTracker, msg_in.stream, false);

    XrSpace baseSpace;
    

    deserialize(&baseSpace, msg_in.stream, false);

    uint32_t skeletonGenerationId;
    

    deserialize(&skeletonGenerationId, msg_in.stream, false);

    XrBodySkeletonHTC* skeleton;
    

    deserialize_ptr(&skeleton, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetBodySkeletonHTC(bodyTracker, baseSpace, skeletonGenerationId, skeleton);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(skeleton, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_HTC_body_tracking
#ifdef XRTRANSPORT_EXT_XR_EXT_active_action_set_priority
#endif // XRTRANSPORT_EXT_XR_EXT_active_action_set_priority
#ifdef XRTRANSPORT_EXT_XR_MNDX_force_feedback_curl

void handle_xrApplyForceFeedbackCurlMNDX(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrApplyForceFeedbackCurlMNDX", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrApplyForceFeedbackCurlMNDX));
    // by this point, the function id has already been read, now read the params
    XrHandTrackerEXT handTracker;
    

    deserialize(&handTracker, msg_in.stream, false);

    const XrForceFeedbackCurlApplyLocationsMNDX* locations;
    

    deserialize_ptr(&locations, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrApplyForceFeedbackCurlMNDX(handTracker, locations);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(locations->locations, locations->locationCount, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_MNDX_force_feedback_curl
#ifdef XRTRANSPORT_EXT_XR_BD_body_tracking

void handle_xrCreateBodyTrackerBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateBodyTrackerBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateBodyTrackerBD));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrBodyTrackerCreateInfoBD* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrBodyTrackerBD* bodyTracker;
    

    deserialize_ptr(&bodyTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateBodyTrackerBD(session, createInfo, bodyTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(bodyTracker, 1, msg_out.buffer);

}


void handle_xrDestroyBodyTrackerBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyBodyTrackerBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyBodyTrackerBD));
    // by this point, the function id has already been read, now read the params
    XrBodyTrackerBD bodyTracker;
    

    deserialize(&bodyTracker, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyBodyTrackerBD(bodyTracker);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrLocateBodyJointsBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrLocateBodyJointsBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrLocateBodyJointsBD));
    // by this point, the function id has already been read, now read the params
    XrBodyTrackerBD bodyTracker;
    

    deserialize(&bodyTracker, msg_in.stream, false);

    const XrBodyJointsLocateInfoBD* locateInfo;
    

    deserialize_ptr(&locateInfo, msg_in.stream, false);

    XrBodyJointLocationsBD* locations;
    

    deserialize_ptr(&locations, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrLocateBodyJointsBD(bodyTracker, locateInfo, locations);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(locations, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_BD_body_tracking
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_sensing

void handle_xrEnumerateSpatialEntityComponentTypesBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateSpatialEntityComponentTypesBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateSpatialEntityComponentTypesBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataSnapshotBD snapshot;
    

    deserialize(&snapshot, msg_in.stream, false);

    XrSpatialEntityIdBD entityId;
    

    deserialize(&entityId, msg_in.stream, false);

    uint32_t componentTypeCapacityInput;
    

    deserialize(&componentTypeCapacityInput, msg_in.stream, false);

    uint32_t* componentTypeCountOutput;
    

    deserialize_ptr(&componentTypeCountOutput, msg_in.stream, false);

    XrSpatialEntityComponentTypeBD* componentTypes;
    

    deserialize_ptr(&componentTypes, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateSpatialEntityComponentTypesBD(snapshot, entityId, componentTypeCapacityInput, componentTypeCountOutput, componentTypes);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(componentTypeCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(componentTypes, componentTypeCapacityInput, msg_out.buffer);

}


void handle_xrGetSpatialEntityUuidBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpatialEntityUuidBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpatialEntityUuidBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataSnapshotBD snapshot;
    

    deserialize(&snapshot, msg_in.stream, false);

    XrSpatialEntityIdBD entityId;
    

    deserialize(&entityId, msg_in.stream, false);

    XrUuidEXT* uuid;
    

    deserialize_ptr(&uuid, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpatialEntityUuidBD(snapshot, entityId, uuid);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(uuid, 1, msg_out.buffer);

}


void handle_xrGetSpatialEntityComponentDataBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSpatialEntityComponentDataBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSpatialEntityComponentDataBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataSnapshotBD snapshot;
    

    deserialize(&snapshot, msg_in.stream, false);

    const XrSpatialEntityComponentGetInfoBD* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    XrSpatialEntityComponentDataBaseHeaderBD* componentData;
    

    deserialize_xr(&componentData, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSpatialEntityComponentDataBD(snapshot, getInfo, componentData);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_xr(componentData, msg_out.buffer);

}


void handle_xrCreateSenseDataProviderBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSenseDataProviderBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSenseDataProviderBD));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSenseDataProviderCreateInfoBD* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSenseDataProviderBD* provider;
    

    deserialize_ptr(&provider, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSenseDataProviderBD(session, createInfo, provider);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(provider, 1, msg_out.buffer);

}


void handle_xrStartSenseDataProviderAsyncBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrStartSenseDataProviderAsyncBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrStartSenseDataProviderAsyncBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    const XrSenseDataProviderStartInfoBD* startInfo;
    

    deserialize_ptr(&startInfo, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrStartSenseDataProviderAsyncBD(provider, startInfo, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrStartSenseDataProviderCompleteBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrStartSenseDataProviderCompleteBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrStartSenseDataProviderCompleteBD));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrFutureCompletionEXT* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrStartSenseDataProviderCompleteBD(session, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}


void handle_xrGetSenseDataProviderStateBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSenseDataProviderStateBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSenseDataProviderStateBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    XrSenseDataProviderStateBD* state;
    

    deserialize_ptr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSenseDataProviderStateBD(provider, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(state, 1, msg_out.buffer);

}


void handle_xrQuerySenseDataAsyncBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrQuerySenseDataAsyncBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrQuerySenseDataAsyncBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    const XrSenseDataQueryInfoBD* queryInfo;
    

    deserialize_ptr(&queryInfo, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrQuerySenseDataAsyncBD(provider, queryInfo, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrQuerySenseDataCompleteBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrQuerySenseDataCompleteBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrQuerySenseDataCompleteBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrSenseDataQueryCompletionBD* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrQuerySenseDataCompleteBD(provider, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}


void handle_xrDestroySenseDataSnapshotBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroySenseDataSnapshotBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroySenseDataSnapshotBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataSnapshotBD snapshot;
    

    deserialize(&snapshot, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroySenseDataSnapshotBD(snapshot);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetQueriedSenseDataBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetQueriedSenseDataBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetQueriedSenseDataBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataSnapshotBD snapshot;
    

    deserialize(&snapshot, msg_in.stream, false);

    XrQueriedSenseDataGetInfoBD* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    XrQueriedSenseDataBD* queriedSenseData;
    

    deserialize_ptr(&queriedSenseData, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetQueriedSenseDataBD(snapshot, getInfo, queriedSenseData);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(getInfo, 1, msg_out.buffer);

    
    serialize_ptr(queriedSenseData, 1, msg_out.buffer);

}


void handle_xrStopSenseDataProviderBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrStopSenseDataProviderBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrStopSenseDataProviderBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrStopSenseDataProviderBD(provider);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrDestroySenseDataProviderBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroySenseDataProviderBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroySenseDataProviderBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroySenseDataProviderBD(provider);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrCreateSpatialEntityAnchorBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialEntityAnchorBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialEntityAnchorBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    const XrSpatialEntityAnchorCreateInfoBD* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrAnchorBD* anchor;
    

    deserialize_ptr(&anchor, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialEntityAnchorBD(provider, createInfo, anchor);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(anchor, 1, msg_out.buffer);

}


void handle_xrDestroyAnchorBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyAnchorBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyAnchorBD));
    // by this point, the function id has already been read, now read the params
    XrAnchorBD anchor;
    

    deserialize(&anchor, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyAnchorBD(anchor);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetAnchorUuidBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetAnchorUuidBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetAnchorUuidBD));
    // by this point, the function id has already been read, now read the params
    XrAnchorBD anchor;
    

    deserialize(&anchor, msg_in.stream, false);

    XrUuidEXT* uuid;
    

    deserialize_ptr(&uuid, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetAnchorUuidBD(anchor, uuid);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(uuid, 1, msg_out.buffer);

}


void handle_xrCreateAnchorSpaceBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateAnchorSpaceBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateAnchorSpaceBD));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrAnchorSpaceCreateInfoBD* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpace* space;
    

    deserialize_ptr(&space, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateAnchorSpaceBD(session, createInfo, space);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(space, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_BD_spatial_sensing
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_anchor

void handle_xrCreateSpatialAnchorAsyncBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorAsyncBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialAnchorAsyncBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    const XrSpatialAnchorCreateInfoBD* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorAsyncBD(provider, info, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrCreateSpatialAnchorCompleteBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorCompleteBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSpatialAnchorCompleteBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrSpatialAnchorCreateCompletionBD* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorCompleteBD(provider, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}


void handle_xrPersistSpatialAnchorAsyncBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPersistSpatialAnchorAsyncBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPersistSpatialAnchorAsyncBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    const XrSpatialAnchorPersistInfoBD* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPersistSpatialAnchorAsyncBD(provider, info, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrPersistSpatialAnchorCompleteBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPersistSpatialAnchorCompleteBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPersistSpatialAnchorCompleteBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrFutureCompletionEXT* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPersistSpatialAnchorCompleteBD(provider, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}


void handle_xrUnpersistSpatialAnchorAsyncBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrUnpersistSpatialAnchorAsyncBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrUnpersistSpatialAnchorAsyncBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    const XrSpatialAnchorUnpersistInfoBD* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrUnpersistSpatialAnchorAsyncBD(provider, info, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrUnpersistSpatialAnchorCompleteBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrUnpersistSpatialAnchorCompleteBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrUnpersistSpatialAnchorCompleteBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrFutureCompletionEXT* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrUnpersistSpatialAnchorCompleteBD(provider, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_BD_spatial_anchor
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_anchor_sharing

void handle_xrShareSpatialAnchorAsyncBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrShareSpatialAnchorAsyncBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrShareSpatialAnchorAsyncBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    const XrSpatialAnchorShareInfoBD* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrShareSpatialAnchorAsyncBD(provider, info, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrShareSpatialAnchorCompleteBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrShareSpatialAnchorCompleteBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrShareSpatialAnchorCompleteBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrFutureCompletionEXT* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrShareSpatialAnchorCompleteBD(provider, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}


void handle_xrDownloadSharedSpatialAnchorAsyncBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDownloadSharedSpatialAnchorAsyncBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDownloadSharedSpatialAnchorAsyncBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    const XrSharedSpatialAnchorDownloadInfoBD* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDownloadSharedSpatialAnchorAsyncBD(provider, info, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrDownloadSharedSpatialAnchorCompleteBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDownloadSharedSpatialAnchorCompleteBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDownloadSharedSpatialAnchorCompleteBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrFutureCompletionEXT* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDownloadSharedSpatialAnchorCompleteBD(provider, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_BD_spatial_anchor_sharing
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_scene

void handle_xrCaptureSceneAsyncBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCaptureSceneAsyncBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCaptureSceneAsyncBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    const XrSceneCaptureInfoBD* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCaptureSceneAsyncBD(provider, info, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrCaptureSceneCompleteBD(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCaptureSceneCompleteBD", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCaptureSceneCompleteBD));
    // by this point, the function id has already been read, now read the params
    XrSenseDataProviderBD provider;
    

    deserialize(&provider, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrFutureCompletionEXT* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCaptureSceneCompleteBD(provider, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_BD_spatial_scene
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_mesh
#endif // XRTRANSPORT_EXT_XR_BD_spatial_mesh
#ifdef XRTRANSPORT_EXT_XR_BD_future_progress
#endif // XRTRANSPORT_EXT_XR_BD_future_progress
#ifdef XRTRANSPORT_EXT_XR_EXT_hand_tracking_data_source
#endif // XRTRANSPORT_EXT_XR_EXT_hand_tracking_data_source
#ifdef XRTRANSPORT_EXT_XR_EXT_plane_detection

void handle_xrCreatePlaneDetectorEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreatePlaneDetectorEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreatePlaneDetectorEXT));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrPlaneDetectorCreateInfoEXT* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrPlaneDetectorEXT* planeDetector;
    

    deserialize_ptr(&planeDetector, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreatePlaneDetectorEXT(session, createInfo, planeDetector);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(planeDetector, 1, msg_out.buffer);

}


void handle_xrDestroyPlaneDetectorEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyPlaneDetectorEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyPlaneDetectorEXT));
    // by this point, the function id has already been read, now read the params
    XrPlaneDetectorEXT planeDetector;
    

    deserialize(&planeDetector, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyPlaneDetectorEXT(planeDetector);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrBeginPlaneDetectionEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrBeginPlaneDetectionEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrBeginPlaneDetectionEXT));
    // by this point, the function id has already been read, now read the params
    XrPlaneDetectorEXT planeDetector;
    

    deserialize(&planeDetector, msg_in.stream, false);

    const XrPlaneDetectorBeginInfoEXT* beginInfo;
    

    deserialize_ptr(&beginInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrBeginPlaneDetectionEXT(planeDetector, beginInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetPlaneDetectionStateEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetPlaneDetectionStateEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetPlaneDetectionStateEXT));
    // by this point, the function id has already been read, now read the params
    XrPlaneDetectorEXT planeDetector;
    

    deserialize(&planeDetector, msg_in.stream, false);

    XrPlaneDetectionStateEXT* state;
    

    deserialize_ptr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetPlaneDetectionStateEXT(planeDetector, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(state, 1, msg_out.buffer);

}


void handle_xrGetPlaneDetectionsEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetPlaneDetectionsEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetPlaneDetectionsEXT));
    // by this point, the function id has already been read, now read the params
    XrPlaneDetectorEXT planeDetector;
    

    deserialize(&planeDetector, msg_in.stream, false);

    const XrPlaneDetectorGetInfoEXT* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrPlaneDetectorLocationsEXT* locations;
    

    deserialize_ptr(&locations, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetPlaneDetectionsEXT(planeDetector, info, locations);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(locations, 1, msg_out.buffer);

}


void handle_xrGetPlanePolygonBufferEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetPlanePolygonBufferEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetPlanePolygonBufferEXT));
    // by this point, the function id has already been read, now read the params
    XrPlaneDetectorEXT planeDetector;
    

    deserialize(&planeDetector, msg_in.stream, false);

    uint64_t planeId;
    

    deserialize(&planeId, msg_in.stream, false);

    uint32_t polygonBufferIndex;
    

    deserialize(&polygonBufferIndex, msg_in.stream, false);

    XrPlaneDetectorPolygonBufferEXT* polygonBuffer;
    

    deserialize_ptr(&polygonBuffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetPlanePolygonBufferEXT(planeDetector, planeId, polygonBufferIndex, polygonBuffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(polygonBuffer, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_EXT_plane_detection
#ifdef XRTRANSPORT_EXT_XR_EXT_future

void handle_xrPollFutureEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPollFutureEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPollFutureEXT));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrFuturePollInfoEXT* pollInfo;
    

    deserialize_ptr(&pollInfo, msg_in.stream, false);

    XrFuturePollResultEXT* pollResult;
    

    deserialize_ptr(&pollResult, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPollFutureEXT(instance, pollInfo, pollResult);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(pollResult, 1, msg_out.buffer);

}


void handle_xrCancelFutureEXT(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCancelFutureEXT", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCancelFutureEXT));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrFutureCancelInfoEXT* cancelInfo;
    

    deserialize_ptr(&cancelInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCancelFutureEXT(instance, cancelInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_EXT_future
#ifdef XRTRANSPORT_EXT_XR_EXT_user_presence
#endif // XRTRANSPORT_EXT_XR_EXT_user_presence
#ifdef XRTRANSPORT_EXT_XR_ML_system_notifications

void handle_xrSetSystemNotificationsML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSetSystemNotificationsML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSetSystemNotificationsML));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrSystemNotificationsSetInfoML* info;
    

    deserialize_ptr(&info, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSetSystemNotificationsML(instance, info);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_ML_system_notifications
#ifdef XRTRANSPORT_EXT_XR_ML_world_mesh_detection

void handle_xrCreateWorldMeshDetectorML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateWorldMeshDetectorML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateWorldMeshDetectorML));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrWorldMeshDetectorCreateInfoML* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrWorldMeshDetectorML* detector;
    

    deserialize_ptr(&detector, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateWorldMeshDetectorML(session, createInfo, detector);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(detector, 1, msg_out.buffer);

}


void handle_xrDestroyWorldMeshDetectorML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyWorldMeshDetectorML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyWorldMeshDetectorML));
    // by this point, the function id has already been read, now read the params
    XrWorldMeshDetectorML detector;
    

    deserialize(&detector, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyWorldMeshDetectorML(detector);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrRequestWorldMeshStateAsyncML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrRequestWorldMeshStateAsyncML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrRequestWorldMeshStateAsyncML));
    // by this point, the function id has already been read, now read the params
    XrWorldMeshDetectorML detector;
    

    deserialize(&detector, msg_in.stream, false);

    const XrWorldMeshStateRequestInfoML* stateRequest;
    

    deserialize_ptr(&stateRequest, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrRequestWorldMeshStateAsyncML(detector, stateRequest, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrRequestWorldMeshStateCompleteML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrRequestWorldMeshStateCompleteML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrRequestWorldMeshStateCompleteML));
    // by this point, the function id has already been read, now read the params
    XrWorldMeshDetectorML detector;
    

    deserialize(&detector, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrWorldMeshStateRequestCompletionML* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrRequestWorldMeshStateCompleteML(detector, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}


void handle_xrGetWorldMeshBufferRecommendSizeML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetWorldMeshBufferRecommendSizeML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetWorldMeshBufferRecommendSizeML));
    // by this point, the function id has already been read, now read the params
    XrWorldMeshDetectorML detector;
    

    deserialize(&detector, msg_in.stream, false);

    const XrWorldMeshBufferRecommendedSizeInfoML* sizeInfo;
    

    deserialize_ptr(&sizeInfo, msg_in.stream, false);

    XrWorldMeshBufferSizeML* size;
    

    deserialize_ptr(&size, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetWorldMeshBufferRecommendSizeML(detector, sizeInfo, size);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(size, 1, msg_out.buffer);

}


void handle_xrAllocateWorldMeshBufferML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrAllocateWorldMeshBufferML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrAllocateWorldMeshBufferML));
    // by this point, the function id has already been read, now read the params
    XrWorldMeshDetectorML detector;
    

    deserialize(&detector, msg_in.stream, false);

    const XrWorldMeshBufferSizeML* size;
    

    deserialize_ptr(&size, msg_in.stream, false);

    XrWorldMeshBufferML* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrAllocateWorldMeshBufferML(detector, size, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_xr(size->next, msg_out.buffer);

    
    serialize_ptr(buffer, 1, msg_out.buffer);

}


void handle_xrFreeWorldMeshBufferML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrFreeWorldMeshBufferML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrFreeWorldMeshBufferML));
    // by this point, the function id has already been read, now read the params
    XrWorldMeshDetectorML detector;
    

    deserialize(&detector, msg_in.stream, false);

    const XrWorldMeshBufferML* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrFreeWorldMeshBufferML(detector, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_xr(buffer->next, msg_out.buffer);

    
    serialize_ptr(buffer->buffer, buffer->bufferSize, msg_out.buffer);

}


void handle_xrRequestWorldMeshAsyncML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrRequestWorldMeshAsyncML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrRequestWorldMeshAsyncML));
    // by this point, the function id has already been read, now read the params
    XrWorldMeshDetectorML detector;
    

    deserialize(&detector, msg_in.stream, false);

    const XrWorldMeshGetInfoML* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    XrWorldMeshBufferML* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);

    XrFutureEXT* future;
    

    deserialize_ptr(&future, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrRequestWorldMeshAsyncML(detector, getInfo, buffer, future);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(getInfo->blocks, getInfo->blockCount, msg_out.buffer);

    
    serialize_ptr(buffer, 1, msg_out.buffer);

    
    serialize_ptr(future, 1, msg_out.buffer);

}


void handle_xrRequestWorldMeshCompleteML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrRequestWorldMeshCompleteML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrRequestWorldMeshCompleteML));
    // by this point, the function id has already been read, now read the params
    XrWorldMeshDetectorML detector;
    

    deserialize(&detector, msg_in.stream, false);

    const XrWorldMeshRequestCompletionInfoML* completionInfo;
    

    deserialize_ptr(&completionInfo, msg_in.stream, false);

    XrFutureEXT future;
    

    deserialize(&future, msg_in.stream, false);

    XrWorldMeshRequestCompletionML* completion;
    

    deserialize_ptr(&completion, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrRequestWorldMeshCompleteML(detector, completionInfo, future, completion);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(completion, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_ML_world_mesh_detection
#ifdef XRTRANSPORT_EXT_XR_ML_facial_expression

void handle_xrCreateFacialExpressionClientML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateFacialExpressionClientML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateFacialExpressionClientML));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrFacialExpressionClientCreateInfoML* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrFacialExpressionClientML* facialExpressionClient;
    

    deserialize_ptr(&facialExpressionClient, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateFacialExpressionClientML(session, createInfo, facialExpressionClient);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(facialExpressionClient, 1, msg_out.buffer);

}


void handle_xrDestroyFacialExpressionClientML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyFacialExpressionClientML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyFacialExpressionClientML));
    // by this point, the function id has already been read, now read the params
    XrFacialExpressionClientML facialExpressionClient;
    

    deserialize(&facialExpressionClient, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyFacialExpressionClientML(facialExpressionClient);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrGetFacialExpressionBlendShapePropertiesML(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetFacialExpressionBlendShapePropertiesML", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetFacialExpressionBlendShapePropertiesML));
    // by this point, the function id has already been read, now read the params
    XrFacialExpressionClientML facialExpressionClient;
    

    deserialize(&facialExpressionClient, msg_in.stream, false);

    const XrFacialExpressionBlendShapeGetInfoML* blendShapeGetInfo;
    

    deserialize_ptr(&blendShapeGetInfo, msg_in.stream, false);

    uint32_t blendShapeCount;
    

    deserialize(&blendShapeCount, msg_in.stream, false);

    XrFacialExpressionBlendShapePropertiesML* blendShapes;
    

    deserialize_ptr(&blendShapes, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetFacialExpressionBlendShapePropertiesML(facialExpressionClient, blendShapeGetInfo, blendShapeCount, blendShapes);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(blendShapes, blendShapeCount, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_ML_facial_expression
#ifdef XRTRANSPORT_EXT_XR_META_simultaneous_hands_and_controllers

void handle_xrResumeSimultaneousHandsAndControllersTrackingMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrResumeSimultaneousHandsAndControllersTrackingMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrResumeSimultaneousHandsAndControllersTrackingMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSimultaneousHandsAndControllersTrackingResumeInfoMETA* resumeInfo;
    

    deserialize_ptr(&resumeInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrResumeSimultaneousHandsAndControllersTrackingMETA(session, resumeInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrPauseSimultaneousHandsAndControllersTrackingMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPauseSimultaneousHandsAndControllersTrackingMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPauseSimultaneousHandsAndControllersTrackingMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSimultaneousHandsAndControllersTrackingPauseInfoMETA* pauseInfo;
    

    deserialize_ptr(&pauseInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPauseSimultaneousHandsAndControllersTrackingMETA(session, pauseInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}

#endif // XRTRANSPORT_EXT_XR_META_simultaneous_hands_and_controllers
#ifdef XRTRANSPORT_EXT_XR_META_colocation_discovery

void handle_xrStartColocationDiscoveryMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrStartColocationDiscoveryMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrStartColocationDiscoveryMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrColocationDiscoveryStartInfoMETA* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrAsyncRequestIdFB* discoveryRequestId;
    

    deserialize_ptr(&discoveryRequestId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrStartColocationDiscoveryMETA(session, info, discoveryRequestId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(discoveryRequestId, 1, msg_out.buffer);

}


void handle_xrStopColocationDiscoveryMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrStopColocationDiscoveryMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrStopColocationDiscoveryMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrColocationDiscoveryStopInfoMETA* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrAsyncRequestIdFB* requestId;
    

    deserialize_ptr(&requestId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrStopColocationDiscoveryMETA(session, info, requestId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(requestId, 1, msg_out.buffer);

}


void handle_xrStartColocationAdvertisementMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrStartColocationAdvertisementMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrStartColocationAdvertisementMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrColocationAdvertisementStartInfoMETA* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrAsyncRequestIdFB* advertisementRequestId;
    

    deserialize_ptr(&advertisementRequestId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrStartColocationAdvertisementMETA(session, info, advertisementRequestId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(info->buffer, info->bufferSize, msg_out.buffer);

    
    serialize_ptr(advertisementRequestId, 1, msg_out.buffer);

}


void handle_xrStopColocationAdvertisementMETA(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrStopColocationAdvertisementMETA", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrStopColocationAdvertisementMETA));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrColocationAdvertisementStopInfoMETA* info;
    

    deserialize_ptr(&info, msg_in.stream, false);

    XrAsyncRequestIdFB* requestId;
    

    deserialize_ptr(&requestId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrStopColocationAdvertisementMETA(session, info, requestId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(requestId, 1, msg_out.buffer);

}

#endif // XRTRANSPORT_EXT_XR_META_colocation_discovery
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_group_sharing
#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_group_sharing

void handle_xrAcquireSwapchainImage(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrAcquireSwapchainImage", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrAcquireSwapchainImage));
    // by this point, the function id has already been read, now read the params
    XrSwapchain swapchain;
    

    deserialize(&swapchain, msg_in.stream, false);

    const XrSwapchainImageAcquireInfo* acquireInfo;
    

    deserialize_ptr(&acquireInfo, msg_in.stream, false);

    uint32_t* index;
    

    deserialize_ptr(&index, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrAcquireSwapchainImage(swapchain, acquireInfo, index);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(index, 1, msg_out.buffer);

}


void handle_xrApplyHapticFeedback(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrApplyHapticFeedback", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrApplyHapticFeedback));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrHapticActionInfo* hapticActionInfo;
    

    deserialize_ptr(&hapticActionInfo, msg_in.stream, false);

    const XrHapticBaseHeader* hapticFeedback;
    

    deserialize_xr(&hapticFeedback, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrApplyHapticFeedback(session, hapticActionInfo, hapticFeedback);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrAttachSessionActionSets(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrAttachSessionActionSets", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrAttachSessionActionSets));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSessionActionSetsAttachInfo* attachInfo;
    

    deserialize_ptr(&attachInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrAttachSessionActionSets(session, attachInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrBeginFrame(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrBeginFrame", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrBeginFrame));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrFrameBeginInfo* frameBeginInfo;
    

    deserialize_ptr(&frameBeginInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrBeginFrame(session, frameBeginInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrBeginSession(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrBeginSession", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrBeginSession));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSessionBeginInfo* beginInfo;
    

    deserialize_ptr(&beginInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrBeginSession(session, beginInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrCreateAction(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateAction", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateAction));
    // by this point, the function id has already been read, now read the params
    XrActionSet actionSet;
    

    deserialize(&actionSet, msg_in.stream, false);

    const XrActionCreateInfo* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrAction* action;
    

    deserialize_ptr(&action, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateAction(actionSet, createInfo, action);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(action, 1, msg_out.buffer);

}


void handle_xrCreateActionSet(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateActionSet", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateActionSet));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrActionSetCreateInfo* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrActionSet* actionSet;
    

    deserialize_ptr(&actionSet, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateActionSet(instance, createInfo, actionSet);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(actionSet, 1, msg_out.buffer);

}


void handle_xrCreateActionSpace(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateActionSpace", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateActionSpace));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrActionSpaceCreateInfo* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpace* space;
    

    deserialize_ptr(&space, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateActionSpace(session, createInfo, space);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(space, 1, msg_out.buffer);

}


void handle_xrCreateInstance(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateInstance", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateInstance));
    // by this point, the function id has already been read, now read the params
    const XrInstanceCreateInfo* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrInstance* instance;
    

    deserialize_ptr(&instance, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateInstance(createInfo, instance);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(instance, 1, msg_out.buffer);

}


void handle_xrCreateReferenceSpace(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateReferenceSpace", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateReferenceSpace));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrReferenceSpaceCreateInfo* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSpace* space;
    

    deserialize_ptr(&space, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateReferenceSpace(session, createInfo, space);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(space, 1, msg_out.buffer);

}


void handle_xrCreateSession(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSession", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSession));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrSessionCreateInfo* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSession* session;
    

    deserialize_ptr(&session, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSession(instance, createInfo, session);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(session, 1, msg_out.buffer);

}


void handle_xrCreateSwapchain(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrCreateSwapchain", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrCreateSwapchain));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSwapchainCreateInfo* createInfo;
    

    deserialize_ptr(&createInfo, msg_in.stream, false);

    XrSwapchain* swapchain;
    

    deserialize_ptr(&swapchain, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrCreateSwapchain(session, createInfo, swapchain);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(swapchain, 1, msg_out.buffer);

}


void handle_xrDestroyAction(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyAction", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyAction));
    // by this point, the function id has already been read, now read the params
    XrAction action;
    

    deserialize(&action, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyAction(action);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrDestroyActionSet(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyActionSet", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyActionSet));
    // by this point, the function id has already been read, now read the params
    XrActionSet actionSet;
    

    deserialize(&actionSet, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyActionSet(actionSet);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrDestroyInstance(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroyInstance", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroyInstance));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroyInstance(instance);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrDestroySession(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroySession", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroySession));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroySession(session);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrDestroySpace(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroySpace", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroySpace));
    // by this point, the function id has already been read, now read the params
    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroySpace(space);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrDestroySwapchain(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrDestroySwapchain", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrDestroySwapchain));
    // by this point, the function id has already been read, now read the params
    XrSwapchain swapchain;
    

    deserialize(&swapchain, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrDestroySwapchain(swapchain);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrEndFrame(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEndFrame", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEndFrame));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrFrameEndInfo* frameEndInfo;
    

    deserialize_ptr(&frameEndInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEndFrame(session, frameEndInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrEndSession(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEndSession", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEndSession));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEndSession(session);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrEnumerateApiLayerProperties(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateApiLayerProperties", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateApiLayerProperties));
    // by this point, the function id has already been read, now read the params
    uint32_t propertyCapacityInput;
    

    deserialize(&propertyCapacityInput, msg_in.stream, false);

    uint32_t* propertyCountOutput;
    

    deserialize_ptr(&propertyCountOutput, msg_in.stream, false);

    XrApiLayerProperties* properties;
    

    deserialize_ptr(&properties, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateApiLayerProperties(propertyCapacityInput, propertyCountOutput, properties);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(propertyCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(properties, propertyCapacityInput, msg_out.buffer);

}


void handle_xrEnumerateBoundSourcesForAction(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateBoundSourcesForAction", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateBoundSourcesForAction));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrBoundSourcesForActionEnumerateInfo* enumerateInfo;
    

    deserialize_ptr(&enumerateInfo, msg_in.stream, false);

    uint32_t sourceCapacityInput;
    

    deserialize(&sourceCapacityInput, msg_in.stream, false);

    uint32_t* sourceCountOutput;
    

    deserialize_ptr(&sourceCountOutput, msg_in.stream, false);

    XrPath* sources;
    

    deserialize_ptr(&sources, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateBoundSourcesForAction(session, enumerateInfo, sourceCapacityInput, sourceCountOutput, sources);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(sourceCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(sources, sourceCapacityInput, msg_out.buffer);

}


void handle_xrEnumerateEnvironmentBlendModes(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateEnvironmentBlendModes", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateEnvironmentBlendModes));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    XrViewConfigurationType viewConfigurationType;
    

    deserialize(&viewConfigurationType, msg_in.stream, false);

    uint32_t environmentBlendModeCapacityInput;
    

    deserialize(&environmentBlendModeCapacityInput, msg_in.stream, false);

    uint32_t* environmentBlendModeCountOutput;
    

    deserialize_ptr(&environmentBlendModeCountOutput, msg_in.stream, false);

    XrEnvironmentBlendMode* environmentBlendModes;
    

    deserialize_ptr(&environmentBlendModes, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateEnvironmentBlendModes(instance, systemId, viewConfigurationType, environmentBlendModeCapacityInput, environmentBlendModeCountOutput, environmentBlendModes);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(environmentBlendModeCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(environmentBlendModes, environmentBlendModeCapacityInput, msg_out.buffer);

}


void handle_xrEnumerateInstanceExtensionProperties(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateInstanceExtensionProperties", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateInstanceExtensionProperties));
    // by this point, the function id has already been read, now read the params
    const char* layerName;
    

    deserialize_ptr(&layerName, msg_in.stream, false);

    uint32_t propertyCapacityInput;
    

    deserialize(&propertyCapacityInput, msg_in.stream, false);

    uint32_t* propertyCountOutput;
    

    deserialize_ptr(&propertyCountOutput, msg_in.stream, false);

    XrExtensionProperties* properties;
    

    deserialize_ptr(&properties, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateInstanceExtensionProperties(layerName, propertyCapacityInput, propertyCountOutput, properties);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(propertyCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(properties, propertyCapacityInput, msg_out.buffer);

}


void handle_xrEnumerateReferenceSpaces(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateReferenceSpaces", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateReferenceSpaces));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    uint32_t spaceCapacityInput;
    

    deserialize(&spaceCapacityInput, msg_in.stream, false);

    uint32_t* spaceCountOutput;
    

    deserialize_ptr(&spaceCountOutput, msg_in.stream, false);

    XrReferenceSpaceType* spaces;
    

    deserialize_ptr(&spaces, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateReferenceSpaces(session, spaceCapacityInput, spaceCountOutput, spaces);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(spaceCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(spaces, spaceCapacityInput, msg_out.buffer);

}


void handle_xrEnumerateSwapchainFormats(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateSwapchainFormats", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateSwapchainFormats));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    uint32_t formatCapacityInput;
    

    deserialize(&formatCapacityInput, msg_in.stream, false);

    uint32_t* formatCountOutput;
    

    deserialize_ptr(&formatCountOutput, msg_in.stream, false);

    int64_t* formats;
    

    deserialize_ptr(&formats, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateSwapchainFormats(session, formatCapacityInput, formatCountOutput, formats);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(formatCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(formats, formatCapacityInput, msg_out.buffer);

}


void handle_xrEnumerateSwapchainImages(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateSwapchainImages", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateSwapchainImages));
    // by this point, the function id has already been read, now read the params
    XrSwapchain swapchain;
    

    deserialize(&swapchain, msg_in.stream, false);

    uint32_t imageCapacityInput;
    

    deserialize(&imageCapacityInput, msg_in.stream, false);

    uint32_t* imageCountOutput;
    

    deserialize_ptr(&imageCountOutput, msg_in.stream, false);

    XrSwapchainImageBaseHeader* images;
    

    deserialize_xr_array(&images, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateSwapchainImages(swapchain, imageCapacityInput, imageCountOutput, images);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(imageCountOutput, 1, msg_out.buffer);

    
    serialize_xr_array(images, imageCapacityInput, msg_out.buffer);

}


void handle_xrEnumerateViewConfigurationViews(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateViewConfigurationViews", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateViewConfigurationViews));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    XrViewConfigurationType viewConfigurationType;
    

    deserialize(&viewConfigurationType, msg_in.stream, false);

    uint32_t viewCapacityInput;
    

    deserialize(&viewCapacityInput, msg_in.stream, false);

    uint32_t* viewCountOutput;
    

    deserialize_ptr(&viewCountOutput, msg_in.stream, false);

    XrViewConfigurationView* views;
    

    deserialize_ptr(&views, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateViewConfigurationViews(instance, systemId, viewConfigurationType, viewCapacityInput, viewCountOutput, views);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(viewCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(views, viewCapacityInput, msg_out.buffer);

}


void handle_xrEnumerateViewConfigurations(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrEnumerateViewConfigurations", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrEnumerateViewConfigurations));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    uint32_t viewConfigurationTypeCapacityInput;
    

    deserialize(&viewConfigurationTypeCapacityInput, msg_in.stream, false);

    uint32_t* viewConfigurationTypeCountOutput;
    

    deserialize_ptr(&viewConfigurationTypeCountOutput, msg_in.stream, false);

    XrViewConfigurationType* viewConfigurationTypes;
    

    deserialize_ptr(&viewConfigurationTypes, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrEnumerateViewConfigurations(instance, systemId, viewConfigurationTypeCapacityInput, viewConfigurationTypeCountOutput, viewConfigurationTypes);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(viewConfigurationTypeCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(viewConfigurationTypes, viewConfigurationTypeCapacityInput, msg_out.buffer);

}


void handle_xrGetActionStateBoolean(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetActionStateBoolean", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetActionStateBoolean));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrActionStateGetInfo* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    XrActionStateBoolean* state;
    

    deserialize_ptr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetActionStateBoolean(session, getInfo, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(state, 1, msg_out.buffer);

}


void handle_xrGetActionStateFloat(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetActionStateFloat", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetActionStateFloat));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrActionStateGetInfo* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    XrActionStateFloat* state;
    

    deserialize_ptr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetActionStateFloat(session, getInfo, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(state, 1, msg_out.buffer);

}


void handle_xrGetActionStatePose(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetActionStatePose", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetActionStatePose));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrActionStateGetInfo* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    XrActionStatePose* state;
    

    deserialize_ptr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetActionStatePose(session, getInfo, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(state, 1, msg_out.buffer);

}


void handle_xrGetActionStateVector2f(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetActionStateVector2f", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetActionStateVector2f));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrActionStateGetInfo* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    XrActionStateVector2f* state;
    

    deserialize_ptr(&state, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetActionStateVector2f(session, getInfo, state);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(state, 1, msg_out.buffer);

}


void handle_xrGetCurrentInteractionProfile(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetCurrentInteractionProfile", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetCurrentInteractionProfile));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrPath topLevelUserPath;
    

    deserialize(&topLevelUserPath, msg_in.stream, false);

    XrInteractionProfileState* interactionProfile;
    

    deserialize_ptr(&interactionProfile, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetCurrentInteractionProfile(session, topLevelUserPath, interactionProfile);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(interactionProfile, 1, msg_out.buffer);

}


void handle_xrGetInputSourceLocalizedName(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetInputSourceLocalizedName", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetInputSourceLocalizedName));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrInputSourceLocalizedNameGetInfo* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    uint32_t bufferCapacityInput;
    

    deserialize(&bufferCapacityInput, msg_in.stream, false);

    uint32_t* bufferCountOutput;
    

    deserialize_ptr(&bufferCountOutput, msg_in.stream, false);

    char* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetInputSourceLocalizedName(session, getInfo, bufferCapacityInput, bufferCountOutput, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(bufferCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(buffer, bufferCapacityInput, msg_out.buffer);

}


void handle_xrGetInstanceProperties(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetInstanceProperties", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetInstanceProperties));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrInstanceProperties* instanceProperties;
    

    deserialize_ptr(&instanceProperties, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetInstanceProperties(instance, instanceProperties);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(instanceProperties, 1, msg_out.buffer);

}


void handle_xrGetReferenceSpaceBoundsRect(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetReferenceSpaceBoundsRect", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetReferenceSpaceBoundsRect));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    XrReferenceSpaceType referenceSpaceType;
    

    deserialize(&referenceSpaceType, msg_in.stream, false);

    XrExtent2Df* bounds;
    

    deserialize_ptr(&bounds, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetReferenceSpaceBoundsRect(session, referenceSpaceType, bounds);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(bounds, 1, msg_out.buffer);

}


void handle_xrGetSystem(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSystem", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSystem));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrSystemGetInfo* getInfo;
    

    deserialize_ptr(&getInfo, msg_in.stream, false);

    XrSystemId* systemId;
    

    deserialize_ptr(&systemId, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSystem(instance, getInfo, systemId);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(systemId, 1, msg_out.buffer);

}


void handle_xrGetSystemProperties(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetSystemProperties", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetSystemProperties));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    XrSystemProperties* properties;
    

    deserialize_ptr(&properties, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetSystemProperties(instance, systemId, properties);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(properties, 1, msg_out.buffer);

}


void handle_xrGetViewConfigurationProperties(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrGetViewConfigurationProperties", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrGetViewConfigurationProperties));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrSystemId systemId;
    

    deserialize(&systemId, msg_in.stream, false);

    XrViewConfigurationType viewConfigurationType;
    

    deserialize(&viewConfigurationType, msg_in.stream, false);

    XrViewConfigurationProperties* configurationProperties;
    

    deserialize_ptr(&configurationProperties, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrGetViewConfigurationProperties(instance, systemId, viewConfigurationType, configurationProperties);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(configurationProperties, 1, msg_out.buffer);

}


void handle_xrLocateSpace(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrLocateSpace", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrLocateSpace));
    // by this point, the function id has already been read, now read the params
    XrSpace space;
    

    deserialize(&space, msg_in.stream, false);

    XrSpace baseSpace;
    

    deserialize(&baseSpace, msg_in.stream, false);

    XrTime time;
    

    deserialize(&time, msg_in.stream, false);

    XrSpaceLocation* location;
    

    deserialize_ptr(&location, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrLocateSpace(space, baseSpace, time, location);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(location, 1, msg_out.buffer);

}


void handle_xrLocateSpaces(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrLocateSpaces", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrLocateSpaces));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrSpacesLocateInfo* locateInfo;
    

    deserialize_ptr(&locateInfo, msg_in.stream, false);

    XrSpaceLocations* spaceLocations;
    

    deserialize_ptr(&spaceLocations, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrLocateSpaces(session, locateInfo, spaceLocations);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(spaceLocations, 1, msg_out.buffer);

}


void handle_xrLocateViews(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrLocateViews", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrLocateViews));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrViewLocateInfo* viewLocateInfo;
    

    deserialize_ptr(&viewLocateInfo, msg_in.stream, false);

    XrViewState* viewState;
    

    deserialize_ptr(&viewState, msg_in.stream, false);

    uint32_t viewCapacityInput;
    

    deserialize(&viewCapacityInput, msg_in.stream, false);

    uint32_t* viewCountOutput;
    

    deserialize_ptr(&viewCountOutput, msg_in.stream, false);

    XrView* views;
    

    deserialize_ptr(&views, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrLocateViews(session, viewLocateInfo, viewState, viewCapacityInput, viewCountOutput, views);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(viewState, 1, msg_out.buffer);

    
    serialize_ptr(viewCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(views, viewCapacityInput, msg_out.buffer);

}


void handle_xrPathToString(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPathToString", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPathToString));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrPath path;
    

    deserialize(&path, msg_in.stream, false);

    uint32_t bufferCapacityInput;
    

    deserialize(&bufferCapacityInput, msg_in.stream, false);

    uint32_t* bufferCountOutput;
    

    deserialize_ptr(&bufferCountOutput, msg_in.stream, false);

    char* buffer;
    

    deserialize_ptr(&buffer, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPathToString(instance, path, bufferCapacityInput, bufferCountOutput, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(bufferCountOutput, 1, msg_out.buffer);

    
    serialize_ptr(buffer, bufferCapacityInput, msg_out.buffer);

}


void handle_xrPollEvent(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrPollEvent", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrPollEvent));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrEventDataBuffer* eventData;
    

    deserialize_ptr(&eventData, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrPollEvent(instance, eventData);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(eventData, 1, msg_out.buffer);

}


void handle_xrReleaseSwapchainImage(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrReleaseSwapchainImage", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrReleaseSwapchainImage));
    // by this point, the function id has already been read, now read the params
    XrSwapchain swapchain;
    

    deserialize(&swapchain, msg_in.stream, false);

    const XrSwapchainImageReleaseInfo* releaseInfo;
    

    deserialize_ptr(&releaseInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrReleaseSwapchainImage(swapchain, releaseInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrRequestExitSession(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrRequestExitSession", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrRequestExitSession));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrRequestExitSession(session);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrResultToString(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrResultToString", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrResultToString));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrResult value;
    

    deserialize(&value, msg_in.stream, false);

    char buffer[XR_MAX_RESULT_STRING_SIZE];
    

    deserialize_array(buffer, XR_MAX_RESULT_STRING_SIZE, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrResultToString(instance, value, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(buffer, XR_MAX_RESULT_STRING_SIZE, msg_out.buffer);

}


void handle_xrStopHapticFeedback(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrStopHapticFeedback", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrStopHapticFeedback));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrHapticActionInfo* hapticActionInfo;
    

    deserialize_ptr(&hapticActionInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrStopHapticFeedback(session, hapticActionInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrStringToPath(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrStringToPath", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrStringToPath));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const char* pathString;
    

    deserialize_ptr(&pathString, msg_in.stream, false);

    XrPath* path;
    

    deserialize_ptr(&path, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrStringToPath(instance, pathString, path);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(path, 1, msg_out.buffer);

}


void handle_xrStructureTypeToString(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrStructureTypeToString", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrStructureTypeToString));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    XrStructureType value;
    

    deserialize(&value, msg_in.stream, false);

    char buffer[XR_MAX_STRUCTURE_NAME_SIZE];
    

    deserialize_array(buffer, XR_MAX_STRUCTURE_NAME_SIZE, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrStructureTypeToString(instance, value, buffer);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(buffer, XR_MAX_STRUCTURE_NAME_SIZE, msg_out.buffer);

}


void handle_xrSuggestInteractionProfileBindings(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSuggestInteractionProfileBindings", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSuggestInteractionProfileBindings));
    // by this point, the function id has already been read, now read the params
    XrInstance instance;
    

    deserialize(&instance, msg_in.stream, false);

    const XrInteractionProfileSuggestedBinding* suggestedBindings;
    

    deserialize_ptr(&suggestedBindings, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSuggestInteractionProfileBindings(instance, suggestedBindings);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrSyncActions(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrSyncActions", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrSyncActions));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrActionsSyncInfo* syncInfo;
    

    deserialize_ptr(&syncInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrSyncActions(session, syncInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}


void handle_xrWaitFrame(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrWaitFrame", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrWaitFrame));
    // by this point, the function id has already been read, now read the params
    XrSession session;
    

    deserialize(&session, msg_in.stream, false);

    const XrFrameWaitInfo* frameWaitInfo;
    

    deserialize_ptr(&frameWaitInfo, msg_in.stream, false);

    XrFrameState* frameState;
    

    deserialize_ptr(&frameState, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrWaitFrame(session, frameWaitInfo, frameState);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
    
    serialize_ptr(frameState, 1, msg_out.buffer);

}


void handle_xrWaitSwapchainImage(MessageLockIn msg_in, Transport& transport, FunctionLoader& function_loader) {
    function_loader.ensure_function_loaded("xrWaitSwapchainImage", reinterpret_cast<PFN_xrVoidFunction*>(&function_loader.pfn_xrWaitSwapchainImage));
    // by this point, the function id has already been read, now read the params
    XrSwapchain swapchain;
    

    deserialize(&swapchain, msg_in.stream, false);

    const XrSwapchainImageWaitInfo* waitInfo;
    

    deserialize_ptr(&waitInfo, msg_in.stream, false);


    XrResult _result = function_loader.pfn_xrWaitSwapchainImage(swapchain, waitInfo);
    
    auto msg_out = transport.start_message(FUNCTION_RETURN);
    serialize(&_result, msg_out.buffer);
}



static std::unordered_map<uint32_t, FunctionHandler> function_handler_lookup_table = {

#ifdef XRTRANSPORT_EXT_XR_KHR_android_thread_settings

    {75001, &handle_xrSetAndroidApplicationThreadKHR},

#endif // XRTRANSPORT_EXT_XR_KHR_android_thread_settings
#ifdef XRTRANSPORT_EXT_XR_KHR_android_surface_swapchain

    {74001, &handle_xrCreateSwapchainAndroidSurfaceKHR},

#endif // XRTRANSPORT_EXT_XR_KHR_android_surface_swapchain
#ifdef XRTRANSPORT_EXT_XR_KHR_composition_layer_cube
#endif // XRTRANSPORT_EXT_XR_KHR_composition_layer_cube
#ifdef XRTRANSPORT_EXT_XR_KHR_android_create_instance
#endif // XRTRANSPORT_EXT_XR_KHR_android_create_instance
#ifdef XRTRANSPORT_EXT_XR_KHR_composition_layer_depth
#endif // XRTRANSPORT_EXT_XR_KHR_composition_layer_depth
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_swapchain_format_list
#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_swapchain_format_list
#ifdef XRTRANSPORT_EXT_XR_EXT_performance_settings

    {21001, &handle_xrPerfSettingsSetPerformanceLevelEXT},

#endif // XRTRANSPORT_EXT_XR_EXT_performance_settings
#ifdef XRTRANSPORT_EXT_XR_EXT_thermal_query

    {23001, &handle_xrThermalGetTemperatureTrendEXT},

#endif // XRTRANSPORT_EXT_XR_EXT_thermal_query
#ifdef XRTRANSPORT_EXT_XR_KHR_composition_layer_cylinder
#endif // XRTRANSPORT_EXT_XR_KHR_composition_layer_cylinder
#ifdef XRTRANSPORT_EXT_XR_KHR_composition_layer_equirect
#endif // XRTRANSPORT_EXT_XR_KHR_composition_layer_equirect
#ifdef XRTRANSPORT_EXT_XR_EXT_debug_utils

    {13006, &handle_xrSetDebugUtilsObjectNameEXT},


    {13001, &handle_xrCreateDebugUtilsMessengerEXT},


    {13002, &handle_xrDestroyDebugUtilsMessengerEXT},


    {13007, &handle_xrSubmitDebugUtilsMessageEXT},


    {13003, &handle_xrSessionBeginDebugUtilsLabelRegionEXT},


    {13004, &handle_xrSessionEndDebugUtilsLabelRegionEXT},


    {13005, &handle_xrSessionInsertDebugUtilsLabelEXT},

#endif // XRTRANSPORT_EXT_XR_EXT_debug_utils
#ifdef XRTRANSPORT_EXT_XR_KHR_opengl_enable

    {88001, &handle_xrGetOpenGLGraphicsRequirementsKHR},

#endif // XRTRANSPORT_EXT_XR_KHR_opengl_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_opengl_es_enable

    {89001, &handle_xrGetOpenGLESGraphicsRequirementsKHR},

#endif // XRTRANSPORT_EXT_XR_KHR_opengl_es_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_enable

    {91004, &handle_xrGetVulkanInstanceExtensionsKHR},


    {91001, &handle_xrGetVulkanDeviceExtensionsKHR},


    {91002, &handle_xrGetVulkanGraphicsDeviceKHR},


    {91003, &handle_xrGetVulkanGraphicsRequirementsKHR},

#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_D3D11_enable

    {71001, &handle_xrGetD3D11GraphicsRequirementsKHR},

#endif // XRTRANSPORT_EXT_XR_KHR_D3D11_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_D3D12_enable

    {72001, &handle_xrGetD3D12GraphicsRequirementsKHR},

#endif // XRTRANSPORT_EXT_XR_KHR_D3D12_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_metal_enable

    {87001, &handle_xrGetMetalGraphicsRequirementsKHR},

#endif // XRTRANSPORT_EXT_XR_KHR_metal_enable
#ifdef XRTRANSPORT_EXT_XR_EXT_eye_gaze_interaction
#endif // XRTRANSPORT_EXT_XR_EXT_eye_gaze_interaction
#ifdef XRTRANSPORT_EXT_XR_KHR_visibility_mask

    {90001, &handle_xrGetVisibilityMaskKHR},

#endif // XRTRANSPORT_EXT_XR_KHR_visibility_mask
#ifdef XRTRANSPORT_EXT_XR_EXTX_overlay
#endif // XRTRANSPORT_EXT_XR_EXTX_overlay
#ifdef XRTRANSPORT_EXT_XR_KHR_composition_layer_color_scale_bias
#endif // XRTRANSPORT_EXT_XR_KHR_composition_layer_color_scale_bias
#ifdef XRTRANSPORT_EXT_XR_KHR_win32_convert_performance_counter_time

    {94002, &handle_xrConvertWin32PerformanceCounterToTimeKHR},


    {94001, &handle_xrConvertTimeToWin32PerformanceCounterKHR},

#endif // XRTRANSPORT_EXT_XR_KHR_win32_convert_performance_counter_time
#ifdef XRTRANSPORT_EXT_XR_KHR_convert_timespec_time

    {83002, &handle_xrConvertTimespecTimeToTimeKHR},


    {83001, &handle_xrConvertTimeToTimespecTimeKHR},

#endif // XRTRANSPORT_EXT_XR_KHR_convert_timespec_time
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_anchor

    {134001, &handle_xrCreateSpatialAnchorMSFT},


    {134002, &handle_xrCreateSpatialAnchorSpaceMSFT},


    {134003, &handle_xrDestroySpatialAnchorMSFT},

#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_anchor
#ifdef XRTRANSPORT_EXT_XR_FB_composition_layer_image_layout
#endif // XRTRANSPORT_EXT_XR_FB_composition_layer_image_layout
#ifdef XRTRANSPORT_EXT_XR_FB_composition_layer_alpha_blend
#endif // XRTRANSPORT_EXT_XR_FB_composition_layer_alpha_blend
#ifdef XRTRANSPORT_EXT_XR_EXT_view_configuration_depth_range
#endif // XRTRANSPORT_EXT_XR_EXT_view_configuration_depth_range
#ifdef XRTRANSPORT_EXT_XR_EXT_conformance_automation

    {12001, &handle_xrSetInputDeviceActiveEXT},


    {12003, &handle_xrSetInputDeviceStateBoolEXT},


    {12004, &handle_xrSetInputDeviceStateFloatEXT},


    {12005, &handle_xrSetInputDeviceStateVector2fEXT},


    {12002, &handle_xrSetInputDeviceLocationEXT},

#endif // XRTRANSPORT_EXT_XR_EXT_conformance_automation
#ifdef XRTRANSPORT_EXT_XR_MNDX_egl_enable
#endif // XRTRANSPORT_EXT_XR_MNDX_egl_enable
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_graph_bridge

    {136001, &handle_xrCreateSpatialGraphNodeSpaceMSFT},


    {136004, &handle_xrTryCreateSpatialGraphStaticNodeBindingMSFT},


    {136002, &handle_xrDestroySpatialGraphNodeBindingMSFT},


    {136003, &handle_xrGetSpatialGraphNodeBindingPropertiesMSFT},

#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_graph_bridge
#ifdef XRTRANSPORT_EXT_XR_EXT_hand_tracking

    {19001, &handle_xrCreateHandTrackerEXT},


    {19002, &handle_xrDestroyHandTrackerEXT},


    {19003, &handle_xrLocateHandJointsEXT},

#endif // XRTRANSPORT_EXT_XR_EXT_hand_tracking
#ifdef XRTRANSPORT_EXT_XR_MSFT_hand_tracking_mesh

    {127001, &handle_xrCreateHandMeshSpaceMSFT},


    {127002, &handle_xrUpdateHandMeshMSFT},

#endif // XRTRANSPORT_EXT_XR_MSFT_hand_tracking_mesh
#ifdef XRTRANSPORT_EXT_XR_MSFT_secondary_view_configuration
#endif // XRTRANSPORT_EXT_XR_MSFT_secondary_view_configuration
#ifdef XRTRANSPORT_EXT_XR_MSFT_controller_model

    {126001, &handle_xrGetControllerModelKeyMSFT},


    {126004, &handle_xrLoadControllerModelMSFT},


    {126002, &handle_xrGetControllerModelPropertiesMSFT},


    {126003, &handle_xrGetControllerModelStateMSFT},

#endif // XRTRANSPORT_EXT_XR_MSFT_controller_model
#ifdef XRTRANSPORT_EXT_XR_MSFT_perception_anchor_interop

    {129001, &handle_xrCreateSpatialAnchorFromPerceptionAnchorMSFT},


    {129002, &handle_xrTryGetPerceptionAnchorFromSpatialAnchorMSFT},

#endif // XRTRANSPORT_EXT_XR_MSFT_perception_anchor_interop
#ifdef XRTRANSPORT_EXT_XR_EPIC_view_configuration_fov
#endif // XRTRANSPORT_EXT_XR_EPIC_view_configuration_fov
#ifdef XRTRANSPORT_EXT_XR_MSFT_holographic_window_attachment
#endif // XRTRANSPORT_EXT_XR_MSFT_holographic_window_attachment
#ifdef XRTRANSPORT_EXT_XR_MSFT_composition_layer_reprojection

    {125001, &handle_xrEnumerateReprojectionModesMSFT},

#endif // XRTRANSPORT_EXT_XR_MSFT_composition_layer_reprojection
#ifdef XRTRANSPORT_EXT_XR_FB_android_surface_swapchain_create
#endif // XRTRANSPORT_EXT_XR_FB_android_surface_swapchain_create
#ifdef XRTRANSPORT_EXT_XR_FB_swapchain_update_state

    {60002, &handle_xrUpdateSwapchainFB},


    {60001, &handle_xrGetSwapchainStateFB},

#endif // XRTRANSPORT_EXT_XR_FB_swapchain_update_state
#ifdef XRTRANSPORT_EXT_XR_FB_composition_layer_secure_content
#endif // XRTRANSPORT_EXT_XR_FB_composition_layer_secure_content
#ifdef XRTRANSPORT_EXT_XR_FB_body_tracking

    {27001, &handle_xrCreateBodyTrackerFB},


    {27002, &handle_xrDestroyBodyTrackerFB},


    {27004, &handle_xrLocateBodyJointsFB},


    {27003, &handle_xrGetBodySkeletonFB},

#endif // XRTRANSPORT_EXT_XR_FB_body_tracking
#ifdef XRTRANSPORT_EXT_XR_EXT_dpad_binding
#endif // XRTRANSPORT_EXT_XR_EXT_dpad_binding
#ifdef XRTRANSPORT_EXT_XR_VALVE_analog_threshold
#endif // XRTRANSPORT_EXT_XR_VALVE_analog_threshold
#ifdef XRTRANSPORT_EXT_XR_EXT_hand_joints_motion_range
#endif // XRTRANSPORT_EXT_XR_EXT_hand_joints_motion_range
#ifdef XRTRANSPORT_EXT_XR_KHR_loader_init

    {85001, &handle_xrInitializeLoaderKHR},

#endif // XRTRANSPORT_EXT_XR_KHR_loader_init
#ifdef XRTRANSPORT_EXT_XR_KHR_loader_init_android
#endif // XRTRANSPORT_EXT_XR_KHR_loader_init_android
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_enable2

    {92002, &handle_xrCreateVulkanInstanceKHR},


    {92001, &handle_xrCreateVulkanDeviceKHR},


    {92003, &handle_xrGetVulkanGraphicsDevice2KHR},

#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_enable2
#ifdef XRTRANSPORT_EXT_XR_KHR_composition_layer_equirect2
#endif // XRTRANSPORT_EXT_XR_KHR_composition_layer_equirect2
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_understanding

    {131006, &handle_xrEnumerateSceneComputeFeaturesMSFT},


    {131003, &handle_xrCreateSceneObserverMSFT},


    {131005, &handle_xrDestroySceneObserverMSFT},


    {131002, &handle_xrCreateSceneMSFT},


    {131004, &handle_xrDestroySceneMSFT},


    {131001, &handle_xrComputeNewSceneMSFT},


    {131008, &handle_xrGetSceneComputeStateMSFT},


    {131007, &handle_xrGetSceneComponentsMSFT},


    {131010, &handle_xrLocateSceneComponentsMSFT},


    {131009, &handle_xrGetSceneMeshBuffersMSFT},

#endif // XRTRANSPORT_EXT_XR_MSFT_scene_understanding
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_understanding_serialization

    {132001, &handle_xrDeserializeSceneMSFT},


    {132002, &handle_xrGetSerializedSceneFragmentDataMSFT},

#endif // XRTRANSPORT_EXT_XR_MSFT_scene_understanding_serialization
#ifdef XRTRANSPORT_EXT_XR_FB_display_refresh_rate

    {34001, &handle_xrEnumerateDisplayRefreshRatesFB},


    {34002, &handle_xrGetDisplayRefreshRateFB},


    {34003, &handle_xrRequestDisplayRefreshRateFB},

#endif // XRTRANSPORT_EXT_XR_FB_display_refresh_rate
#ifdef XRTRANSPORT_EXT_XR_HTCX_vive_tracker_interaction

    {65001, &handle_xrEnumerateViveTrackerPathsHTCX},

#endif // XRTRANSPORT_EXT_XR_HTCX_vive_tracker_interaction
#ifdef XRTRANSPORT_EXT_XR_HTC_facial_tracking

    {68001, &handle_xrCreateFacialTrackerHTC},


    {68002, &handle_xrDestroyFacialTrackerHTC},


    {68003, &handle_xrGetFacialExpressionsHTC},

#endif // XRTRANSPORT_EXT_XR_HTC_facial_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_color_space

    {28001, &handle_xrEnumerateColorSpacesFB},


    {28002, &handle_xrSetColorSpaceFB},

#endif // XRTRANSPORT_EXT_XR_FB_color_space
#ifdef XRTRANSPORT_EXT_XR_FB_hand_tracking_mesh

    {43001, &handle_xrGetHandMeshFB},

#endif // XRTRANSPORT_EXT_XR_FB_hand_tracking_mesh
#ifdef XRTRANSPORT_EXT_XR_FB_hand_tracking_aim
#endif // XRTRANSPORT_EXT_XR_FB_hand_tracking_aim
#ifdef XRTRANSPORT_EXT_XR_FB_hand_tracking_capsules
#endif // XRTRANSPORT_EXT_XR_FB_hand_tracking_capsules
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity

    {53001, &handle_xrCreateSpatialAnchorFB},


    {53004, &handle_xrGetSpaceUuidFB},


    {53002, &handle_xrEnumerateSpaceSupportedComponentsFB},


    {53005, &handle_xrSetSpaceComponentStatusFB},


    {53003, &handle_xrGetSpaceComponentStatusFB},

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity
#ifdef XRTRANSPORT_EXT_XR_FB_foveation

    {38001, &handle_xrCreateFoveationProfileFB},


    {38002, &handle_xrDestroyFoveationProfileFB},

#endif // XRTRANSPORT_EXT_XR_FB_foveation
#ifdef XRTRANSPORT_EXT_XR_FB_foveation_configuration
#endif // XRTRANSPORT_EXT_XR_FB_foveation_configuration
#ifdef XRTRANSPORT_EXT_XR_FB_keyboard_tracking

    {46002, &handle_xrQuerySystemTrackedKeyboardFB},


    {46001, &handle_xrCreateKeyboardSpaceFB},

#endif // XRTRANSPORT_EXT_XR_FB_keyboard_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_triangle_mesh

    {64001, &handle_xrCreateTriangleMeshFB},


    {64002, &handle_xrDestroyTriangleMeshFB},


    {64008, &handle_xrTriangleMeshGetVertexBufferFB},


    {64007, &handle_xrTriangleMeshGetIndexBufferFB},


    {64003, &handle_xrTriangleMeshBeginUpdateFB},


    {64005, &handle_xrTriangleMeshEndUpdateFB},


    {64004, &handle_xrTriangleMeshBeginVertexBufferUpdateFB},


    {64006, &handle_xrTriangleMeshEndVertexBufferUpdateFB},

#endif // XRTRANSPORT_EXT_XR_FB_triangle_mesh
#ifdef XRTRANSPORT_EXT_XR_FB_passthrough

    {47002, &handle_xrCreatePassthroughFB},


    {47005, &handle_xrDestroyPassthroughFB},


    {47012, &handle_xrPassthroughStartFB},


    {47011, &handle_xrPassthroughPauseFB},


    {47003, &handle_xrCreatePassthroughLayerFB},


    {47006, &handle_xrDestroyPassthroughLayerFB},


    {47008, &handle_xrPassthroughLayerPauseFB},


    {47009, &handle_xrPassthroughLayerResumeFB},


    {47010, &handle_xrPassthroughLayerSetStyleFB},


    {47001, &handle_xrCreateGeometryInstanceFB},


    {47004, &handle_xrDestroyGeometryInstanceFB},


    {47007, &handle_xrGeometryInstanceSetTransformFB},

#endif // XRTRANSPORT_EXT_XR_FB_passthrough
#ifdef XRTRANSPORT_EXT_XR_FB_render_model

    {49001, &handle_xrEnumerateRenderModelPathsFB},


    {49002, &handle_xrGetRenderModelPropertiesFB},


    {49003, &handle_xrLoadRenderModelFB},

#endif // XRTRANSPORT_EXT_XR_FB_render_model
#ifdef XRTRANSPORT_EXT_XR_KHR_binding_modification
#endif // XRTRANSPORT_EXT_XR_KHR_binding_modification
#ifdef XRTRANSPORT_EXT_XR_VARJO_foveated_rendering
#endif // XRTRANSPORT_EXT_XR_VARJO_foveated_rendering
#ifdef XRTRANSPORT_EXT_XR_VARJO_composition_layer_depth_test
#endif // XRTRANSPORT_EXT_XR_VARJO_composition_layer_depth_test
#ifdef XRTRANSPORT_EXT_XR_VARJO_environment_depth_estimation

    {142001, &handle_xrSetEnvironmentDepthEstimationVARJO},

#endif // XRTRANSPORT_EXT_XR_VARJO_environment_depth_estimation
#ifdef XRTRANSPORT_EXT_XR_VARJO_marker_tracking

    {144005, &handle_xrSetMarkerTrackingVARJO},


    {144004, &handle_xrSetMarkerTrackingTimeoutVARJO},


    {144003, &handle_xrSetMarkerTrackingPredictionVARJO},


    {144002, &handle_xrGetMarkerSizeVARJO},


    {144001, &handle_xrCreateMarkerSpaceVARJO},

#endif // XRTRANSPORT_EXT_XR_VARJO_marker_tracking
#ifdef XRTRANSPORT_EXT_XR_VARJO_view_offset

    {145001, &handle_xrSetViewOffsetVARJO},

#endif // XRTRANSPORT_EXT_XR_VARJO_view_offset
#ifdef XRTRANSPORT_EXT_XR_ML_frame_end_info
#endif // XRTRANSPORT_EXT_XR_ML_frame_end_info
#ifdef XRTRANSPORT_EXT_XR_ML_global_dimmer
#endif // XRTRANSPORT_EXT_XR_ML_global_dimmer
#ifdef XRTRANSPORT_EXT_XR_ML_compat

    {112001, &handle_xrCreateSpaceFromCoordinateFrameUIDML},

#endif // XRTRANSPORT_EXT_XR_ML_compat
#ifdef XRTRANSPORT_EXT_XR_ML_marker_understanding

    {117001, &handle_xrCreateMarkerDetectorML},


    {117003, &handle_xrDestroyMarkerDetectorML},


    {117010, &handle_xrSnapshotMarkerDetectorML},


    {117004, &handle_xrGetMarkerDetectorStateML},


    {117009, &handle_xrGetMarkersML},


    {117007, &handle_xrGetMarkerReprojectionErrorML},


    {117005, &handle_xrGetMarkerLengthML},


    {117006, &handle_xrGetMarkerNumberML},


    {117008, &handle_xrGetMarkerStringML},


    {117002, &handle_xrCreateMarkerSpaceML},

#endif // XRTRANSPORT_EXT_XR_ML_marker_understanding
#ifdef XRTRANSPORT_EXT_XR_ML_localization_map

    {116003, &handle_xrEnableLocalizationEventsML},


    {116006, &handle_xrQueryLocalizationMapsML},


    {116007, &handle_xrRequestMapLocalizationML},


    {116005, &handle_xrImportLocalizationMapML},


    {116001, &handle_xrCreateExportedLocalizationMapML},


    {116002, &handle_xrDestroyExportedLocalizationMapML},


    {116004, &handle_xrGetExportedLocalizationMapDataML},

#endif // XRTRANSPORT_EXT_XR_ML_localization_map
#ifdef XRTRANSPORT_EXT_XR_ML_spatial_anchors

    {118001, &handle_xrCreateSpatialAnchorsAsyncML},


    {118002, &handle_xrCreateSpatialAnchorsCompleteML},


    {118003, &handle_xrGetSpatialAnchorStateML},

#endif // XRTRANSPORT_EXT_XR_ML_spatial_anchors
#ifdef XRTRANSPORT_EXT_XR_ML_spatial_anchors_storage

    {119001, &handle_xrCreateSpatialAnchorsStorageML},


    {119004, &handle_xrDestroySpatialAnchorsStorageML},


    {119007, &handle_xrQuerySpatialAnchorsAsyncML},


    {119008, &handle_xrQuerySpatialAnchorsCompleteML},


    {119005, &handle_xrPublishSpatialAnchorsAsyncML},


    {119006, &handle_xrPublishSpatialAnchorsCompleteML},


    {119002, &handle_xrDeleteSpatialAnchorsAsyncML},


    {119003, &handle_xrDeleteSpatialAnchorsCompleteML},


    {119009, &handle_xrUpdateSpatialAnchorsExpirationAsyncML},


    {119010, &handle_xrUpdateSpatialAnchorsExpirationCompleteML},

#endif // XRTRANSPORT_EXT_XR_ML_spatial_anchors_storage
#ifdef XRTRANSPORT_EXT_XR_ML_user_calibration

    {121001, &handle_xrEnableUserCalibrationEventsML},

#endif // XRTRANSPORT_EXT_XR_ML_user_calibration
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_anchor_persistence

    {135003, &handle_xrCreateSpatialAnchorStoreConnectionMSFT},


    {135004, &handle_xrDestroySpatialAnchorStoreConnectionMSFT},


    {135006, &handle_xrPersistSpatialAnchorMSFT},


    {135005, &handle_xrEnumeratePersistedSpatialAnchorNamesMSFT},


    {135002, &handle_xrCreateSpatialAnchorFromPersistedNameMSFT},


    {135007, &handle_xrUnpersistSpatialAnchorMSFT},


    {135001, &handle_xrClearSpatialAnchorStoreMSFT},

#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_anchor_persistence
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_marker

    {130002, &handle_xrGetSceneMarkerRawDataMSFT},


    {130001, &handle_xrGetSceneMarkerDecodedStringMSFT},

#endif // XRTRANSPORT_EXT_XR_MSFT_scene_marker
#ifdef XRTRANSPORT_EXT_XR_KHR_extended_struct_name_lengths

    {84001, &handle_xrStructureTypeToString2KHR},

#endif // XRTRANSPORT_EXT_XR_KHR_extended_struct_name_lengths
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_query

    {55001, &handle_xrQuerySpacesFB},


    {55002, &handle_xrRetrieveSpaceQueryResultsFB},

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_query
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_storage

    {57002, &handle_xrSaveSpaceFB},


    {57001, &handle_xrEraseSpaceFB},

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_storage
#ifdef XRTRANSPORT_EXT_XR_OCULUS_audio_device_guid

    {137002, &handle_xrGetAudioOutputDeviceGuidOculus},


    {137001, &handle_xrGetAudioInputDeviceGuidOculus},

#endif // XRTRANSPORT_EXT_XR_OCULUS_audio_device_guid
#ifdef XRTRANSPORT_EXT_XR_FB_foveation_vulkan
#endif // XRTRANSPORT_EXT_XR_FB_foveation_vulkan
#ifdef XRTRANSPORT_EXT_XR_FB_swapchain_update_state_android_surface
#endif // XRTRANSPORT_EXT_XR_FB_swapchain_update_state_android_surface
#ifdef XRTRANSPORT_EXT_XR_FB_swapchain_update_state_opengl_es
#endif // XRTRANSPORT_EXT_XR_FB_swapchain_update_state_opengl_es
#ifdef XRTRANSPORT_EXT_XR_FB_swapchain_update_state_vulkan
#endif // XRTRANSPORT_EXT_XR_FB_swapchain_update_state_vulkan
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_sharing

    {56001, &handle_xrShareSpacesFB},

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_sharing
#ifdef XRTRANSPORT_EXT_XR_FB_space_warp
#endif // XRTRANSPORT_EXT_XR_FB_space_warp
#ifdef XRTRANSPORT_EXT_XR_FB_haptic_amplitude_envelope
#endif // XRTRANSPORT_EXT_XR_FB_haptic_amplitude_envelope
#ifdef XRTRANSPORT_EXT_XR_FB_scene

    {50002, &handle_xrGetSpaceBoundingBox2DFB},


    {50003, &handle_xrGetSpaceBoundingBox3DFB},


    {50005, &handle_xrGetSpaceSemanticLabelsFB},


    {50001, &handle_xrGetSpaceBoundary2DFB},


    {50004, &handle_xrGetSpaceRoomLayoutFB},

#endif // XRTRANSPORT_EXT_XR_FB_scene
#ifdef XRTRANSPORT_EXT_XR_ALMALENCE_digital_lens_control

    {1001, &handle_xrSetDigitalLensControlALMALENCE},

#endif // XRTRANSPORT_EXT_XR_ALMALENCE_digital_lens_control
#ifdef XRTRANSPORT_EXT_XR_FB_scene_capture

    {51001, &handle_xrRequestSceneCaptureFB},

#endif // XRTRANSPORT_EXT_XR_FB_scene_capture
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_container

    {54001, &handle_xrGetSpaceContainerFB},

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_container
#ifdef XRTRANSPORT_EXT_XR_META_foveation_eye_tracked

    {98001, &handle_xrGetFoveationEyeTrackedStateMETA},

#endif // XRTRANSPORT_EXT_XR_META_foveation_eye_tracked
#ifdef XRTRANSPORT_EXT_XR_FB_face_tracking

    {36001, &handle_xrCreateFaceTrackerFB},


    {36002, &handle_xrDestroyFaceTrackerFB},


    {36003, &handle_xrGetFaceExpressionWeightsFB},

#endif // XRTRANSPORT_EXT_XR_FB_face_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_eye_tracking_social

    {35001, &handle_xrCreateEyeTrackerFB},


    {35002, &handle_xrDestroyEyeTrackerFB},


    {35003, &handle_xrGetEyeGazesFB},

#endif // XRTRANSPORT_EXT_XR_FB_eye_tracking_social
#ifdef XRTRANSPORT_EXT_XR_FB_passthrough_keyboard_hands

    {48001, &handle_xrPassthroughLayerSetKeyboardHandsIntensityFB},

#endif // XRTRANSPORT_EXT_XR_FB_passthrough_keyboard_hands
#ifdef XRTRANSPORT_EXT_XR_FB_composition_layer_settings
#endif // XRTRANSPORT_EXT_XR_FB_composition_layer_settings
#ifdef XRTRANSPORT_EXT_XR_FB_haptic_pcm

    {45001, &handle_xrGetDeviceSampleRateFB},

#endif // XRTRANSPORT_EXT_XR_FB_haptic_pcm
#ifdef XRTRANSPORT_EXT_XR_EXT_frame_synthesis
#endif // XRTRANSPORT_EXT_XR_EXT_frame_synthesis
#ifdef XRTRANSPORT_EXT_XR_FB_composition_layer_depth_test
#endif // XRTRANSPORT_EXT_XR_FB_composition_layer_depth_test
#ifdef XRTRANSPORT_EXT_XR_META_local_dimming
#endif // XRTRANSPORT_EXT_XR_META_local_dimming
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_preferences

    {103001, &handle_xrGetPassthroughPreferencesMETA},

#endif // XRTRANSPORT_EXT_XR_META_passthrough_preferences
#ifdef XRTRANSPORT_EXT_XR_META_virtual_keyboard

    {110002, &handle_xrCreateVirtualKeyboardMETA},


    {110004, &handle_xrDestroyVirtualKeyboardMETA},


    {110003, &handle_xrCreateVirtualKeyboardSpaceMETA},


    {110011, &handle_xrSuggestVirtualKeyboardLocationMETA},


    {110007, &handle_xrGetVirtualKeyboardScaleMETA},


    {110010, &handle_xrSetVirtualKeyboardModelVisibilityMETA},


    {110006, &handle_xrGetVirtualKeyboardModelAnimationStatesMETA},


    {110005, &handle_xrGetVirtualKeyboardDirtyTexturesMETA},


    {110008, &handle_xrGetVirtualKeyboardTextureDataMETA},


    {110009, &handle_xrSendVirtualKeyboardInputMETA},


    {110001, &handle_xrChangeVirtualKeyboardTextContextMETA},

#endif // XRTRANSPORT_EXT_XR_META_virtual_keyboard
#ifdef XRTRANSPORT_EXT_XR_OCULUS_external_camera

    {138001, &handle_xrEnumerateExternalCamerasOCULUS},

#endif // XRTRANSPORT_EXT_XR_OCULUS_external_camera
#ifdef XRTRANSPORT_EXT_XR_META_vulkan_swapchain_create_info
#endif // XRTRANSPORT_EXT_XR_META_vulkan_swapchain_create_info
#ifdef XRTRANSPORT_EXT_XR_META_performance_metrics

    {104001, &handle_xrEnumeratePerformanceMetricsCounterPathsMETA},


    {104004, &handle_xrSetPerformanceMetricsStateMETA},


    {104002, &handle_xrGetPerformanceMetricsStateMETA},


    {104003, &handle_xrQueryPerformanceMetricsCounterMETA},

#endif // XRTRANSPORT_EXT_XR_META_performance_metrics
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_storage_batch

    {58001, &handle_xrSaveSpaceListFB},

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_storage_batch
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_user

    {59001, &handle_xrCreateSpaceUserFB},


    {59003, &handle_xrGetSpaceUserIdFB},


    {59002, &handle_xrDestroySpaceUserFB},

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_user
#ifdef XRTRANSPORT_EXT_XR_META_headset_id
#endif // XRTRANSPORT_EXT_XR_META_headset_id
#ifdef XRTRANSPORT_EXT_XR_META_recommended_layer_resolution

    {105001, &handle_xrGetRecommendedLayerResolutionMETA},

#endif // XRTRANSPORT_EXT_XR_META_recommended_layer_resolution
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_color_lut

    {101001, &handle_xrCreatePassthroughColorLutMETA},


    {101002, &handle_xrDestroyPassthroughColorLutMETA},


    {101003, &handle_xrUpdatePassthroughColorLutMETA},

#endif // XRTRANSPORT_EXT_XR_META_passthrough_color_lut
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_mesh

    {108001, &handle_xrGetSpaceTriangleMeshMETA},

#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_mesh
#ifdef XRTRANSPORT_EXT_XR_META_body_tracking_full_body
#endif // XRTRANSPORT_EXT_XR_META_body_tracking_full_body
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_layer_resumed_event
#endif // XRTRANSPORT_EXT_XR_META_passthrough_layer_resumed_event
#ifdef XRTRANSPORT_EXT_XR_FB_face_tracking2

    {37001, &handle_xrCreateFaceTracker2FB},


    {37002, &handle_xrDestroyFaceTracker2FB},


    {37003, &handle_xrGetFaceExpressionWeights2FB},

#endif // XRTRANSPORT_EXT_XR_FB_face_tracking2
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_sharing

    {109001, &handle_xrShareSpacesMETA},

#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_sharing
#ifdef XRTRANSPORT_EXT_XR_META_environment_depth

    {97002, &handle_xrCreateEnvironmentDepthProviderMETA},


    {97004, &handle_xrDestroyEnvironmentDepthProviderMETA},


    {97009, &handle_xrStartEnvironmentDepthProviderMETA},


    {97010, &handle_xrStopEnvironmentDepthProviderMETA},


    {97003, &handle_xrCreateEnvironmentDepthSwapchainMETA},


    {97005, &handle_xrDestroyEnvironmentDepthSwapchainMETA},


    {97006, &handle_xrEnumerateEnvironmentDepthSwapchainImagesMETA},


    {97007, &handle_xrGetEnvironmentDepthSwapchainStateMETA},


    {97001, &handle_xrAcquireEnvironmentDepthImageMETA},


    {97008, &handle_xrSetEnvironmentDepthHandRemovalMETA},

#endif // XRTRANSPORT_EXT_XR_META_environment_depth
#ifdef XRTRANSPORT_EXT_XR_QCOM_tracking_optimization_settings

    {139001, &handle_xrSetTrackingOptimizationSettingsHintQCOM},

#endif // XRTRANSPORT_EXT_XR_QCOM_tracking_optimization_settings
#ifdef XRTRANSPORT_EXT_XR_HTC_passthrough

    {70001, &handle_xrCreatePassthroughHTC},


    {70002, &handle_xrDestroyPassthroughHTC},

#endif // XRTRANSPORT_EXT_XR_HTC_passthrough
#ifdef XRTRANSPORT_EXT_XR_HTC_foveation

    {69001, &handle_xrApplyFoveationHTC},

#endif // XRTRANSPORT_EXT_XR_HTC_foveation
#ifdef XRTRANSPORT_EXT_XR_HTC_anchor

    {66001, &handle_xrCreateSpatialAnchorHTC},


    {66002, &handle_xrGetSpatialAnchorNameHTC},

#endif // XRTRANSPORT_EXT_XR_HTC_anchor
#ifdef XRTRANSPORT_EXT_XR_HTC_body_tracking

    {67001, &handle_xrCreateBodyTrackerHTC},


    {67002, &handle_xrDestroyBodyTrackerHTC},


    {67004, &handle_xrLocateBodyJointsHTC},


    {67003, &handle_xrGetBodySkeletonHTC},

#endif // XRTRANSPORT_EXT_XR_HTC_body_tracking
#ifdef XRTRANSPORT_EXT_XR_EXT_active_action_set_priority
#endif // XRTRANSPORT_EXT_XR_EXT_active_action_set_priority
#ifdef XRTRANSPORT_EXT_XR_MNDX_force_feedback_curl

    {124001, &handle_xrApplyForceFeedbackCurlMNDX},

#endif // XRTRANSPORT_EXT_XR_MNDX_force_feedback_curl
#ifdef XRTRANSPORT_EXT_XR_BD_body_tracking

    {2001, &handle_xrCreateBodyTrackerBD},


    {2002, &handle_xrDestroyBodyTrackerBD},


    {2003, &handle_xrLocateBodyJointsBD},

#endif // XRTRANSPORT_EXT_XR_BD_body_tracking
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_sensing

    {8007, &handle_xrEnumerateSpatialEntityComponentTypesBD},


    {8012, &handle_xrGetSpatialEntityUuidBD},


    {8011, &handle_xrGetSpatialEntityComponentDataBD},


    {8002, &handle_xrCreateSenseDataProviderBD},


    {8015, &handle_xrStartSenseDataProviderAsyncBD},


    {8016, &handle_xrStartSenseDataProviderCompleteBD},


    {8010, &handle_xrGetSenseDataProviderStateBD},


    {8013, &handle_xrQuerySenseDataAsyncBD},


    {8014, &handle_xrQuerySenseDataCompleteBD},


    {8006, &handle_xrDestroySenseDataSnapshotBD},


    {8009, &handle_xrGetQueriedSenseDataBD},


    {8017, &handle_xrStopSenseDataProviderBD},


    {8005, &handle_xrDestroySenseDataProviderBD},


    {8003, &handle_xrCreateSpatialEntityAnchorBD},


    {8004, &handle_xrDestroyAnchorBD},


    {8008, &handle_xrGetAnchorUuidBD},


    {8001, &handle_xrCreateAnchorSpaceBD},

#endif // XRTRANSPORT_EXT_XR_BD_spatial_sensing
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_anchor

    {4001, &handle_xrCreateSpatialAnchorAsyncBD},


    {4002, &handle_xrCreateSpatialAnchorCompleteBD},


    {4003, &handle_xrPersistSpatialAnchorAsyncBD},


    {4004, &handle_xrPersistSpatialAnchorCompleteBD},


    {4005, &handle_xrUnpersistSpatialAnchorAsyncBD},


    {4006, &handle_xrUnpersistSpatialAnchorCompleteBD},

#endif // XRTRANSPORT_EXT_XR_BD_spatial_anchor
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_anchor_sharing

    {5003, &handle_xrShareSpatialAnchorAsyncBD},


    {5004, &handle_xrShareSpatialAnchorCompleteBD},


    {5001, &handle_xrDownloadSharedSpatialAnchorAsyncBD},


    {5002, &handle_xrDownloadSharedSpatialAnchorCompleteBD},

#endif // XRTRANSPORT_EXT_XR_BD_spatial_anchor_sharing
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_scene

    {7001, &handle_xrCaptureSceneAsyncBD},


    {7002, &handle_xrCaptureSceneCompleteBD},

#endif // XRTRANSPORT_EXT_XR_BD_spatial_scene
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_mesh
#endif // XRTRANSPORT_EXT_XR_BD_spatial_mesh
#ifdef XRTRANSPORT_EXT_XR_BD_future_progress
#endif // XRTRANSPORT_EXT_XR_BD_future_progress
#ifdef XRTRANSPORT_EXT_XR_EXT_hand_tracking_data_source
#endif // XRTRANSPORT_EXT_XR_EXT_hand_tracking_data_source
#ifdef XRTRANSPORT_EXT_XR_EXT_plane_detection

    {22002, &handle_xrCreatePlaneDetectorEXT},


    {22003, &handle_xrDestroyPlaneDetectorEXT},


    {22001, &handle_xrBeginPlaneDetectionEXT},


    {22004, &handle_xrGetPlaneDetectionStateEXT},


    {22005, &handle_xrGetPlaneDetectionsEXT},


    {22006, &handle_xrGetPlanePolygonBufferEXT},

#endif // XRTRANSPORT_EXT_XR_EXT_plane_detection
#ifdef XRTRANSPORT_EXT_XR_EXT_future

    {17002, &handle_xrPollFutureEXT},


    {17001, &handle_xrCancelFutureEXT},

#endif // XRTRANSPORT_EXT_XR_EXT_future
#ifdef XRTRANSPORT_EXT_XR_EXT_user_presence
#endif // XRTRANSPORT_EXT_XR_EXT_user_presence
#ifdef XRTRANSPORT_EXT_XR_ML_system_notifications

    {120001, &handle_xrSetSystemNotificationsML},

#endif // XRTRANSPORT_EXT_XR_ML_system_notifications
#ifdef XRTRANSPORT_EXT_XR_ML_world_mesh_detection

    {122002, &handle_xrCreateWorldMeshDetectorML},


    {122003, &handle_xrDestroyWorldMeshDetectorML},


    {122008, &handle_xrRequestWorldMeshStateAsyncML},


    {122009, &handle_xrRequestWorldMeshStateCompleteML},


    {122005, &handle_xrGetWorldMeshBufferRecommendSizeML},


    {122001, &handle_xrAllocateWorldMeshBufferML},


    {122004, &handle_xrFreeWorldMeshBufferML},


    {122006, &handle_xrRequestWorldMeshAsyncML},


    {122007, &handle_xrRequestWorldMeshCompleteML},

#endif // XRTRANSPORT_EXT_XR_ML_world_mesh_detection
#ifdef XRTRANSPORT_EXT_XR_ML_facial_expression

    {113001, &handle_xrCreateFacialExpressionClientML},


    {113002, &handle_xrDestroyFacialExpressionClientML},


    {113003, &handle_xrGetFacialExpressionBlendShapePropertiesML},

#endif // XRTRANSPORT_EXT_XR_ML_facial_expression
#ifdef XRTRANSPORT_EXT_XR_META_simultaneous_hands_and_controllers

    {106002, &handle_xrResumeSimultaneousHandsAndControllersTrackingMETA},


    {106001, &handle_xrPauseSimultaneousHandsAndControllersTrackingMETA},

#endif // XRTRANSPORT_EXT_XR_META_simultaneous_hands_and_controllers
#ifdef XRTRANSPORT_EXT_XR_META_colocation_discovery

    {96002, &handle_xrStartColocationDiscoveryMETA},


    {96004, &handle_xrStopColocationDiscoveryMETA},


    {96001, &handle_xrStartColocationAdvertisementMETA},


    {96003, &handle_xrStopColocationAdvertisementMETA},

#endif // XRTRANSPORT_EXT_XR_META_colocation_discovery
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_group_sharing
#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_group_sharing

    {1, &handle_xrAcquireSwapchainImage},


    {2, &handle_xrApplyHapticFeedback},


    {3, &handle_xrAttachSessionActionSets},


    {4, &handle_xrBeginFrame},


    {5, &handle_xrBeginSession},


    {6, &handle_xrCreateAction},


    {7, &handle_xrCreateActionSet},


    {8, &handle_xrCreateActionSpace},


    {10, &handle_xrCreateInstance},


    {11, &handle_xrCreateReferenceSpace},


    {12, &handle_xrCreateSession},


    {13, &handle_xrCreateSwapchain},


    {14, &handle_xrDestroyAction},


    {15, &handle_xrDestroyActionSet},


    {16, &handle_xrDestroyInstance},


    {17, &handle_xrDestroySession},


    {18, &handle_xrDestroySpace},


    {19, &handle_xrDestroySwapchain},


    {20, &handle_xrEndFrame},


    {21, &handle_xrEndSession},


    {22, &handle_xrEnumerateApiLayerProperties},


    {23, &handle_xrEnumerateBoundSourcesForAction},


    {24, &handle_xrEnumerateEnvironmentBlendModes},


    {25, &handle_xrEnumerateInstanceExtensionProperties},


    {26, &handle_xrEnumerateReferenceSpaces},


    {27, &handle_xrEnumerateSwapchainFormats},


    {28, &handle_xrEnumerateSwapchainImages},


    {29, &handle_xrEnumerateViewConfigurationViews},


    {30, &handle_xrEnumerateViewConfigurations},


    {31, &handle_xrGetActionStateBoolean},


    {32, &handle_xrGetActionStateFloat},


    {33, &handle_xrGetActionStatePose},


    {34, &handle_xrGetActionStateVector2f},


    {35, &handle_xrGetCurrentInteractionProfile},


    {36, &handle_xrGetInputSourceLocalizedName},


    {38, &handle_xrGetInstanceProperties},


    {39, &handle_xrGetReferenceSpaceBoundsRect},


    {40, &handle_xrGetSystem},


    {41, &handle_xrGetSystemProperties},


    {42, &handle_xrGetViewConfigurationProperties},


    {43, &handle_xrLocateSpace},


    {44, &handle_xrLocateSpaces},


    {45, &handle_xrLocateViews},


    {48, &handle_xrPathToString},


    {49, &handle_xrPollEvent},


    {50, &handle_xrReleaseSwapchainImage},


    {51, &handle_xrRequestExitSession},


    {52, &handle_xrResultToString},


    {53, &handle_xrStopHapticFeedback},


    {54, &handle_xrStringToPath},


    {55, &handle_xrStructureTypeToString},


    {56, &handle_xrSuggestInteractionProfileBindings},


    {57, &handle_xrSyncActions},


    {58, &handle_xrWaitFrame},


    {59, &handle_xrWaitSwapchainImage},


};

FunctionHandler function_handler_lookup(uint32_t function_id) {
    if (function_handler_lookup_table.find(function_id) == function_handler_lookup_table.end()) {
        throw UnknownFunctionIdException("Unknown function id in function_handler_lookup: " + std::to_string(function_id));
    }
    return function_handler_lookup_table.at(function_id);
}

} // namespace xrtransport
/*
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file was automatically generated by the code_generation module.
 * Any changes made to this file will be lost when regenerated.
 *
 * To modify this file, edit the corresponding template in:
 * code_generation/templates/server/function_dispatch_impl.mako
 */
#include "function_dispatch.h"

#include "xrtransport/server/function_loader.h"
#include "xrtransport/transport/transport.h"
#include "xrtransport/serialization/serializer.h"
#include "xrtransport/serialization/deserializer.h"
#include "xrtransport/util.h"
#include "xrtransport/time.h"

#include "openxr/openxr.h"

#include <spdlog/spdlog.h>

#include <unordered_map>
#include <string>

using std::uint32_t;

namespace xrtransport {

static XrTime start_runtime_timer() {
    return get_time();
}

static XrDuration end_runtime_timer(XrTime start_time) {
    return get_time() - start_time;
}

#ifdef XRTRANSPORT_EXT_XR_ALMALENCE_digital_lens_control
void FunctionDispatch::handle_xrSetDigitalLensControlALMALENCE(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetDigitalLensControlALMALENCE", function_loader.pfn_xrSetDigitalLensControlALMALENCE);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrDigitalLensControlALMALENCE* digitalLensControl{};
    deserialize_ptr(&digitalLensControl, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetDigitalLensControlALMALENCE(session, digitalLensControl);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(digitalLensControl, 1);
}

#endif // XRTRANSPORT_EXT_XR_ALMALENCE_digital_lens_control
#ifdef XRTRANSPORT_EXT_XR_BD_body_tracking
void FunctionDispatch::handle_xrCreateBodyTrackerBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateBodyTrackerBD", function_loader.pfn_xrCreateBodyTrackerBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrBodyTrackerCreateInfoBD* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrBodyTrackerBD* bodyTracker{};
    deserialize_ptr(&bodyTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateBodyTrackerBD(session, createInfo, bodyTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bodyTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(bodyTracker, 1);
}

void FunctionDispatch::handle_xrDestroyBodyTrackerBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyBodyTrackerBD", function_loader.pfn_xrDestroyBodyTrackerBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrBodyTrackerBD bodyTracker{};
    deserialize(&bodyTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyBodyTrackerBD(bodyTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
}

void FunctionDispatch::handle_xrLocateBodyJointsBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateBodyJointsBD", function_loader.pfn_xrLocateBodyJointsBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrBodyTrackerBD bodyTracker{};
    deserialize(&bodyTracker, d_ctx);
    XrBodyJointsLocateInfoBD* locateInfo{};
    deserialize_ptr(&locateInfo, d_ctx);
    XrBodyJointLocationsBD* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrLocateBodyJointsBD(bodyTracker, locateInfo, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations, 1, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
    cleanup_ptr(locateInfo, 1);
    cleanup_ptr(locations, 1);
}

#endif // XRTRANSPORT_EXT_XR_BD_body_tracking
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_anchor
void FunctionDispatch::handle_xrCreateSpatialAnchorAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorAsyncBD", function_loader.pfn_xrCreateSpatialAnchorAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSpatialAnchorCreateInfoBD* info{};
    deserialize_ptr(&info, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorAsyncBD(provider, info, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(info, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrCreateSpatialAnchorCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorCompleteBD", function_loader.pfn_xrCreateSpatialAnchorCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrSpatialAnchorCreateCompletionBD* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrPersistSpatialAnchorAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPersistSpatialAnchorAsyncBD", function_loader.pfn_xrPersistSpatialAnchorAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSpatialAnchorPersistInfoBD* info{};
    deserialize_ptr(&info, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPersistSpatialAnchorAsyncBD(provider, info, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(info, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrPersistSpatialAnchorCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPersistSpatialAnchorCompleteBD", function_loader.pfn_xrPersistSpatialAnchorCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrFutureCompletionEXT* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPersistSpatialAnchorCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrUnpersistSpatialAnchorAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUnpersistSpatialAnchorAsyncBD", function_loader.pfn_xrUnpersistSpatialAnchorAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSpatialAnchorUnpersistInfoBD* info{};
    deserialize_ptr(&info, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrUnpersistSpatialAnchorAsyncBD(provider, info, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(info, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrUnpersistSpatialAnchorCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUnpersistSpatialAnchorCompleteBD", function_loader.pfn_xrUnpersistSpatialAnchorCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrFutureCompletionEXT* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrUnpersistSpatialAnchorCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

#endif // XRTRANSPORT_EXT_XR_BD_spatial_anchor
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_anchor_sharing
void FunctionDispatch::handle_xrDownloadSharedSpatialAnchorAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDownloadSharedSpatialAnchorAsyncBD", function_loader.pfn_xrDownloadSharedSpatialAnchorAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSharedSpatialAnchorDownloadInfoBD* info{};
    deserialize_ptr(&info, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDownloadSharedSpatialAnchorAsyncBD(provider, info, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(info, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrDownloadSharedSpatialAnchorCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDownloadSharedSpatialAnchorCompleteBD", function_loader.pfn_xrDownloadSharedSpatialAnchorCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrFutureCompletionEXT* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDownloadSharedSpatialAnchorCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrShareSpatialAnchorAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrShareSpatialAnchorAsyncBD", function_loader.pfn_xrShareSpatialAnchorAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSpatialAnchorShareInfoBD* info{};
    deserialize_ptr(&info, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrShareSpatialAnchorAsyncBD(provider, info, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(info, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrShareSpatialAnchorCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrShareSpatialAnchorCompleteBD", function_loader.pfn_xrShareSpatialAnchorCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrFutureCompletionEXT* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrShareSpatialAnchorCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

#endif // XRTRANSPORT_EXT_XR_BD_spatial_anchor_sharing
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_scene
void FunctionDispatch::handle_xrCaptureSceneAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCaptureSceneAsyncBD", function_loader.pfn_xrCaptureSceneAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSceneCaptureInfoBD* info{};
    deserialize_ptr(&info, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCaptureSceneAsyncBD(provider, info, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(info, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrCaptureSceneCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCaptureSceneCompleteBD", function_loader.pfn_xrCaptureSceneCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrFutureCompletionEXT* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCaptureSceneCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

#endif // XRTRANSPORT_EXT_XR_BD_spatial_scene
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_sensing
void FunctionDispatch::handle_xrCreateAnchorSpaceBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateAnchorSpaceBD", function_loader.pfn_xrCreateAnchorSpaceBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrAnchorSpaceCreateInfoBD* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateAnchorSpaceBD(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrCreateSenseDataProviderBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSenseDataProviderBD", function_loader.pfn_xrCreateSenseDataProviderBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSenseDataProviderCreateInfoBD* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSenseDataProviderBD* provider{};
    deserialize_ptr(&provider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSenseDataProviderBD(session, createInfo, provider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(provider, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(provider, 1);
}

void FunctionDispatch::handle_xrCreateSpatialEntityAnchorBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialEntityAnchorBD", function_loader.pfn_xrCreateSpatialEntityAnchorBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSpatialEntityAnchorCreateInfoBD* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrAnchorBD* anchor{};
    deserialize_ptr(&anchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialEntityAnchorBD(provider, createInfo, anchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(anchor, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(anchor, 1);
}

void FunctionDispatch::handle_xrDestroyAnchorBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyAnchorBD", function_loader.pfn_xrDestroyAnchorBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrAnchorBD anchor{};
    deserialize(&anchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyAnchorBD(anchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&anchor);
}

void FunctionDispatch::handle_xrDestroySenseDataProviderBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySenseDataProviderBD", function_loader.pfn_xrDestroySenseDataProviderBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroySenseDataProviderBD(provider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&provider);
}

void FunctionDispatch::handle_xrDestroySenseDataSnapshotBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySenseDataSnapshotBD", function_loader.pfn_xrDestroySenseDataSnapshotBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataSnapshotBD snapshot{};
    deserialize(&snapshot, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroySenseDataSnapshotBD(snapshot);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&snapshot);
}

void FunctionDispatch::handle_xrEnumerateSpatialEntityComponentTypesBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateSpatialEntityComponentTypesBD", function_loader.pfn_xrEnumerateSpatialEntityComponentTypesBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataSnapshotBD snapshot{};
    deserialize(&snapshot, d_ctx);
    XrSpatialEntityIdBD entityId{};
    deserialize(&entityId, d_ctx);
    uint32_t componentTypeCapacityInput{};
    deserialize(&componentTypeCapacityInput, d_ctx);
    uint32_t* componentTypeCountOutput{};
    deserialize_ptr(&componentTypeCountOutput, d_ctx);
    XrSpatialEntityComponentTypeBD* componentTypes{};
    deserialize_ptr(&componentTypes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateSpatialEntityComponentTypesBD(snapshot, entityId, componentTypeCapacityInput, componentTypeCountOutput, componentTypes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(componentTypeCountOutput, 1, s_ctx);
    serialize_ptr(componentTypes, componentTypeCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&snapshot);
    cleanup(&entityId);
    cleanup(&componentTypeCapacityInput);
    cleanup_ptr(componentTypeCountOutput, 1);
    cleanup_ptr(componentTypes, componentTypeCapacityInput);
}

void FunctionDispatch::handle_xrGetAnchorUuidBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetAnchorUuidBD", function_loader.pfn_xrGetAnchorUuidBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrAnchorBD anchor{};
    deserialize(&anchor, d_ctx);
    XrUuidEXT* uuid{};
    deserialize_ptr(&uuid, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetAnchorUuidBD(anchor, uuid);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(uuid, 1, s_ctx);
    msg_out.flush();

    cleanup(&anchor);
    cleanup_ptr(uuid, 1);
}

void FunctionDispatch::handle_xrGetQueriedSenseDataBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetQueriedSenseDataBD", function_loader.pfn_xrGetQueriedSenseDataBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataSnapshotBD snapshot{};
    deserialize(&snapshot, d_ctx);
    XrQueriedSenseDataGetInfoBD* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrQueriedSenseDataBD* queriedSenseData{};
    deserialize_ptr(&queriedSenseData, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetQueriedSenseDataBD(snapshot, getInfo, queriedSenseData);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(getInfo, 1, s_ctx);
    serialize_ptr(queriedSenseData, 1, s_ctx);
    msg_out.flush();

    cleanup(&snapshot);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(queriedSenseData, 1);
}

void FunctionDispatch::handle_xrGetSenseDataProviderStateBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSenseDataProviderStateBD", function_loader.pfn_xrGetSenseDataProviderStateBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSenseDataProviderStateBD* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSenseDataProviderStateBD(provider, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetSpatialEntityComponentDataBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpatialEntityComponentDataBD", function_loader.pfn_xrGetSpatialEntityComponentDataBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataSnapshotBD snapshot{};
    deserialize(&snapshot, d_ctx);
    XrSpatialEntityComponentGetInfoBD* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrSpatialEntityComponentDataBaseHeaderBD* componentData{};
    deserialize_xr(&componentData, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpatialEntityComponentDataBD(snapshot, getInfo, componentData);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(componentData, s_ctx);
    msg_out.flush();

    cleanup(&snapshot);
    cleanup_ptr(getInfo, 1);
    cleanup_xr(componentData);
}

void FunctionDispatch::handle_xrGetSpatialEntityUuidBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpatialEntityUuidBD", function_loader.pfn_xrGetSpatialEntityUuidBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataSnapshotBD snapshot{};
    deserialize(&snapshot, d_ctx);
    XrSpatialEntityIdBD entityId{};
    deserialize(&entityId, d_ctx);
    XrUuidEXT* uuid{};
    deserialize_ptr(&uuid, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpatialEntityUuidBD(snapshot, entityId, uuid);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(uuid, 1, s_ctx);
    msg_out.flush();

    cleanup(&snapshot);
    cleanup(&entityId);
    cleanup_ptr(uuid, 1);
}

void FunctionDispatch::handle_xrQuerySenseDataAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQuerySenseDataAsyncBD", function_loader.pfn_xrQuerySenseDataAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSenseDataQueryInfoBD* queryInfo{};
    deserialize_ptr(&queryInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrQuerySenseDataAsyncBD(provider, queryInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(queryInfo, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrQuerySenseDataCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQuerySenseDataCompleteBD", function_loader.pfn_xrQuerySenseDataCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrSenseDataQueryCompletionBD* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrQuerySenseDataCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrStartSenseDataProviderAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStartSenseDataProviderAsyncBD", function_loader.pfn_xrStartSenseDataProviderAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSenseDataProviderStartInfoBD* startInfo{};
    deserialize_ptr(&startInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrStartSenseDataProviderAsyncBD(provider, startInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(startInfo, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrStartSenseDataProviderCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStartSenseDataProviderCompleteBD", function_loader.pfn_xrStartSenseDataProviderCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrFutureCompletionEXT* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrStartSenseDataProviderCompleteBD(session, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrStopSenseDataProviderBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStopSenseDataProviderBD", function_loader.pfn_xrStopSenseDataProviderBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrStopSenseDataProviderBD(provider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&provider);
}

#endif // XRTRANSPORT_EXT_XR_BD_spatial_sensing
#ifdef XRTRANSPORT_EXT_XR_EXT_conformance_automation
void FunctionDispatch::handle_xrSetInputDeviceActiveEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetInputDeviceActiveEXT", function_loader.pfn_xrSetInputDeviceActiveEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath interactionProfile{};
    deserialize(&interactionProfile, d_ctx);
    XrPath topLevelPath{};
    deserialize(&topLevelPath, d_ctx);
    XrBool32 isActive{};
    deserialize(&isActive, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetInputDeviceActiveEXT(session, interactionProfile, topLevelPath, isActive);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&interactionProfile);
    cleanup(&topLevelPath);
    cleanup(&isActive);
}

void FunctionDispatch::handle_xrSetInputDeviceLocationEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetInputDeviceLocationEXT", function_loader.pfn_xrSetInputDeviceLocationEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath topLevelPath{};
    deserialize(&topLevelPath, d_ctx);
    XrPath inputSourcePath{};
    deserialize(&inputSourcePath, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrPosef pose{};
    deserialize(&pose, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetInputDeviceLocationEXT(session, topLevelPath, inputSourcePath, space, pose);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&topLevelPath);
    cleanup(&inputSourcePath);
    cleanup(&space);
    cleanup(&pose);
}

void FunctionDispatch::handle_xrSetInputDeviceStateBoolEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetInputDeviceStateBoolEXT", function_loader.pfn_xrSetInputDeviceStateBoolEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath topLevelPath{};
    deserialize(&topLevelPath, d_ctx);
    XrPath inputSourcePath{};
    deserialize(&inputSourcePath, d_ctx);
    XrBool32 state{};
    deserialize(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetInputDeviceStateBoolEXT(session, topLevelPath, inputSourcePath, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&topLevelPath);
    cleanup(&inputSourcePath);
    cleanup(&state);
}

void FunctionDispatch::handle_xrSetInputDeviceStateFloatEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetInputDeviceStateFloatEXT", function_loader.pfn_xrSetInputDeviceStateFloatEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath topLevelPath{};
    deserialize(&topLevelPath, d_ctx);
    XrPath inputSourcePath{};
    deserialize(&inputSourcePath, d_ctx);
    float state{};
    deserialize(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetInputDeviceStateFloatEXT(session, topLevelPath, inputSourcePath, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&topLevelPath);
    cleanup(&inputSourcePath);
    cleanup(&state);
}

void FunctionDispatch::handle_xrSetInputDeviceStateVector2fEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetInputDeviceStateVector2fEXT", function_loader.pfn_xrSetInputDeviceStateVector2fEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath topLevelPath{};
    deserialize(&topLevelPath, d_ctx);
    XrPath inputSourcePath{};
    deserialize(&inputSourcePath, d_ctx);
    XrVector2f state{};
    deserialize(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetInputDeviceStateVector2fEXT(session, topLevelPath, inputSourcePath, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&topLevelPath);
    cleanup(&inputSourcePath);
    cleanup(&state);
}

#endif // XRTRANSPORT_EXT_XR_EXT_conformance_automation
#ifdef XRTRANSPORT_EXT_XR_EXT_debug_utils
void FunctionDispatch::handle_xrCreateDebugUtilsMessengerEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateDebugUtilsMessengerEXT", function_loader.pfn_xrCreateDebugUtilsMessengerEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrDebugUtilsMessengerCreateInfoEXT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrDebugUtilsMessengerEXT* messenger{};
    deserialize_ptr(&messenger, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateDebugUtilsMessengerEXT(instance, createInfo, messenger);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(createInfo->userData, 1, s_ctx);
    serialize_ptr(messenger, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(messenger, 1);
}

void FunctionDispatch::handle_xrDestroyDebugUtilsMessengerEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyDebugUtilsMessengerEXT", function_loader.pfn_xrDestroyDebugUtilsMessengerEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrDebugUtilsMessengerEXT messenger{};
    deserialize(&messenger, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyDebugUtilsMessengerEXT(messenger);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&messenger);
}

void FunctionDispatch::handle_xrSessionBeginDebugUtilsLabelRegionEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSessionBeginDebugUtilsLabelRegionEXT", function_loader.pfn_xrSessionBeginDebugUtilsLabelRegionEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrDebugUtilsLabelEXT* labelInfo{};
    deserialize_ptr(&labelInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSessionBeginDebugUtilsLabelRegionEXT(session, labelInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(labelInfo, 1);
}

void FunctionDispatch::handle_xrSessionEndDebugUtilsLabelRegionEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSessionEndDebugUtilsLabelRegionEXT", function_loader.pfn_xrSessionEndDebugUtilsLabelRegionEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSessionEndDebugUtilsLabelRegionEXT(session);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
}

void FunctionDispatch::handle_xrSessionInsertDebugUtilsLabelEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSessionInsertDebugUtilsLabelEXT", function_loader.pfn_xrSessionInsertDebugUtilsLabelEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrDebugUtilsLabelEXT* labelInfo{};
    deserialize_ptr(&labelInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSessionInsertDebugUtilsLabelEXT(session, labelInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(labelInfo, 1);
}

void FunctionDispatch::handle_xrSetDebugUtilsObjectNameEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetDebugUtilsObjectNameEXT", function_loader.pfn_xrSetDebugUtilsObjectNameEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrDebugUtilsObjectNameInfoEXT* nameInfo{};
    deserialize_ptr(&nameInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetDebugUtilsObjectNameEXT(instance, nameInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(nameInfo, 1);
}

void FunctionDispatch::handle_xrSubmitDebugUtilsMessageEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSubmitDebugUtilsMessageEXT", function_loader.pfn_xrSubmitDebugUtilsMessageEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrDebugUtilsMessageSeverityFlagsEXT messageSeverity{};
    deserialize(&messageSeverity, d_ctx);
    XrDebugUtilsMessageTypeFlagsEXT messageTypes{};
    deserialize(&messageTypes, d_ctx);
    XrDebugUtilsMessengerCallbackDataEXT* callbackData{};
    deserialize_ptr(&callbackData, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, callbackData);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(callbackData->objects, callbackData->objectCount, s_ctx);
    serialize_ptr(callbackData->sessionLabels, callbackData->sessionLabelCount, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&messageSeverity);
    cleanup(&messageTypes);
    cleanup_ptr(callbackData, 1);
}

#endif // XRTRANSPORT_EXT_XR_EXT_debug_utils
#ifdef XRTRANSPORT_EXT_XR_EXT_future
void FunctionDispatch::handle_xrCancelFutureEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCancelFutureEXT", function_loader.pfn_xrCancelFutureEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrFutureCancelInfoEXT* cancelInfo{};
    deserialize_ptr(&cancelInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCancelFutureEXT(instance, cancelInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(cancelInfo, 1);
}

void FunctionDispatch::handle_xrPollFutureEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPollFutureEXT", function_loader.pfn_xrPollFutureEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrFuturePollInfoEXT* pollInfo{};
    deserialize_ptr(&pollInfo, d_ctx);
    XrFuturePollResultEXT* pollResult{};
    deserialize_ptr(&pollResult, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPollFutureEXT(instance, pollInfo, pollResult);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(pollResult, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(pollInfo, 1);
    cleanup_ptr(pollResult, 1);
}

#endif // XRTRANSPORT_EXT_XR_EXT_future
#ifdef XRTRANSPORT_EXT_XR_EXT_hand_tracking
void FunctionDispatch::handle_xrCreateHandTrackerEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateHandTrackerEXT", function_loader.pfn_xrCreateHandTrackerEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrHandTrackerCreateInfoEXT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrHandTrackerEXT* handTracker{};
    deserialize_ptr(&handTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateHandTrackerEXT(session, createInfo, handTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(handTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(handTracker, 1);
}

void FunctionDispatch::handle_xrDestroyHandTrackerEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyHandTrackerEXT", function_loader.pfn_xrDestroyHandTrackerEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrHandTrackerEXT handTracker{};
    deserialize(&handTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyHandTrackerEXT(handTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&handTracker);
}

void FunctionDispatch::handle_xrLocateHandJointsEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateHandJointsEXT", function_loader.pfn_xrLocateHandJointsEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrHandTrackerEXT handTracker{};
    deserialize(&handTracker, d_ctx);
    XrHandJointsLocateInfoEXT* locateInfo{};
    deserialize_ptr(&locateInfo, d_ctx);
    XrHandJointLocationsEXT* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrLocateHandJointsEXT(handTracker, locateInfo, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations, 1, s_ctx);
    msg_out.flush();

    cleanup(&handTracker);
    cleanup_ptr(locateInfo, 1);
    cleanup_ptr(locations, 1);
}

#endif // XRTRANSPORT_EXT_XR_EXT_hand_tracking
#ifdef XRTRANSPORT_EXT_XR_EXT_performance_settings
void FunctionDispatch::handle_xrPerfSettingsSetPerformanceLevelEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPerfSettingsSetPerformanceLevelEXT", function_loader.pfn_xrPerfSettingsSetPerformanceLevelEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPerfSettingsDomainEXT domain{};
    deserialize(&domain, d_ctx);
    XrPerfSettingsLevelEXT level{};
    deserialize(&level, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPerfSettingsSetPerformanceLevelEXT(session, domain, level);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&domain);
    cleanup(&level);
}

#endif // XRTRANSPORT_EXT_XR_EXT_performance_settings
#ifdef XRTRANSPORT_EXT_XR_EXT_plane_detection
void FunctionDispatch::handle_xrBeginPlaneDetectionEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrBeginPlaneDetectionEXT", function_loader.pfn_xrBeginPlaneDetectionEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPlaneDetectorEXT planeDetector{};
    deserialize(&planeDetector, d_ctx);
    XrPlaneDetectorBeginInfoEXT* beginInfo{};
    deserialize_ptr(&beginInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrBeginPlaneDetectionEXT(planeDetector, beginInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&planeDetector);
    cleanup_ptr(beginInfo, 1);
}

void FunctionDispatch::handle_xrCreatePlaneDetectorEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreatePlaneDetectorEXT", function_loader.pfn_xrCreatePlaneDetectorEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPlaneDetectorCreateInfoEXT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrPlaneDetectorEXT* planeDetector{};
    deserialize_ptr(&planeDetector, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreatePlaneDetectorEXT(session, createInfo, planeDetector);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(planeDetector, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(planeDetector, 1);
}

void FunctionDispatch::handle_xrDestroyPlaneDetectorEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyPlaneDetectorEXT", function_loader.pfn_xrDestroyPlaneDetectorEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPlaneDetectorEXT planeDetector{};
    deserialize(&planeDetector, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyPlaneDetectorEXT(planeDetector);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&planeDetector);
}

void FunctionDispatch::handle_xrGetPlaneDetectionStateEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetPlaneDetectionStateEXT", function_loader.pfn_xrGetPlaneDetectionStateEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPlaneDetectorEXT planeDetector{};
    deserialize(&planeDetector, d_ctx);
    XrPlaneDetectionStateEXT* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetPlaneDetectionStateEXT(planeDetector, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&planeDetector);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetPlaneDetectionsEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetPlaneDetectionsEXT", function_loader.pfn_xrGetPlaneDetectionsEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPlaneDetectorEXT planeDetector{};
    deserialize(&planeDetector, d_ctx);
    XrPlaneDetectorGetInfoEXT* info{};
    deserialize_ptr(&info, d_ctx);
    XrPlaneDetectorLocationsEXT* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetPlaneDetectionsEXT(planeDetector, info, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations, 1, s_ctx);
    msg_out.flush();

    cleanup(&planeDetector);
    cleanup_ptr(info, 1);
    cleanup_ptr(locations, 1);
}

void FunctionDispatch::handle_xrGetPlanePolygonBufferEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetPlanePolygonBufferEXT", function_loader.pfn_xrGetPlanePolygonBufferEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPlaneDetectorEXT planeDetector{};
    deserialize(&planeDetector, d_ctx);
    uint64_t planeId{};
    deserialize(&planeId, d_ctx);
    uint32_t polygonBufferIndex{};
    deserialize(&polygonBufferIndex, d_ctx);
    XrPlaneDetectorPolygonBufferEXT* polygonBuffer{};
    deserialize_ptr(&polygonBuffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetPlanePolygonBufferEXT(planeDetector, planeId, polygonBufferIndex, polygonBuffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(polygonBuffer, 1, s_ctx);
    msg_out.flush();

    cleanup(&planeDetector);
    cleanup(&planeId);
    cleanup(&polygonBufferIndex);
    cleanup_ptr(polygonBuffer, 1);
}

#endif // XRTRANSPORT_EXT_XR_EXT_plane_detection
#ifdef XRTRANSPORT_EXT_XR_EXT_thermal_query
void FunctionDispatch::handle_xrThermalGetTemperatureTrendEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrThermalGetTemperatureTrendEXT", function_loader.pfn_xrThermalGetTemperatureTrendEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPerfSettingsDomainEXT domain{};
    deserialize(&domain, d_ctx);
    XrPerfSettingsNotificationLevelEXT* notificationLevel{};
    deserialize_ptr(&notificationLevel, d_ctx);
    float* tempHeadroom{};
    deserialize_ptr(&tempHeadroom, d_ctx);
    float* tempSlope{};
    deserialize_ptr(&tempSlope, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrThermalGetTemperatureTrendEXT(session, domain, notificationLevel, tempHeadroom, tempSlope);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(notificationLevel, 1, s_ctx);
    serialize_ptr(tempHeadroom, 1, s_ctx);
    serialize_ptr(tempSlope, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&domain);
    cleanup_ptr(notificationLevel, 1);
    cleanup_ptr(tempHeadroom, 1);
    cleanup_ptr(tempSlope, 1);
}

#endif // XRTRANSPORT_EXT_XR_EXT_thermal_query
#ifdef XRTRANSPORT_EXT_XR_FB_body_tracking
void FunctionDispatch::handle_xrCreateBodyTrackerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateBodyTrackerFB", function_loader.pfn_xrCreateBodyTrackerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrBodyTrackerCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrBodyTrackerFB* bodyTracker{};
    deserialize_ptr(&bodyTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateBodyTrackerFB(session, createInfo, bodyTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bodyTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(bodyTracker, 1);
}

void FunctionDispatch::handle_xrDestroyBodyTrackerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyBodyTrackerFB", function_loader.pfn_xrDestroyBodyTrackerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrBodyTrackerFB bodyTracker{};
    deserialize(&bodyTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyBodyTrackerFB(bodyTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
}

void FunctionDispatch::handle_xrGetBodySkeletonFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetBodySkeletonFB", function_loader.pfn_xrGetBodySkeletonFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrBodyTrackerFB bodyTracker{};
    deserialize(&bodyTracker, d_ctx);
    XrBodySkeletonFB* skeleton{};
    deserialize_ptr(&skeleton, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetBodySkeletonFB(bodyTracker, skeleton);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(skeleton, 1, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
    cleanup_ptr(skeleton, 1);
}

void FunctionDispatch::handle_xrLocateBodyJointsFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateBodyJointsFB", function_loader.pfn_xrLocateBodyJointsFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrBodyTrackerFB bodyTracker{};
    deserialize(&bodyTracker, d_ctx);
    XrBodyJointsLocateInfoFB* locateInfo{};
    deserialize_ptr(&locateInfo, d_ctx);
    XrBodyJointLocationsFB* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrLocateBodyJointsFB(bodyTracker, locateInfo, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations, 1, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
    cleanup_ptr(locateInfo, 1);
    cleanup_ptr(locations, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_body_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_color_space
void FunctionDispatch::handle_xrEnumerateColorSpacesFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateColorSpacesFB", function_loader.pfn_xrEnumerateColorSpacesFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint32_t colorSpaceCapacityInput{};
    deserialize(&colorSpaceCapacityInput, d_ctx);
    uint32_t* colorSpaceCountOutput{};
    deserialize_ptr(&colorSpaceCountOutput, d_ctx);
    XrColorSpaceFB* colorSpaces{};
    deserialize_ptr(&colorSpaces, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateColorSpacesFB(session, colorSpaceCapacityInput, colorSpaceCountOutput, colorSpaces);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(colorSpaceCountOutput, 1, s_ctx);
    serialize_ptr(colorSpaces, colorSpaceCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&colorSpaceCapacityInput);
    cleanup_ptr(colorSpaceCountOutput, 1);
    cleanup_ptr(colorSpaces, colorSpaceCapacityInput);
}

void FunctionDispatch::handle_xrSetColorSpaceFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetColorSpaceFB", function_loader.pfn_xrSetColorSpaceFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrColorSpaceFB colorSpace{};
    deserialize(&colorSpace, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetColorSpaceFB(session, colorSpace);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&colorSpace);
}

#endif // XRTRANSPORT_EXT_XR_FB_color_space
#ifdef XRTRANSPORT_EXT_XR_FB_display_refresh_rate
void FunctionDispatch::handle_xrEnumerateDisplayRefreshRatesFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateDisplayRefreshRatesFB", function_loader.pfn_xrEnumerateDisplayRefreshRatesFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint32_t displayRefreshRateCapacityInput{};
    deserialize(&displayRefreshRateCapacityInput, d_ctx);
    uint32_t* displayRefreshRateCountOutput{};
    deserialize_ptr(&displayRefreshRateCountOutput, d_ctx);
    float* displayRefreshRates{};
    deserialize_ptr(&displayRefreshRates, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateDisplayRefreshRatesFB(session, displayRefreshRateCapacityInput, displayRefreshRateCountOutput, displayRefreshRates);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(displayRefreshRateCountOutput, 1, s_ctx);
    serialize_ptr(displayRefreshRates, displayRefreshRateCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&displayRefreshRateCapacityInput);
    cleanup_ptr(displayRefreshRateCountOutput, 1);
    cleanup_ptr(displayRefreshRates, displayRefreshRateCapacityInput);
}

void FunctionDispatch::handle_xrGetDisplayRefreshRateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetDisplayRefreshRateFB", function_loader.pfn_xrGetDisplayRefreshRateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    float* displayRefreshRate{};
    deserialize_ptr(&displayRefreshRate, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetDisplayRefreshRateFB(session, displayRefreshRate);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(displayRefreshRate, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(displayRefreshRate, 1);
}

void FunctionDispatch::handle_xrRequestDisplayRefreshRateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestDisplayRefreshRateFB", function_loader.pfn_xrRequestDisplayRefreshRateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    float displayRefreshRate{};
    deserialize(&displayRefreshRate, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrRequestDisplayRefreshRateFB(session, displayRefreshRate);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&displayRefreshRate);
}

#endif // XRTRANSPORT_EXT_XR_FB_display_refresh_rate
#ifdef XRTRANSPORT_EXT_XR_FB_eye_tracking_social
void FunctionDispatch::handle_xrCreateEyeTrackerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateEyeTrackerFB", function_loader.pfn_xrCreateEyeTrackerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrEyeTrackerCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrEyeTrackerFB* eyeTracker{};
    deserialize_ptr(&eyeTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateEyeTrackerFB(session, createInfo, eyeTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(eyeTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(eyeTracker, 1);
}

void FunctionDispatch::handle_xrDestroyEyeTrackerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyEyeTrackerFB", function_loader.pfn_xrDestroyEyeTrackerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrEyeTrackerFB eyeTracker{};
    deserialize(&eyeTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyEyeTrackerFB(eyeTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&eyeTracker);
}

void FunctionDispatch::handle_xrGetEyeGazesFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetEyeGazesFB", function_loader.pfn_xrGetEyeGazesFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrEyeTrackerFB eyeTracker{};
    deserialize(&eyeTracker, d_ctx);
    XrEyeGazesInfoFB* gazeInfo{};
    deserialize_ptr(&gazeInfo, d_ctx);
    XrEyeGazesFB* eyeGazes{};
    deserialize_ptr(&eyeGazes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetEyeGazesFB(eyeTracker, gazeInfo, eyeGazes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(eyeGazes, 1, s_ctx);
    msg_out.flush();

    cleanup(&eyeTracker);
    cleanup_ptr(gazeInfo, 1);
    cleanup_ptr(eyeGazes, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_eye_tracking_social
#ifdef XRTRANSPORT_EXT_XR_FB_face_tracking
void FunctionDispatch::handle_xrCreateFaceTrackerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateFaceTrackerFB", function_loader.pfn_xrCreateFaceTrackerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFaceTrackerCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrFaceTrackerFB* faceTracker{};
    deserialize_ptr(&faceTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateFaceTrackerFB(session, createInfo, faceTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(faceTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(faceTracker, 1);
}

void FunctionDispatch::handle_xrDestroyFaceTrackerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyFaceTrackerFB", function_loader.pfn_xrDestroyFaceTrackerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrFaceTrackerFB faceTracker{};
    deserialize(&faceTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyFaceTrackerFB(faceTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&faceTracker);
}

void FunctionDispatch::handle_xrGetFaceExpressionWeightsFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetFaceExpressionWeightsFB", function_loader.pfn_xrGetFaceExpressionWeightsFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrFaceTrackerFB faceTracker{};
    deserialize(&faceTracker, d_ctx);
    XrFaceExpressionInfoFB* expressionInfo{};
    deserialize_ptr(&expressionInfo, d_ctx);
    XrFaceExpressionWeightsFB* expressionWeights{};
    deserialize_ptr(&expressionWeights, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetFaceExpressionWeightsFB(faceTracker, expressionInfo, expressionWeights);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(expressionWeights, 1, s_ctx);
    msg_out.flush();

    cleanup(&faceTracker);
    cleanup_ptr(expressionInfo, 1);
    cleanup_ptr(expressionWeights, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_face_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_face_tracking2
void FunctionDispatch::handle_xrCreateFaceTracker2FB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateFaceTracker2FB", function_loader.pfn_xrCreateFaceTracker2FB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFaceTrackerCreateInfo2FB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrFaceTracker2FB* faceTracker{};
    deserialize_ptr(&faceTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateFaceTracker2FB(session, createInfo, faceTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(createInfo->requestedDataSources, createInfo->requestedDataSourceCount, s_ctx);
    serialize_ptr(faceTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(faceTracker, 1);
}

void FunctionDispatch::handle_xrDestroyFaceTracker2FB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyFaceTracker2FB", function_loader.pfn_xrDestroyFaceTracker2FB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrFaceTracker2FB faceTracker{};
    deserialize(&faceTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyFaceTracker2FB(faceTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&faceTracker);
}

void FunctionDispatch::handle_xrGetFaceExpressionWeights2FB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetFaceExpressionWeights2FB", function_loader.pfn_xrGetFaceExpressionWeights2FB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrFaceTracker2FB faceTracker{};
    deserialize(&faceTracker, d_ctx);
    XrFaceExpressionInfo2FB* expressionInfo{};
    deserialize_ptr(&expressionInfo, d_ctx);
    XrFaceExpressionWeights2FB* expressionWeights{};
    deserialize_ptr(&expressionWeights, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetFaceExpressionWeights2FB(faceTracker, expressionInfo, expressionWeights);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(expressionWeights, 1, s_ctx);
    msg_out.flush();

    cleanup(&faceTracker);
    cleanup_ptr(expressionInfo, 1);
    cleanup_ptr(expressionWeights, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_face_tracking2
#ifdef XRTRANSPORT_EXT_XR_FB_foveation
void FunctionDispatch::handle_xrCreateFoveationProfileFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateFoveationProfileFB", function_loader.pfn_xrCreateFoveationProfileFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFoveationProfileCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrFoveationProfileFB* profile{};
    deserialize_ptr(&profile, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateFoveationProfileFB(session, createInfo, profile);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(createInfo->next, s_ctx);
    serialize_ptr(profile, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(profile, 1);
}

void FunctionDispatch::handle_xrDestroyFoveationProfileFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyFoveationProfileFB", function_loader.pfn_xrDestroyFoveationProfileFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrFoveationProfileFB profile{};
    deserialize(&profile, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyFoveationProfileFB(profile);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&profile);
}

#endif // XRTRANSPORT_EXT_XR_FB_foveation
#ifdef XRTRANSPORT_EXT_XR_FB_hand_tracking_mesh
void FunctionDispatch::handle_xrGetHandMeshFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetHandMeshFB", function_loader.pfn_xrGetHandMeshFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrHandTrackerEXT handTracker{};
    deserialize(&handTracker, d_ctx);
    XrHandTrackingMeshFB* mesh{};
    deserialize_ptr(&mesh, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetHandMeshFB(handTracker, mesh);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(mesh, 1, s_ctx);
    msg_out.flush();

    cleanup(&handTracker);
    cleanup_ptr(mesh, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_hand_tracking_mesh
#ifdef XRTRANSPORT_EXT_XR_FB_haptic_pcm
void FunctionDispatch::handle_xrGetDeviceSampleRateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetDeviceSampleRateFB", function_loader.pfn_xrGetDeviceSampleRateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrHapticActionInfo* hapticActionInfo{};
    deserialize_ptr(&hapticActionInfo, d_ctx);
    XrDevicePcmSampleRateGetInfoFB* deviceSampleRate{};
    deserialize_ptr(&deviceSampleRate, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetDeviceSampleRateFB(session, hapticActionInfo, deviceSampleRate);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(deviceSampleRate, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(hapticActionInfo, 1);
    cleanup_ptr(deviceSampleRate, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_haptic_pcm
#ifdef XRTRANSPORT_EXT_XR_FB_keyboard_tracking
void FunctionDispatch::handle_xrCreateKeyboardSpaceFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateKeyboardSpaceFB", function_loader.pfn_xrCreateKeyboardSpaceFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrKeyboardSpaceCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* keyboardSpace{};
    deserialize_ptr(&keyboardSpace, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateKeyboardSpaceFB(session, createInfo, keyboardSpace);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(createInfo->next, s_ctx);
    serialize_ptr(keyboardSpace, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(keyboardSpace, 1);
}

void FunctionDispatch::handle_xrQuerySystemTrackedKeyboardFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQuerySystemTrackedKeyboardFB", function_loader.pfn_xrQuerySystemTrackedKeyboardFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrKeyboardTrackingQueryFB* queryInfo{};
    deserialize_ptr(&queryInfo, d_ctx);
    XrKeyboardTrackingDescriptionFB* keyboard{};
    deserialize_ptr(&keyboard, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrQuerySystemTrackedKeyboardFB(session, queryInfo, keyboard);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(queryInfo->next, s_ctx);
    serialize_ptr(keyboard, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(queryInfo, 1);
    cleanup_ptr(keyboard, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_keyboard_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_passthrough
void FunctionDispatch::handle_xrCreateGeometryInstanceFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateGeometryInstanceFB", function_loader.pfn_xrCreateGeometryInstanceFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrGeometryInstanceCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrGeometryInstanceFB* outGeometryInstance{};
    deserialize_ptr(&outGeometryInstance, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateGeometryInstanceFB(session, createInfo, outGeometryInstance);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outGeometryInstance, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(outGeometryInstance, 1);
}

void FunctionDispatch::handle_xrCreatePassthroughFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreatePassthroughFB", function_loader.pfn_xrCreatePassthroughFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPassthroughCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrPassthroughFB* outPassthrough{};
    deserialize_ptr(&outPassthrough, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreatePassthroughFB(session, createInfo, outPassthrough);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outPassthrough, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(outPassthrough, 1);
}

void FunctionDispatch::handle_xrCreatePassthroughLayerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreatePassthroughLayerFB", function_loader.pfn_xrCreatePassthroughLayerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPassthroughLayerCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrPassthroughLayerFB* outLayer{};
    deserialize_ptr(&outLayer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreatePassthroughLayerFB(session, createInfo, outLayer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outLayer, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(outLayer, 1);
}

void FunctionDispatch::handle_xrDestroyGeometryInstanceFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyGeometryInstanceFB", function_loader.pfn_xrDestroyGeometryInstanceFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrGeometryInstanceFB instance{};
    deserialize(&instance, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyGeometryInstanceFB(instance);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
}

void FunctionDispatch::handle_xrDestroyPassthroughFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyPassthroughFB", function_loader.pfn_xrDestroyPassthroughFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPassthroughFB passthrough{};
    deserialize(&passthrough, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyPassthroughFB(passthrough);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&passthrough);
}

void FunctionDispatch::handle_xrDestroyPassthroughLayerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyPassthroughLayerFB", function_loader.pfn_xrDestroyPassthroughLayerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPassthroughLayerFB layer{};
    deserialize(&layer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyPassthroughLayerFB(layer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&layer);
}

void FunctionDispatch::handle_xrGeometryInstanceSetTransformFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGeometryInstanceSetTransformFB", function_loader.pfn_xrGeometryInstanceSetTransformFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrGeometryInstanceFB instance{};
    deserialize(&instance, d_ctx);
    XrGeometryInstanceTransformFB* transformation{};
    deserialize_ptr(&transformation, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGeometryInstanceSetTransformFB(instance, transformation);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(transformation, 1);
}

void FunctionDispatch::handle_xrPassthroughLayerPauseFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPassthroughLayerPauseFB", function_loader.pfn_xrPassthroughLayerPauseFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPassthroughLayerFB layer{};
    deserialize(&layer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPassthroughLayerPauseFB(layer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&layer);
}

void FunctionDispatch::handle_xrPassthroughLayerResumeFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPassthroughLayerResumeFB", function_loader.pfn_xrPassthroughLayerResumeFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPassthroughLayerFB layer{};
    deserialize(&layer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPassthroughLayerResumeFB(layer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&layer);
}

void FunctionDispatch::handle_xrPassthroughLayerSetStyleFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPassthroughLayerSetStyleFB", function_loader.pfn_xrPassthroughLayerSetStyleFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPassthroughLayerFB layer{};
    deserialize(&layer, d_ctx);
    XrPassthroughStyleFB* style{};
    deserialize_ptr(&style, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPassthroughLayerSetStyleFB(layer, style);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&layer);
    cleanup_ptr(style, 1);
}

void FunctionDispatch::handle_xrPassthroughPauseFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPassthroughPauseFB", function_loader.pfn_xrPassthroughPauseFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPassthroughFB passthrough{};
    deserialize(&passthrough, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPassthroughPauseFB(passthrough);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&passthrough);
}

void FunctionDispatch::handle_xrPassthroughStartFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPassthroughStartFB", function_loader.pfn_xrPassthroughStartFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPassthroughFB passthrough{};
    deserialize(&passthrough, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPassthroughStartFB(passthrough);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&passthrough);
}

#endif // XRTRANSPORT_EXT_XR_FB_passthrough
#ifdef XRTRANSPORT_EXT_XR_FB_passthrough_keyboard_hands
void FunctionDispatch::handle_xrPassthroughLayerSetKeyboardHandsIntensityFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPassthroughLayerSetKeyboardHandsIntensityFB", function_loader.pfn_xrPassthroughLayerSetKeyboardHandsIntensityFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPassthroughLayerFB layer{};
    deserialize(&layer, d_ctx);
    XrPassthroughKeyboardHandsIntensityFB* intensity{};
    deserialize_ptr(&intensity, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPassthroughLayerSetKeyboardHandsIntensityFB(layer, intensity);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&layer);
    cleanup_ptr(intensity, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_passthrough_keyboard_hands
#ifdef XRTRANSPORT_EXT_XR_FB_render_model
void FunctionDispatch::handle_xrEnumerateRenderModelPathsFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateRenderModelPathsFB", function_loader.pfn_xrEnumerateRenderModelPathsFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint32_t pathCapacityInput{};
    deserialize(&pathCapacityInput, d_ctx);
    uint32_t* pathCountOutput{};
    deserialize_ptr(&pathCountOutput, d_ctx);
    XrRenderModelPathInfoFB* paths{};
    deserialize_ptr(&paths, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateRenderModelPathsFB(session, pathCapacityInput, pathCountOutput, paths);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(pathCountOutput, 1, s_ctx);
    serialize_ptr(paths, pathCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&pathCapacityInput);
    cleanup_ptr(pathCountOutput, 1);
    cleanup_ptr(paths, pathCapacityInput);
}

void FunctionDispatch::handle_xrGetRenderModelPropertiesFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetRenderModelPropertiesFB", function_loader.pfn_xrGetRenderModelPropertiesFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath path{};
    deserialize(&path, d_ctx);
    XrRenderModelPropertiesFB* properties{};
    deserialize_ptr(&properties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetRenderModelPropertiesFB(session, path, properties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(properties, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&path);
    cleanup_ptr(properties, 1);
}

void FunctionDispatch::handle_xrLoadRenderModelFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLoadRenderModelFB", function_loader.pfn_xrLoadRenderModelFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrRenderModelLoadInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrRenderModelBufferFB* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrLoadRenderModelFB(session, info, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(info->next, s_ctx);
    serialize_ptr(buffer, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(buffer, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_render_model
#ifdef XRTRANSPORT_EXT_XR_FB_scene
void FunctionDispatch::handle_xrGetSpaceBoundary2DFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceBoundary2DFB", function_loader.pfn_xrGetSpaceBoundary2DFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrBoundary2DFB* boundary2DOutput{};
    deserialize_ptr(&boundary2DOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpaceBoundary2DFB(session, space, boundary2DOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(boundary2DOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&space);
    cleanup_ptr(boundary2DOutput, 1);
}

void FunctionDispatch::handle_xrGetSpaceBoundingBox2DFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceBoundingBox2DFB", function_loader.pfn_xrGetSpaceBoundingBox2DFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrRect2Df* boundingBox2DOutput{};
    deserialize_ptr(&boundingBox2DOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpaceBoundingBox2DFB(session, space, boundingBox2DOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(boundingBox2DOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&space);
    cleanup_ptr(boundingBox2DOutput, 1);
}

void FunctionDispatch::handle_xrGetSpaceBoundingBox3DFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceBoundingBox3DFB", function_loader.pfn_xrGetSpaceBoundingBox3DFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrRect3DfFB* boundingBox3DOutput{};
    deserialize_ptr(&boundingBox3DOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpaceBoundingBox3DFB(session, space, boundingBox3DOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(boundingBox3DOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&space);
    cleanup_ptr(boundingBox3DOutput, 1);
}

void FunctionDispatch::handle_xrGetSpaceRoomLayoutFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceRoomLayoutFB", function_loader.pfn_xrGetSpaceRoomLayoutFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrRoomLayoutFB* roomLayoutOutput{};
    deserialize_ptr(&roomLayoutOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpaceRoomLayoutFB(session, space, roomLayoutOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(roomLayoutOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&space);
    cleanup_ptr(roomLayoutOutput, 1);
}

void FunctionDispatch::handle_xrGetSpaceSemanticLabelsFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceSemanticLabelsFB", function_loader.pfn_xrGetSpaceSemanticLabelsFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrSemanticLabelsFB* semanticLabelsOutput{};
    deserialize_ptr(&semanticLabelsOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpaceSemanticLabelsFB(session, space, semanticLabelsOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(semanticLabelsOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&space);
    cleanup_ptr(semanticLabelsOutput, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_scene
#ifdef XRTRANSPORT_EXT_XR_FB_scene_capture
void FunctionDispatch::handle_xrRequestSceneCaptureFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestSceneCaptureFB", function_loader.pfn_xrRequestSceneCaptureFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSceneCaptureRequestInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrRequestSceneCaptureFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_scene_capture
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity
void FunctionDispatch::handle_xrCreateSpatialAnchorFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorFB", function_loader.pfn_xrCreateSpatialAnchorFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorCreateInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

void FunctionDispatch::handle_xrEnumerateSpaceSupportedComponentsFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateSpaceSupportedComponentsFB", function_loader.pfn_xrEnumerateSpaceSupportedComponentsFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpace space{};
    deserialize(&space, d_ctx);
    uint32_t componentTypeCapacityInput{};
    deserialize(&componentTypeCapacityInput, d_ctx);
    uint32_t* componentTypeCountOutput{};
    deserialize_ptr(&componentTypeCountOutput, d_ctx);
    XrSpaceComponentTypeFB* componentTypes{};
    deserialize_ptr(&componentTypes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateSpaceSupportedComponentsFB(space, componentTypeCapacityInput, componentTypeCountOutput, componentTypes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(componentTypeCountOutput, 1, s_ctx);
    serialize_ptr(componentTypes, componentTypeCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&space);
    cleanup(&componentTypeCapacityInput);
    cleanup_ptr(componentTypeCountOutput, 1);
    cleanup_ptr(componentTypes, componentTypeCapacityInput);
}

void FunctionDispatch::handle_xrGetSpaceComponentStatusFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceComponentStatusFB", function_loader.pfn_xrGetSpaceComponentStatusFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrSpaceComponentTypeFB componentType{};
    deserialize(&componentType, d_ctx);
    XrSpaceComponentStatusFB* status{};
    deserialize_ptr(&status, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpaceComponentStatusFB(space, componentType, status);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(status, 1, s_ctx);
    msg_out.flush();

    cleanup(&space);
    cleanup(&componentType);
    cleanup_ptr(status, 1);
}

void FunctionDispatch::handle_xrGetSpaceUuidFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceUuidFB", function_loader.pfn_xrGetSpaceUuidFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrUuidEXT* uuid{};
    deserialize_ptr(&uuid, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpaceUuidFB(space, uuid);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(uuid, 1, s_ctx);
    msg_out.flush();

    cleanup(&space);
    cleanup_ptr(uuid, 1);
}

void FunctionDispatch::handle_xrSetSpaceComponentStatusFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetSpaceComponentStatusFB", function_loader.pfn_xrSetSpaceComponentStatusFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrSpaceComponentStatusSetInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetSpaceComponentStatusFB(space, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&space);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_container
void FunctionDispatch::handle_xrGetSpaceContainerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceContainerFB", function_loader.pfn_xrGetSpaceContainerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrSpaceContainerFB* spaceContainerOutput{};
    deserialize_ptr(&spaceContainerOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpaceContainerFB(session, space, spaceContainerOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(spaceContainerOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&space);
    cleanup_ptr(spaceContainerOutput, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_container
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_query
void FunctionDispatch::handle_xrQuerySpacesFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQuerySpacesFB", function_loader.pfn_xrQuerySpacesFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpaceQueryInfoBaseHeaderFB* info{};
    deserialize_xr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrQuerySpacesFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_xr(info);
    cleanup_ptr(requestId, 1);
}

void FunctionDispatch::handle_xrRetrieveSpaceQueryResultsFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRetrieveSpaceQueryResultsFB", function_loader.pfn_xrRetrieveSpaceQueryResultsFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrAsyncRequestIdFB requestId{};
    deserialize(&requestId, d_ctx);
    XrSpaceQueryResultsFB* results{};
    deserialize_ptr(&results, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrRetrieveSpaceQueryResultsFB(session, requestId, results);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(results, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&requestId);
    cleanup_ptr(results, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_query
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_sharing
void FunctionDispatch::handle_xrShareSpacesFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrShareSpacesFB", function_loader.pfn_xrShareSpacesFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpaceShareInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrShareSpacesFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(info->spaces, info->spaceCount, s_ctx);
    serialize_ptr(info->users, info->userCount, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_sharing
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_storage
void FunctionDispatch::handle_xrEraseSpaceFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEraseSpaceFB", function_loader.pfn_xrEraseSpaceFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpaceEraseInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEraseSpaceFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

void FunctionDispatch::handle_xrSaveSpaceFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSaveSpaceFB", function_loader.pfn_xrSaveSpaceFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpaceSaveInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSaveSpaceFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_storage
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_storage_batch
void FunctionDispatch::handle_xrSaveSpaceListFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSaveSpaceListFB", function_loader.pfn_xrSaveSpaceListFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpaceListSaveInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSaveSpaceListFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(info->spaces, info->spaceCount, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_storage_batch
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_user
void FunctionDispatch::handle_xrCreateSpaceUserFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpaceUserFB", function_loader.pfn_xrCreateSpaceUserFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpaceUserCreateInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrSpaceUserFB* user{};
    deserialize_ptr(&user, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpaceUserFB(session, info, user);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(user, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(user, 1);
}

void FunctionDispatch::handle_xrDestroySpaceUserFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySpaceUserFB", function_loader.pfn_xrDestroySpaceUserFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpaceUserFB user{};
    deserialize(&user, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroySpaceUserFB(user);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&user);
}

void FunctionDispatch::handle_xrGetSpaceUserIdFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceUserIdFB", function_loader.pfn_xrGetSpaceUserIdFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpaceUserFB user{};
    deserialize(&user, d_ctx);
    XrSpaceUserIdFB* userId{};
    deserialize_ptr(&userId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpaceUserIdFB(user, userId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(userId, 1, s_ctx);
    msg_out.flush();

    cleanup(&user);
    cleanup_ptr(userId, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_user
#ifdef XRTRANSPORT_EXT_XR_FB_swapchain_update_state
void FunctionDispatch::handle_xrGetSwapchainStateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSwapchainStateFB", function_loader.pfn_xrGetSwapchainStateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);
    XrSwapchainStateBaseHeaderFB* state{};
    deserialize_xr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSwapchainStateFB(swapchain, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(state, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup_xr(state);
}

void FunctionDispatch::handle_xrUpdateSwapchainFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUpdateSwapchainFB", function_loader.pfn_xrUpdateSwapchainFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);
    XrSwapchainStateBaseHeaderFB* state{};
    deserialize_xr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrUpdateSwapchainFB(swapchain, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup_xr(state);
}

#endif // XRTRANSPORT_EXT_XR_FB_swapchain_update_state
#ifdef XRTRANSPORT_EXT_XR_FB_triangle_mesh
void FunctionDispatch::handle_xrCreateTriangleMeshFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateTriangleMeshFB", function_loader.pfn_xrCreateTriangleMeshFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrTriangleMeshCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrTriangleMeshFB* outTriangleMesh{};
    deserialize_ptr(&outTriangleMesh, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateTriangleMeshFB(session, createInfo, outTriangleMesh);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outTriangleMesh, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(outTriangleMesh, 1);
}

void FunctionDispatch::handle_xrDestroyTriangleMeshFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyTriangleMeshFB", function_loader.pfn_xrDestroyTriangleMeshFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyTriangleMeshFB(mesh);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
}

void FunctionDispatch::handle_xrTriangleMeshBeginUpdateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTriangleMeshBeginUpdateFB", function_loader.pfn_xrTriangleMeshBeginUpdateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrTriangleMeshBeginUpdateFB(mesh);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
}

void FunctionDispatch::handle_xrTriangleMeshBeginVertexBufferUpdateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTriangleMeshBeginVertexBufferUpdateFB", function_loader.pfn_xrTriangleMeshBeginVertexBufferUpdateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);
    uint32_t* outVertexCount{};
    deserialize_ptr(&outVertexCount, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrTriangleMeshBeginVertexBufferUpdateFB(mesh, outVertexCount);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outVertexCount, 1, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
    cleanup_ptr(outVertexCount, 1);
}

void FunctionDispatch::handle_xrTriangleMeshEndUpdateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTriangleMeshEndUpdateFB", function_loader.pfn_xrTriangleMeshEndUpdateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);
    uint32_t vertexCount{};
    deserialize(&vertexCount, d_ctx);
    uint32_t triangleCount{};
    deserialize(&triangleCount, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrTriangleMeshEndUpdateFB(mesh, vertexCount, triangleCount);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
    cleanup(&vertexCount);
    cleanup(&triangleCount);
}

void FunctionDispatch::handle_xrTriangleMeshEndVertexBufferUpdateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTriangleMeshEndVertexBufferUpdateFB", function_loader.pfn_xrTriangleMeshEndVertexBufferUpdateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrTriangleMeshEndVertexBufferUpdateFB(mesh);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
}

void FunctionDispatch::handle_xrTriangleMeshGetIndexBufferFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTriangleMeshGetIndexBufferFB", function_loader.pfn_xrTriangleMeshGetIndexBufferFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);
    uint32_t** outIndexBuffer{};
    #error "auto-generator doesn't support double pointers (outIndexBuffer)"None

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrTriangleMeshGetIndexBufferFB(mesh, outIndexBuffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outIndexBuffer, 1, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
    #error "auto-generator doesn't support double pointers (outIndexBuffer)"None
}

void FunctionDispatch::handle_xrTriangleMeshGetVertexBufferFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTriangleMeshGetVertexBufferFB", function_loader.pfn_xrTriangleMeshGetVertexBufferFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);
    XrVector3f** outVertexBuffer{};
    #error "auto-generator doesn't support double pointers (outVertexBuffer)"None

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrTriangleMeshGetVertexBufferFB(mesh, outVertexBuffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outVertexBuffer, 1, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
    #error "auto-generator doesn't support double pointers (outVertexBuffer)"None
}

#endif // XRTRANSPORT_EXT_XR_FB_triangle_mesh
#ifdef XRTRANSPORT_EXT_XR_HTCX_vive_tracker_interaction
void FunctionDispatch::handle_xrEnumerateViveTrackerPathsHTCX(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateViveTrackerPathsHTCX", function_loader.pfn_xrEnumerateViveTrackerPathsHTCX);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    uint32_t pathCapacityInput{};
    deserialize(&pathCapacityInput, d_ctx);
    uint32_t* pathCountOutput{};
    deserialize_ptr(&pathCountOutput, d_ctx);
    XrViveTrackerPathsHTCX* paths{};
    deserialize_ptr(&paths, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateViveTrackerPathsHTCX(instance, pathCapacityInput, pathCountOutput, paths);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(pathCountOutput, 1, s_ctx);
    serialize_ptr(paths, pathCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&pathCapacityInput);
    cleanup_ptr(pathCountOutput, 1);
    cleanup_ptr(paths, pathCapacityInput);
}

#endif // XRTRANSPORT_EXT_XR_HTCX_vive_tracker_interaction
#ifdef XRTRANSPORT_EXT_XR_HTC_anchor
void FunctionDispatch::handle_xrCreateSpatialAnchorHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorHTC", function_loader.pfn_xrCreateSpatialAnchorHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorCreateInfoHTC* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* anchor{};
    deserialize_ptr(&anchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorHTC(session, createInfo, anchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(anchor, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(anchor, 1);
}

void FunctionDispatch::handle_xrGetSpatialAnchorNameHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpatialAnchorNameHTC", function_loader.pfn_xrGetSpatialAnchorNameHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpace anchor{};
    deserialize(&anchor, d_ctx);
    XrSpatialAnchorNameHTC* name{};
    deserialize_ptr(&name, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpatialAnchorNameHTC(anchor, name);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(name, 1, s_ctx);
    msg_out.flush();

    cleanup(&anchor);
    cleanup_ptr(name, 1);
}

#endif // XRTRANSPORT_EXT_XR_HTC_anchor
#ifdef XRTRANSPORT_EXT_XR_HTC_body_tracking
void FunctionDispatch::handle_xrCreateBodyTrackerHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateBodyTrackerHTC", function_loader.pfn_xrCreateBodyTrackerHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrBodyTrackerCreateInfoHTC* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrBodyTrackerHTC* bodyTracker{};
    deserialize_ptr(&bodyTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateBodyTrackerHTC(session, createInfo, bodyTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bodyTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(bodyTracker, 1);
}

void FunctionDispatch::handle_xrDestroyBodyTrackerHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyBodyTrackerHTC", function_loader.pfn_xrDestroyBodyTrackerHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrBodyTrackerHTC bodyTracker{};
    deserialize(&bodyTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyBodyTrackerHTC(bodyTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
}

void FunctionDispatch::handle_xrGetBodySkeletonHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetBodySkeletonHTC", function_loader.pfn_xrGetBodySkeletonHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrBodyTrackerHTC bodyTracker{};
    deserialize(&bodyTracker, d_ctx);
    XrSpace baseSpace{};
    deserialize(&baseSpace, d_ctx);
    uint32_t skeletonGenerationId{};
    deserialize(&skeletonGenerationId, d_ctx);
    XrBodySkeletonHTC* skeleton{};
    deserialize_ptr(&skeleton, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetBodySkeletonHTC(bodyTracker, baseSpace, skeletonGenerationId, skeleton);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(skeleton, 1, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
    cleanup(&baseSpace);
    cleanup(&skeletonGenerationId);
    cleanup_ptr(skeleton, 1);
}

void FunctionDispatch::handle_xrLocateBodyJointsHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateBodyJointsHTC", function_loader.pfn_xrLocateBodyJointsHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrBodyTrackerHTC bodyTracker{};
    deserialize(&bodyTracker, d_ctx);
    XrBodyJointsLocateInfoHTC* locateInfo{};
    deserialize_ptr(&locateInfo, d_ctx);
    XrBodyJointLocationsHTC* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrLocateBodyJointsHTC(bodyTracker, locateInfo, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations, 1, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
    cleanup_ptr(locateInfo, 1);
    cleanup_ptr(locations, 1);
}

#endif // XRTRANSPORT_EXT_XR_HTC_body_tracking
#ifdef XRTRANSPORT_EXT_XR_HTC_facial_tracking
void FunctionDispatch::handle_xrCreateFacialTrackerHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateFacialTrackerHTC", function_loader.pfn_xrCreateFacialTrackerHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFacialTrackerCreateInfoHTC* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrFacialTrackerHTC* facialTracker{};
    deserialize_ptr(&facialTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateFacialTrackerHTC(session, createInfo, facialTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(facialTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(facialTracker, 1);
}

void FunctionDispatch::handle_xrDestroyFacialTrackerHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyFacialTrackerHTC", function_loader.pfn_xrDestroyFacialTrackerHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrFacialTrackerHTC facialTracker{};
    deserialize(&facialTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyFacialTrackerHTC(facialTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&facialTracker);
}

void FunctionDispatch::handle_xrGetFacialExpressionsHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetFacialExpressionsHTC", function_loader.pfn_xrGetFacialExpressionsHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrFacialTrackerHTC facialTracker{};
    deserialize(&facialTracker, d_ctx);
    XrFacialExpressionsHTC* facialExpressions{};
    deserialize_ptr(&facialExpressions, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetFacialExpressionsHTC(facialTracker, facialExpressions);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(facialExpressions, 1, s_ctx);
    msg_out.flush();

    cleanup(&facialTracker);
    cleanup_ptr(facialExpressions, 1);
}

#endif // XRTRANSPORT_EXT_XR_HTC_facial_tracking
#ifdef XRTRANSPORT_EXT_XR_HTC_foveation
void FunctionDispatch::handle_xrApplyFoveationHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrApplyFoveationHTC", function_loader.pfn_xrApplyFoveationHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFoveationApplyInfoHTC* applyInfo{};
    deserialize_ptr(&applyInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrApplyFoveationHTC(session, applyInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(applyInfo->subImages, applyInfo->subImageCount, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(applyInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_HTC_foveation
#ifdef XRTRANSPORT_EXT_XR_HTC_passthrough
void FunctionDispatch::handle_xrCreatePassthroughHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreatePassthroughHTC", function_loader.pfn_xrCreatePassthroughHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPassthroughCreateInfoHTC* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrPassthroughHTC* passthrough{};
    deserialize_ptr(&passthrough, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreatePassthroughHTC(session, createInfo, passthrough);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(passthrough, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(passthrough, 1);
}

void FunctionDispatch::handle_xrDestroyPassthroughHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyPassthroughHTC", function_loader.pfn_xrDestroyPassthroughHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPassthroughHTC passthrough{};
    deserialize(&passthrough, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyPassthroughHTC(passthrough);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&passthrough);
}

#endif // XRTRANSPORT_EXT_XR_HTC_passthrough
#ifdef XRTRANSPORT_EXT_XR_KHR_D3D11_enable
void FunctionDispatch::handle_xrGetD3D11GraphicsRequirementsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetD3D11GraphicsRequirementsKHR", function_loader.pfn_xrGetD3D11GraphicsRequirementsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrGraphicsRequirementsD3D11KHR* graphicsRequirements{};
    deserialize_ptr(&graphicsRequirements, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetD3D11GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(graphicsRequirements, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(graphicsRequirements, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_D3D11_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_D3D12_enable
void FunctionDispatch::handle_xrGetD3D12GraphicsRequirementsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetD3D12GraphicsRequirementsKHR", function_loader.pfn_xrGetD3D12GraphicsRequirementsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrGraphicsRequirementsD3D12KHR* graphicsRequirements{};
    deserialize_ptr(&graphicsRequirements, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetD3D12GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(graphicsRequirements, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(graphicsRequirements, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_D3D12_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_android_surface_swapchain
void FunctionDispatch::handle_xrCreateSwapchainAndroidSurfaceKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSwapchainAndroidSurfaceKHR", function_loader.pfn_xrCreateSwapchainAndroidSurfaceKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSwapchainCreateInfo* info{};
    deserialize_ptr(&info, d_ctx);
    XrSwapchain* swapchain{};
    deserialize_ptr(&swapchain, d_ctx);
    jobject* surface{};
    deserialize_ptr(&surface, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSwapchainAndroidSurfaceKHR(session, info, swapchain, surface);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(swapchain, 1, s_ctx);
    serialize_ptr(surface, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(swapchain, 1);
    cleanup_ptr(surface, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_android_surface_swapchain
#ifdef XRTRANSPORT_EXT_XR_KHR_android_thread_settings
void FunctionDispatch::handle_xrSetAndroidApplicationThreadKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetAndroidApplicationThreadKHR", function_loader.pfn_xrSetAndroidApplicationThreadKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrAndroidThreadTypeKHR threadType{};
    deserialize(&threadType, d_ctx);
    uint32_t threadId{};
    deserialize(&threadId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetAndroidApplicationThreadKHR(session, threadType, threadId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&threadType);
    cleanup(&threadId);
}

#endif // XRTRANSPORT_EXT_XR_KHR_android_thread_settings
#ifdef XRTRANSPORT_EXT_XR_KHR_convert_timespec_time
void FunctionDispatch::handle_xrConvertTimeToTimespecTimeKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrConvertTimeToTimespecTimeKHR", function_loader.pfn_xrConvertTimeToTimespecTimeKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrTime time{};
    deserialize_time(&time, d_ctx);
    timespec* timespecTime{};
    deserialize_ptr(&timespecTime, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrConvertTimeToTimespecTimeKHR(instance, time, timespecTime);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(timespecTime, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&time);
    cleanup_ptr(timespecTime, 1);
}

void FunctionDispatch::handle_xrConvertTimespecTimeToTimeKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrConvertTimespecTimeToTimeKHR", function_loader.pfn_xrConvertTimespecTimeToTimeKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    timespec* timespecTime{};
    deserialize_ptr(&timespecTime, d_ctx);
    XrTime* time{};
    deserialize_ptr(&time, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrConvertTimespecTimeToTimeKHR(instance, timespecTime, time);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(timespecTime, 1, s_ctx);
    serialize_ptr(time, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(timespecTime, 1);
    cleanup_ptr(time, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_convert_timespec_time
#ifdef XRTRANSPORT_EXT_XR_KHR_extended_struct_name_lengths
void FunctionDispatch::handle_xrStructureTypeToString2KHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStructureTypeToString2KHR", function_loader.pfn_xrStructureTypeToString2KHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrStructureType value{};
    deserialize(&value, d_ctx);
    char buffer[XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR]{};
    deserialize_array(buffer, XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrStructureTypeToString2KHR(instance, value, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(buffer, XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&value);
    cleanup_array(buffer, XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR);
}

#endif // XRTRANSPORT_EXT_XR_KHR_extended_struct_name_lengths
#ifdef XRTRANSPORT_EXT_XR_KHR_loader_init
void FunctionDispatch::handle_xrInitializeLoaderKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrInitializeLoaderKHR", function_loader.pfn_xrInitializeLoaderKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrLoaderInitInfoBaseHeaderKHR* loaderInitInfo{};
    deserialize_xr(&loaderInitInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrInitializeLoaderKHR(loaderInitInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup_xr(loaderInitInfo);
}

#endif // XRTRANSPORT_EXT_XR_KHR_loader_init
#ifdef XRTRANSPORT_EXT_XR_KHR_metal_enable
void FunctionDispatch::handle_xrGetMetalGraphicsRequirementsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMetalGraphicsRequirementsKHR", function_loader.pfn_xrGetMetalGraphicsRequirementsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrGraphicsRequirementsMetalKHR* graphicsRequirements{};
    deserialize_ptr(&graphicsRequirements, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetMetalGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(graphicsRequirements, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(graphicsRequirements, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_metal_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_opengl_enable
void FunctionDispatch::handle_xrGetOpenGLGraphicsRequirementsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetOpenGLGraphicsRequirementsKHR", function_loader.pfn_xrGetOpenGLGraphicsRequirementsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrGraphicsRequirementsOpenGLKHR* graphicsRequirements{};
    deserialize_ptr(&graphicsRequirements, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetOpenGLGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(graphicsRequirements, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(graphicsRequirements, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_opengl_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_opengl_es_enable
void FunctionDispatch::handle_xrGetOpenGLESGraphicsRequirementsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetOpenGLESGraphicsRequirementsKHR", function_loader.pfn_xrGetOpenGLESGraphicsRequirementsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrGraphicsRequirementsOpenGLESKHR* graphicsRequirements{};
    deserialize_ptr(&graphicsRequirements, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetOpenGLESGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(graphicsRequirements, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(graphicsRequirements, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_opengl_es_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_visibility_mask
void FunctionDispatch::handle_xrGetVisibilityMaskKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVisibilityMaskKHR", function_loader.pfn_xrGetVisibilityMaskKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrViewConfigurationType viewConfigurationType{};
    deserialize(&viewConfigurationType, d_ctx);
    uint32_t viewIndex{};
    deserialize(&viewIndex, d_ctx);
    XrVisibilityMaskTypeKHR visibilityMaskType{};
    deserialize(&visibilityMaskType, d_ctx);
    XrVisibilityMaskKHR* visibilityMask{};
    deserialize_ptr(&visibilityMask, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetVisibilityMaskKHR(session, viewConfigurationType, viewIndex, visibilityMaskType, visibilityMask);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(visibilityMask, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&viewConfigurationType);
    cleanup(&viewIndex);
    cleanup(&visibilityMaskType);
    cleanup_ptr(visibilityMask, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_visibility_mask
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_enable
void FunctionDispatch::handle_xrGetVulkanDeviceExtensionsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVulkanDeviceExtensionsKHR", function_loader.pfn_xrGetVulkanDeviceExtensionsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetVulkanDeviceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

void FunctionDispatch::handle_xrGetVulkanGraphicsDeviceKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVulkanGraphicsDeviceKHR", function_loader.pfn_xrGetVulkanGraphicsDeviceKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    VkInstance vkInstance{};
    deserialize(&vkInstance, d_ctx);
    VkPhysicalDevice* vkPhysicalDevice{};
    deserialize_ptr(&vkPhysicalDevice, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetVulkanGraphicsDeviceKHR(instance, systemId, vkInstance, vkPhysicalDevice);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(vkPhysicalDevice, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&vkInstance);
    cleanup_ptr(vkPhysicalDevice, 1);
}

void FunctionDispatch::handle_xrGetVulkanGraphicsRequirementsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVulkanGraphicsRequirementsKHR", function_loader.pfn_xrGetVulkanGraphicsRequirementsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrGraphicsRequirementsVulkanKHR* graphicsRequirements{};
    deserialize_ptr(&graphicsRequirements, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetVulkanGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(graphicsRequirements, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(graphicsRequirements, 1);
}

void FunctionDispatch::handle_xrGetVulkanInstanceExtensionsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVulkanInstanceExtensionsKHR", function_loader.pfn_xrGetVulkanInstanceExtensionsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetVulkanInstanceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_enable2
void FunctionDispatch::handle_xrCreateVulkanDeviceKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateVulkanDeviceKHR", function_loader.pfn_xrCreateVulkanDeviceKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrVulkanDeviceCreateInfoKHR* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    VkDevice* vulkanDevice{};
    deserialize_ptr(&vulkanDevice, d_ctx);
    VkResult* vulkanResult{};
    deserialize_ptr(&vulkanResult, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateVulkanDeviceKHR(instance, createInfo, vulkanDevice, vulkanResult);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(vulkanDevice, 1, s_ctx);
    serialize_ptr(vulkanResult, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(vulkanDevice, 1);
    cleanup_ptr(vulkanResult, 1);
}

void FunctionDispatch::handle_xrCreateVulkanInstanceKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateVulkanInstanceKHR", function_loader.pfn_xrCreateVulkanInstanceKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrVulkanInstanceCreateInfoKHR* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    VkInstance* vulkanInstance{};
    deserialize_ptr(&vulkanInstance, d_ctx);
    VkResult* vulkanResult{};
    deserialize_ptr(&vulkanResult, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateVulkanInstanceKHR(instance, createInfo, vulkanInstance, vulkanResult);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(vulkanInstance, 1, s_ctx);
    serialize_ptr(vulkanResult, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(vulkanInstance, 1);
    cleanup_ptr(vulkanResult, 1);
}

void FunctionDispatch::handle_xrGetVulkanGraphicsDevice2KHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVulkanGraphicsDevice2KHR", function_loader.pfn_xrGetVulkanGraphicsDevice2KHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrVulkanGraphicsDeviceGetInfoKHR* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    VkPhysicalDevice* vulkanPhysicalDevice{};
    deserialize_ptr(&vulkanPhysicalDevice, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetVulkanGraphicsDevice2KHR(instance, getInfo, vulkanPhysicalDevice);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(vulkanPhysicalDevice, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(vulkanPhysicalDevice, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_enable2
#ifdef XRTRANSPORT_EXT_XR_KHR_win32_convert_performance_counter_time
void FunctionDispatch::handle_xrConvertTimeToWin32PerformanceCounterKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrConvertTimeToWin32PerformanceCounterKHR", function_loader.pfn_xrConvertTimeToWin32PerformanceCounterKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrTime time{};
    deserialize_time(&time, d_ctx);
    LARGE_INTEGER* performanceCounter{};
    deserialize_ptr(&performanceCounter, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrConvertTimeToWin32PerformanceCounterKHR(instance, time, performanceCounter);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(performanceCounter, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&time);
    cleanup_ptr(performanceCounter, 1);
}

void FunctionDispatch::handle_xrConvertWin32PerformanceCounterToTimeKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrConvertWin32PerformanceCounterToTimeKHR", function_loader.pfn_xrConvertWin32PerformanceCounterToTimeKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    LARGE_INTEGER* performanceCounter{};
    deserialize_ptr(&performanceCounter, d_ctx);
    XrTime* time{};
    deserialize_ptr(&time, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrConvertWin32PerformanceCounterToTimeKHR(instance, performanceCounter, time);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(time, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(performanceCounter, 1);
    cleanup_ptr(time, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_win32_convert_performance_counter_time
#ifdef XRTRANSPORT_EXT_XR_META_colocation_discovery
void FunctionDispatch::handle_xrStartColocationAdvertisementMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStartColocationAdvertisementMETA", function_loader.pfn_xrStartColocationAdvertisementMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrColocationAdvertisementStartInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* advertisementRequestId{};
    deserialize_ptr(&advertisementRequestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrStartColocationAdvertisementMETA(session, info, advertisementRequestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(info->buffer, info->bufferSize, s_ctx);
    serialize_ptr(advertisementRequestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(advertisementRequestId, 1);
}

void FunctionDispatch::handle_xrStartColocationDiscoveryMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStartColocationDiscoveryMETA", function_loader.pfn_xrStartColocationDiscoveryMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrColocationDiscoveryStartInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* discoveryRequestId{};
    deserialize_ptr(&discoveryRequestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrStartColocationDiscoveryMETA(session, info, discoveryRequestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(discoveryRequestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(discoveryRequestId, 1);
}

void FunctionDispatch::handle_xrStopColocationAdvertisementMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStopColocationAdvertisementMETA", function_loader.pfn_xrStopColocationAdvertisementMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrColocationAdvertisementStopInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrStopColocationAdvertisementMETA(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

void FunctionDispatch::handle_xrStopColocationDiscoveryMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStopColocationDiscoveryMETA", function_loader.pfn_xrStopColocationDiscoveryMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrColocationDiscoveryStopInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrStopColocationDiscoveryMETA(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_colocation_discovery
#ifdef XRTRANSPORT_EXT_XR_META_environment_depth
void FunctionDispatch::handle_xrAcquireEnvironmentDepthImageMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrAcquireEnvironmentDepthImageMETA", function_loader.pfn_xrAcquireEnvironmentDepthImageMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrEnvironmentDepthProviderMETA environmentDepthProvider{};
    deserialize(&environmentDepthProvider, d_ctx);
    XrEnvironmentDepthImageAcquireInfoMETA* acquireInfo{};
    deserialize_ptr(&acquireInfo, d_ctx);
    XrEnvironmentDepthImageMETA* environmentDepthImage{};
    deserialize_ptr(&environmentDepthImage, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrAcquireEnvironmentDepthImageMETA(environmentDepthProvider, acquireInfo, environmentDepthImage);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(environmentDepthImage, 1, s_ctx);
    msg_out.flush();

    cleanup(&environmentDepthProvider);
    cleanup_ptr(acquireInfo, 1);
    cleanup_ptr(environmentDepthImage, 1);
}

void FunctionDispatch::handle_xrCreateEnvironmentDepthProviderMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateEnvironmentDepthProviderMETA", function_loader.pfn_xrCreateEnvironmentDepthProviderMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrEnvironmentDepthProviderCreateInfoMETA* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrEnvironmentDepthProviderMETA* environmentDepthProvider{};
    deserialize_ptr(&environmentDepthProvider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateEnvironmentDepthProviderMETA(session, createInfo, environmentDepthProvider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(environmentDepthProvider, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(environmentDepthProvider, 1);
}

void FunctionDispatch::handle_xrCreateEnvironmentDepthSwapchainMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateEnvironmentDepthSwapchainMETA", function_loader.pfn_xrCreateEnvironmentDepthSwapchainMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrEnvironmentDepthProviderMETA environmentDepthProvider{};
    deserialize(&environmentDepthProvider, d_ctx);
    XrEnvironmentDepthSwapchainCreateInfoMETA* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrEnvironmentDepthSwapchainMETA* swapchain{};
    deserialize_ptr(&swapchain, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateEnvironmentDepthSwapchainMETA(environmentDepthProvider, createInfo, swapchain);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(swapchain, 1, s_ctx);
    msg_out.flush();

    cleanup(&environmentDepthProvider);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(swapchain, 1);
}

void FunctionDispatch::handle_xrDestroyEnvironmentDepthProviderMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyEnvironmentDepthProviderMETA", function_loader.pfn_xrDestroyEnvironmentDepthProviderMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrEnvironmentDepthProviderMETA environmentDepthProvider{};
    deserialize(&environmentDepthProvider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyEnvironmentDepthProviderMETA(environmentDepthProvider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&environmentDepthProvider);
}

void FunctionDispatch::handle_xrDestroyEnvironmentDepthSwapchainMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyEnvironmentDepthSwapchainMETA", function_loader.pfn_xrDestroyEnvironmentDepthSwapchainMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrEnvironmentDepthSwapchainMETA swapchain{};
    deserialize(&swapchain, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyEnvironmentDepthSwapchainMETA(swapchain);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
}

void FunctionDispatch::handle_xrEnumerateEnvironmentDepthSwapchainImagesMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateEnvironmentDepthSwapchainImagesMETA", function_loader.pfn_xrEnumerateEnvironmentDepthSwapchainImagesMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrEnvironmentDepthSwapchainMETA swapchain{};
    deserialize(&swapchain, d_ctx);
    uint32_t imageCapacityInput{};
    deserialize(&imageCapacityInput, d_ctx);
    uint32_t* imageCountOutput{};
    deserialize_ptr(&imageCountOutput, d_ctx);
    XrSwapchainImageBaseHeader* images{};
    deserialize_xr_array(&images, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateEnvironmentDepthSwapchainImagesMETA(swapchain, imageCapacityInput, imageCountOutput, images);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(imageCountOutput, 1, s_ctx);
    serialize_xr_array(images, imageCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup(&imageCapacityInput);
    cleanup_ptr(imageCountOutput, 1);
    cleanup_xr_array(images, imageCapacityInput);
}

void FunctionDispatch::handle_xrGetEnvironmentDepthSwapchainStateMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetEnvironmentDepthSwapchainStateMETA", function_loader.pfn_xrGetEnvironmentDepthSwapchainStateMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrEnvironmentDepthSwapchainMETA swapchain{};
    deserialize(&swapchain, d_ctx);
    XrEnvironmentDepthSwapchainStateMETA* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetEnvironmentDepthSwapchainStateMETA(swapchain, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrSetEnvironmentDepthHandRemovalMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetEnvironmentDepthHandRemovalMETA", function_loader.pfn_xrSetEnvironmentDepthHandRemovalMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrEnvironmentDepthProviderMETA environmentDepthProvider{};
    deserialize(&environmentDepthProvider, d_ctx);
    XrEnvironmentDepthHandRemovalSetInfoMETA* setInfo{};
    deserialize_ptr(&setInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetEnvironmentDepthHandRemovalMETA(environmentDepthProvider, setInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&environmentDepthProvider);
    cleanup_ptr(setInfo, 1);
}

void FunctionDispatch::handle_xrStartEnvironmentDepthProviderMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStartEnvironmentDepthProviderMETA", function_loader.pfn_xrStartEnvironmentDepthProviderMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrEnvironmentDepthProviderMETA environmentDepthProvider{};
    deserialize(&environmentDepthProvider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrStartEnvironmentDepthProviderMETA(environmentDepthProvider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&environmentDepthProvider);
}

void FunctionDispatch::handle_xrStopEnvironmentDepthProviderMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStopEnvironmentDepthProviderMETA", function_loader.pfn_xrStopEnvironmentDepthProviderMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrEnvironmentDepthProviderMETA environmentDepthProvider{};
    deserialize(&environmentDepthProvider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrStopEnvironmentDepthProviderMETA(environmentDepthProvider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&environmentDepthProvider);
}

#endif // XRTRANSPORT_EXT_XR_META_environment_depth
#ifdef XRTRANSPORT_EXT_XR_META_foveation_eye_tracked
void FunctionDispatch::handle_xrGetFoveationEyeTrackedStateMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetFoveationEyeTrackedStateMETA", function_loader.pfn_xrGetFoveationEyeTrackedStateMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFoveationEyeTrackedStateMETA* foveationState{};
    deserialize_ptr(&foveationState, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetFoveationEyeTrackedStateMETA(session, foveationState);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(foveationState, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(foveationState, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_foveation_eye_tracked
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_color_lut
void FunctionDispatch::handle_xrCreatePassthroughColorLutMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreatePassthroughColorLutMETA", function_loader.pfn_xrCreatePassthroughColorLutMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPassthroughFB passthrough{};
    deserialize(&passthrough, d_ctx);
    XrPassthroughColorLutCreateInfoMETA* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrPassthroughColorLutMETA* colorLut{};
    deserialize_ptr(&colorLut, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreatePassthroughColorLutMETA(passthrough, createInfo, colorLut);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(colorLut, 1, s_ctx);
    msg_out.flush();

    cleanup(&passthrough);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(colorLut, 1);
}

void FunctionDispatch::handle_xrDestroyPassthroughColorLutMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyPassthroughColorLutMETA", function_loader.pfn_xrDestroyPassthroughColorLutMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPassthroughColorLutMETA colorLut{};
    deserialize(&colorLut, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyPassthroughColorLutMETA(colorLut);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&colorLut);
}

void FunctionDispatch::handle_xrUpdatePassthroughColorLutMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUpdatePassthroughColorLutMETA", function_loader.pfn_xrUpdatePassthroughColorLutMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrPassthroughColorLutMETA colorLut{};
    deserialize(&colorLut, d_ctx);
    XrPassthroughColorLutUpdateInfoMETA* updateInfo{};
    deserialize_ptr(&updateInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrUpdatePassthroughColorLutMETA(colorLut, updateInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&colorLut);
    cleanup_ptr(updateInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_passthrough_color_lut
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_preferences
void FunctionDispatch::handle_xrGetPassthroughPreferencesMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetPassthroughPreferencesMETA", function_loader.pfn_xrGetPassthroughPreferencesMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPassthroughPreferencesMETA* preferences{};
    deserialize_ptr(&preferences, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetPassthroughPreferencesMETA(session, preferences);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(preferences, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(preferences, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_passthrough_preferences
#ifdef XRTRANSPORT_EXT_XR_META_performance_metrics
void FunctionDispatch::handle_xrEnumeratePerformanceMetricsCounterPathsMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumeratePerformanceMetricsCounterPathsMETA", function_loader.pfn_xrEnumeratePerformanceMetricsCounterPathsMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    uint32_t counterPathCapacityInput{};
    deserialize(&counterPathCapacityInput, d_ctx);
    uint32_t* counterPathCountOutput{};
    deserialize_ptr(&counterPathCountOutput, d_ctx);
    XrPath* counterPaths{};
    deserialize_ptr(&counterPaths, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumeratePerformanceMetricsCounterPathsMETA(instance, counterPathCapacityInput, counterPathCountOutput, counterPaths);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(counterPathCountOutput, 1, s_ctx);
    serialize_ptr(counterPaths, counterPathCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&counterPathCapacityInput);
    cleanup_ptr(counterPathCountOutput, 1);
    cleanup_ptr(counterPaths, counterPathCapacityInput);
}

void FunctionDispatch::handle_xrGetPerformanceMetricsStateMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetPerformanceMetricsStateMETA", function_loader.pfn_xrGetPerformanceMetricsStateMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPerformanceMetricsStateMETA* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetPerformanceMetricsStateMETA(session, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrQueryPerformanceMetricsCounterMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQueryPerformanceMetricsCounterMETA", function_loader.pfn_xrQueryPerformanceMetricsCounterMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath counterPath{};
    deserialize(&counterPath, d_ctx);
    XrPerformanceMetricsCounterMETA* counter{};
    deserialize_ptr(&counter, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrQueryPerformanceMetricsCounterMETA(session, counterPath, counter);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(counter, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&counterPath);
    cleanup_ptr(counter, 1);
}

void FunctionDispatch::handle_xrSetPerformanceMetricsStateMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetPerformanceMetricsStateMETA", function_loader.pfn_xrSetPerformanceMetricsStateMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPerformanceMetricsStateMETA* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetPerformanceMetricsStateMETA(session, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(state, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_performance_metrics
#ifdef XRTRANSPORT_EXT_XR_META_recommended_layer_resolution
void FunctionDispatch::handle_xrGetRecommendedLayerResolutionMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetRecommendedLayerResolutionMETA", function_loader.pfn_xrGetRecommendedLayerResolutionMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrRecommendedLayerResolutionGetInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrRecommendedLayerResolutionMETA* resolution{};
    deserialize_ptr(&resolution, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetRecommendedLayerResolutionMETA(session, info, resolution);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(resolution, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(resolution, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_recommended_layer_resolution
#ifdef XRTRANSPORT_EXT_XR_META_simultaneous_hands_and_controllers
void FunctionDispatch::handle_xrPauseSimultaneousHandsAndControllersTrackingMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPauseSimultaneousHandsAndControllersTrackingMETA", function_loader.pfn_xrPauseSimultaneousHandsAndControllersTrackingMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSimultaneousHandsAndControllersTrackingPauseInfoMETA* pauseInfo{};
    deserialize_ptr(&pauseInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPauseSimultaneousHandsAndControllersTrackingMETA(session, pauseInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(pauseInfo, 1);
}

void FunctionDispatch::handle_xrResumeSimultaneousHandsAndControllersTrackingMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrResumeSimultaneousHandsAndControllersTrackingMETA", function_loader.pfn_xrResumeSimultaneousHandsAndControllersTrackingMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSimultaneousHandsAndControllersTrackingResumeInfoMETA* resumeInfo{};
    deserialize_ptr(&resumeInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrResumeSimultaneousHandsAndControllersTrackingMETA(session, resumeInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(resumeInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_simultaneous_hands_and_controllers
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_mesh
void FunctionDispatch::handle_xrGetSpaceTriangleMeshMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceTriangleMeshMETA", function_loader.pfn_xrGetSpaceTriangleMeshMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrSpaceTriangleMeshGetInfoMETA* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrSpaceTriangleMeshMETA* triangleMeshOutput{};
    deserialize_ptr(&triangleMeshOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpaceTriangleMeshMETA(space, getInfo, triangleMeshOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(triangleMeshOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&space);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(triangleMeshOutput, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_mesh
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_sharing
void FunctionDispatch::handle_xrShareSpacesMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrShareSpacesMETA", function_loader.pfn_xrShareSpacesMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrShareSpacesInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrShareSpacesMETA(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(info->spaces, info->spaceCount, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_sharing
#ifdef XRTRANSPORT_EXT_XR_META_virtual_keyboard
void FunctionDispatch::handle_xrChangeVirtualKeyboardTextContextMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrChangeVirtualKeyboardTextContextMETA", function_loader.pfn_xrChangeVirtualKeyboardTextContextMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    XrVirtualKeyboardTextContextChangeInfoMETA* changeInfo{};
    deserialize_ptr(&changeInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrChangeVirtualKeyboardTextContextMETA(keyboard, changeInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup_ptr(changeInfo, 1);
}

void FunctionDispatch::handle_xrCreateVirtualKeyboardMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateVirtualKeyboardMETA", function_loader.pfn_xrCreateVirtualKeyboardMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrVirtualKeyboardCreateInfoMETA* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrVirtualKeyboardMETA* keyboard{};
    deserialize_ptr(&keyboard, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateVirtualKeyboardMETA(session, createInfo, keyboard);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(keyboard, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(keyboard, 1);
}

void FunctionDispatch::handle_xrCreateVirtualKeyboardSpaceMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateVirtualKeyboardSpaceMETA", function_loader.pfn_xrCreateVirtualKeyboardSpaceMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    XrVirtualKeyboardSpaceCreateInfoMETA* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* keyboardSpace{};
    deserialize_ptr(&keyboardSpace, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateVirtualKeyboardSpaceMETA(session, keyboard, createInfo, keyboardSpace);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(keyboardSpace, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&keyboard);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(keyboardSpace, 1);
}

void FunctionDispatch::handle_xrDestroyVirtualKeyboardMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyVirtualKeyboardMETA", function_loader.pfn_xrDestroyVirtualKeyboardMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyVirtualKeyboardMETA(keyboard);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
}

void FunctionDispatch::handle_xrGetVirtualKeyboardDirtyTexturesMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVirtualKeyboardDirtyTexturesMETA", function_loader.pfn_xrGetVirtualKeyboardDirtyTexturesMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    uint32_t textureIdCapacityInput{};
    deserialize(&textureIdCapacityInput, d_ctx);
    uint32_t* textureIdCountOutput{};
    deserialize_ptr(&textureIdCountOutput, d_ctx);
    uint64_t* textureIds{};
    deserialize_ptr(&textureIds, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetVirtualKeyboardDirtyTexturesMETA(keyboard, textureIdCapacityInput, textureIdCountOutput, textureIds);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(textureIdCountOutput, 1, s_ctx);
    serialize_ptr(textureIds, textureIdCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup(&textureIdCapacityInput);
    cleanup_ptr(textureIdCountOutput, 1);
    cleanup_ptr(textureIds, textureIdCapacityInput);
}

void FunctionDispatch::handle_xrGetVirtualKeyboardModelAnimationStatesMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVirtualKeyboardModelAnimationStatesMETA", function_loader.pfn_xrGetVirtualKeyboardModelAnimationStatesMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    XrVirtualKeyboardModelAnimationStatesMETA* animationStates{};
    deserialize_ptr(&animationStates, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetVirtualKeyboardModelAnimationStatesMETA(keyboard, animationStates);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(animationStates, 1, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup_ptr(animationStates, 1);
}

void FunctionDispatch::handle_xrGetVirtualKeyboardScaleMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVirtualKeyboardScaleMETA", function_loader.pfn_xrGetVirtualKeyboardScaleMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    float* scale{};
    deserialize_ptr(&scale, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetVirtualKeyboardScaleMETA(keyboard, scale);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(scale, 1, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup_ptr(scale, 1);
}

void FunctionDispatch::handle_xrGetVirtualKeyboardTextureDataMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVirtualKeyboardTextureDataMETA", function_loader.pfn_xrGetVirtualKeyboardTextureDataMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    uint64_t textureId{};
    deserialize(&textureId, d_ctx);
    XrVirtualKeyboardTextureDataMETA* textureData{};
    deserialize_ptr(&textureData, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetVirtualKeyboardTextureDataMETA(keyboard, textureId, textureData);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(textureData, 1, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup(&textureId);
    cleanup_ptr(textureData, 1);
}

void FunctionDispatch::handle_xrSendVirtualKeyboardInputMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSendVirtualKeyboardInputMETA", function_loader.pfn_xrSendVirtualKeyboardInputMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    XrVirtualKeyboardInputInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrPosef* interactorRootPose{};
    deserialize_ptr(&interactorRootPose, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSendVirtualKeyboardInputMETA(keyboard, info, interactorRootPose);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(interactorRootPose, 1, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup_ptr(info, 1);
    cleanup_ptr(interactorRootPose, 1);
}

void FunctionDispatch::handle_xrSetVirtualKeyboardModelVisibilityMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetVirtualKeyboardModelVisibilityMETA", function_loader.pfn_xrSetVirtualKeyboardModelVisibilityMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    XrVirtualKeyboardModelVisibilitySetInfoMETA* modelVisibility{};
    deserialize_ptr(&modelVisibility, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetVirtualKeyboardModelVisibilityMETA(keyboard, modelVisibility);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup_ptr(modelVisibility, 1);
}

void FunctionDispatch::handle_xrSuggestVirtualKeyboardLocationMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSuggestVirtualKeyboardLocationMETA", function_loader.pfn_xrSuggestVirtualKeyboardLocationMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    XrVirtualKeyboardLocationInfoMETA* locationInfo{};
    deserialize_ptr(&locationInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSuggestVirtualKeyboardLocationMETA(keyboard, locationInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup_ptr(locationInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_virtual_keyboard
#ifdef XRTRANSPORT_EXT_XR_ML_compat
void FunctionDispatch::handle_xrCreateSpaceFromCoordinateFrameUIDML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpaceFromCoordinateFrameUIDML", function_loader.pfn_xrCreateSpaceFromCoordinateFrameUIDML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrCoordinateSpaceCreateInfoML* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpaceFromCoordinateFrameUIDML(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_compat
#ifdef XRTRANSPORT_EXT_XR_ML_facial_expression
void FunctionDispatch::handle_xrCreateFacialExpressionClientML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateFacialExpressionClientML", function_loader.pfn_xrCreateFacialExpressionClientML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFacialExpressionClientCreateInfoML* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrFacialExpressionClientML* facialExpressionClient{};
    deserialize_ptr(&facialExpressionClient, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateFacialExpressionClientML(session, createInfo, facialExpressionClient);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(facialExpressionClient, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(facialExpressionClient, 1);
}

void FunctionDispatch::handle_xrDestroyFacialExpressionClientML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyFacialExpressionClientML", function_loader.pfn_xrDestroyFacialExpressionClientML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrFacialExpressionClientML facialExpressionClient{};
    deserialize(&facialExpressionClient, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyFacialExpressionClientML(facialExpressionClient);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&facialExpressionClient);
}

void FunctionDispatch::handle_xrGetFacialExpressionBlendShapePropertiesML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetFacialExpressionBlendShapePropertiesML", function_loader.pfn_xrGetFacialExpressionBlendShapePropertiesML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrFacialExpressionClientML facialExpressionClient{};
    deserialize(&facialExpressionClient, d_ctx);
    XrFacialExpressionBlendShapeGetInfoML* blendShapeGetInfo{};
    deserialize_ptr(&blendShapeGetInfo, d_ctx);
    uint32_t blendShapeCount{};
    deserialize(&blendShapeCount, d_ctx);
    XrFacialExpressionBlendShapePropertiesML* blendShapes{};
    deserialize_ptr(&blendShapes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetFacialExpressionBlendShapePropertiesML(facialExpressionClient, blendShapeGetInfo, blendShapeCount, blendShapes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(blendShapes, blendShapeCount, s_ctx);
    msg_out.flush();

    cleanup(&facialExpressionClient);
    cleanup_ptr(blendShapeGetInfo, 1);
    cleanup(&blendShapeCount);
    cleanup_ptr(blendShapes, blendShapeCount);
}

#endif // XRTRANSPORT_EXT_XR_ML_facial_expression
#ifdef XRTRANSPORT_EXT_XR_ML_localization_map
void FunctionDispatch::handle_xrCreateExportedLocalizationMapML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateExportedLocalizationMapML", function_loader.pfn_xrCreateExportedLocalizationMapML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrUuidEXT* mapUuid{};
    deserialize_ptr(&mapUuid, d_ctx);
    XrExportedLocalizationMapML* map{};
    deserialize_ptr(&map, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateExportedLocalizationMapML(session, mapUuid, map);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(map, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(mapUuid, 1);
    cleanup_ptr(map, 1);
}

void FunctionDispatch::handle_xrDestroyExportedLocalizationMapML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyExportedLocalizationMapML", function_loader.pfn_xrDestroyExportedLocalizationMapML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrExportedLocalizationMapML map{};
    deserialize(&map, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyExportedLocalizationMapML(map);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&map);
}

void FunctionDispatch::handle_xrEnableLocalizationEventsML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnableLocalizationEventsML", function_loader.pfn_xrEnableLocalizationEventsML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrLocalizationEnableEventsInfoML* info{};
    deserialize_ptr(&info, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnableLocalizationEventsML(session, info);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
}

void FunctionDispatch::handle_xrGetExportedLocalizationMapDataML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetExportedLocalizationMapDataML", function_loader.pfn_xrGetExportedLocalizationMapDataML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrExportedLocalizationMapML map{};
    deserialize(&map, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetExportedLocalizationMapDataML(map, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&map);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

void FunctionDispatch::handle_xrImportLocalizationMapML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrImportLocalizationMapML", function_loader.pfn_xrImportLocalizationMapML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrLocalizationMapImportInfoML* importInfo{};
    deserialize_ptr(&importInfo, d_ctx);
    XrUuidEXT* mapUuid{};
    deserialize_ptr(&mapUuid, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrImportLocalizationMapML(session, importInfo, mapUuid);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(importInfo->data, importInfo->size, s_ctx);
    serialize_ptr(mapUuid, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(importInfo, 1);
    cleanup_ptr(mapUuid, 1);
}

void FunctionDispatch::handle_xrQueryLocalizationMapsML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQueryLocalizationMapsML", function_loader.pfn_xrQueryLocalizationMapsML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrLocalizationMapQueryInfoBaseHeaderML* queryInfo{};
    deserialize_xr(&queryInfo, d_ctx);
    uint32_t mapCapacityInput{};
    deserialize(&mapCapacityInput, d_ctx);
    uint32_t* mapCountOutput{};
    deserialize_ptr(&mapCountOutput, d_ctx);
    XrLocalizationMapML* maps{};
    deserialize_ptr(&maps, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrQueryLocalizationMapsML(session, queryInfo, mapCapacityInput, mapCountOutput, maps);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(mapCountOutput, 1, s_ctx);
    serialize_ptr(maps, mapCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_xr(queryInfo);
    cleanup(&mapCapacityInput);
    cleanup_ptr(mapCountOutput, 1);
    cleanup_ptr(maps, mapCapacityInput);
}

void FunctionDispatch::handle_xrRequestMapLocalizationML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestMapLocalizationML", function_loader.pfn_xrRequestMapLocalizationML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrMapLocalizationRequestInfoML* requestInfo{};
    deserialize_ptr(&requestInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrRequestMapLocalizationML(session, requestInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(requestInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_localization_map
#ifdef XRTRANSPORT_EXT_XR_ML_marker_understanding
void FunctionDispatch::handle_xrCreateMarkerDetectorML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateMarkerDetectorML", function_loader.pfn_xrCreateMarkerDetectorML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrMarkerDetectorCreateInfoML* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrMarkerDetectorML* markerDetector{};
    deserialize_ptr(&markerDetector, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateMarkerDetectorML(session, createInfo, markerDetector);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(markerDetector, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(markerDetector, 1);
}

void FunctionDispatch::handle_xrCreateMarkerSpaceML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateMarkerSpaceML", function_loader.pfn_xrCreateMarkerSpaceML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrMarkerSpaceCreateInfoML* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateMarkerSpaceML(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrDestroyMarkerDetectorML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyMarkerDetectorML", function_loader.pfn_xrDestroyMarkerDetectorML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyMarkerDetectorML(markerDetector);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
}

void FunctionDispatch::handle_xrGetMarkerDetectorStateML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkerDetectorStateML", function_loader.pfn_xrGetMarkerDetectorStateML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    XrMarkerDetectorStateML* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetMarkerDetectorStateML(markerDetector, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetMarkerLengthML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkerLengthML", function_loader.pfn_xrGetMarkerLengthML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    XrMarkerML marker{};
    deserialize(&marker, d_ctx);
    float* meters{};
    deserialize_ptr(&meters, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetMarkerLengthML(markerDetector, marker, meters);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(meters, 1, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup(&marker);
    cleanup_ptr(meters, 1);
}

void FunctionDispatch::handle_xrGetMarkerNumberML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkerNumberML", function_loader.pfn_xrGetMarkerNumberML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    XrMarkerML marker{};
    deserialize(&marker, d_ctx);
    uint64_t* number{};
    deserialize_ptr(&number, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetMarkerNumberML(markerDetector, marker, number);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(number, 1, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup(&marker);
    cleanup_ptr(number, 1);
}

void FunctionDispatch::handle_xrGetMarkerReprojectionErrorML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkerReprojectionErrorML", function_loader.pfn_xrGetMarkerReprojectionErrorML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    XrMarkerML marker{};
    deserialize(&marker, d_ctx);
    float* reprojectionErrorMeters{};
    deserialize_ptr(&reprojectionErrorMeters, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetMarkerReprojectionErrorML(markerDetector, marker, reprojectionErrorMeters);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(reprojectionErrorMeters, 1, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup(&marker);
    cleanup_ptr(reprojectionErrorMeters, 1);
}

void FunctionDispatch::handle_xrGetMarkerStringML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkerStringML", function_loader.pfn_xrGetMarkerStringML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    XrMarkerML marker{};
    deserialize(&marker, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetMarkerStringML(markerDetector, marker, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup(&marker);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

void FunctionDispatch::handle_xrGetMarkersML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkersML", function_loader.pfn_xrGetMarkersML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    uint32_t markerCapacityInput{};
    deserialize(&markerCapacityInput, d_ctx);
    uint32_t* markerCountOutput{};
    deserialize_ptr(&markerCountOutput, d_ctx);
    XrMarkerML* markers{};
    deserialize_ptr(&markers, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetMarkersML(markerDetector, markerCapacityInput, markerCountOutput, markers);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(markerCountOutput, 1, s_ctx);
    serialize_ptr(markers, markerCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup(&markerCapacityInput);
    cleanup_ptr(markerCountOutput, 1);
    cleanup_ptr(markers, markerCapacityInput);
}

void FunctionDispatch::handle_xrSnapshotMarkerDetectorML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSnapshotMarkerDetectorML", function_loader.pfn_xrSnapshotMarkerDetectorML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    XrMarkerDetectorSnapshotInfoML* snapshotInfo{};
    deserialize_ptr(&snapshotInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSnapshotMarkerDetectorML(markerDetector, snapshotInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(snapshotInfo, 1, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup_ptr(snapshotInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_marker_understanding
#ifdef XRTRANSPORT_EXT_XR_ML_spatial_anchors
void FunctionDispatch::handle_xrCreateSpatialAnchorsAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorsAsyncML", function_loader.pfn_xrCreateSpatialAnchorsAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorsCreateInfoBaseHeaderML* createInfo{};
    deserialize_xr(&createInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorsAsyncML(session, createInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_xr(createInfo);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrCreateSpatialAnchorsCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorsCompleteML", function_loader.pfn_xrCreateSpatialAnchorsCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrCreateSpatialAnchorsCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorsCompleteML(session, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrGetSpatialAnchorStateML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpatialAnchorStateML", function_loader.pfn_xrGetSpatialAnchorStateML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpace anchor{};
    deserialize(&anchor, d_ctx);
    XrSpatialAnchorStateML* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpatialAnchorStateML(anchor, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&anchor);
    cleanup_ptr(state, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_spatial_anchors
#ifdef XRTRANSPORT_EXT_XR_ML_spatial_anchors_storage
void FunctionDispatch::handle_xrCreateSpatialAnchorsStorageML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorsStorageML", function_loader.pfn_xrCreateSpatialAnchorsStorageML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorsCreateStorageInfoML* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpatialAnchorsStorageML* storage{};
    deserialize_ptr(&storage, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorsStorageML(session, createInfo, storage);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(storage, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(storage, 1);
}

void FunctionDispatch::handle_xrDeleteSpatialAnchorsAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDeleteSpatialAnchorsAsyncML", function_loader.pfn_xrDeleteSpatialAnchorsAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrSpatialAnchorsDeleteInfoML* deleteInfo{};
    deserialize_ptr(&deleteInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDeleteSpatialAnchorsAsyncML(storage, deleteInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup_ptr(deleteInfo, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrDeleteSpatialAnchorsCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDeleteSpatialAnchorsCompleteML", function_loader.pfn_xrDeleteSpatialAnchorsCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrSpatialAnchorsDeleteCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDeleteSpatialAnchorsCompleteML(storage, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrDestroySpatialAnchorsStorageML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySpatialAnchorsStorageML", function_loader.pfn_xrDestroySpatialAnchorsStorageML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroySpatialAnchorsStorageML(storage);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&storage);
}

void FunctionDispatch::handle_xrPublishSpatialAnchorsAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPublishSpatialAnchorsAsyncML", function_loader.pfn_xrPublishSpatialAnchorsAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrSpatialAnchorsPublishInfoML* publishInfo{};
    deserialize_ptr(&publishInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPublishSpatialAnchorsAsyncML(storage, publishInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup_ptr(publishInfo, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrPublishSpatialAnchorsCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPublishSpatialAnchorsCompleteML", function_loader.pfn_xrPublishSpatialAnchorsCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrSpatialAnchorsPublishCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPublishSpatialAnchorsCompleteML(storage, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrQuerySpatialAnchorsAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQuerySpatialAnchorsAsyncML", function_loader.pfn_xrQuerySpatialAnchorsAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrSpatialAnchorsQueryInfoBaseHeaderML* queryInfo{};
    deserialize_xr(&queryInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrQuerySpatialAnchorsAsyncML(storage, queryInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup_xr(queryInfo);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrQuerySpatialAnchorsCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQuerySpatialAnchorsCompleteML", function_loader.pfn_xrQuerySpatialAnchorsCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrSpatialAnchorsQueryCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrQuerySpatialAnchorsCompleteML(storage, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrUpdateSpatialAnchorsExpirationAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUpdateSpatialAnchorsExpirationAsyncML", function_loader.pfn_xrUpdateSpatialAnchorsExpirationAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrSpatialAnchorsUpdateExpirationInfoML* updateInfo{};
    deserialize_ptr(&updateInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrUpdateSpatialAnchorsExpirationAsyncML(storage, updateInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup_ptr(updateInfo, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrUpdateSpatialAnchorsExpirationCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUpdateSpatialAnchorsExpirationCompleteML", function_loader.pfn_xrUpdateSpatialAnchorsExpirationCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrSpatialAnchorsUpdateExpirationCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrUpdateSpatialAnchorsExpirationCompleteML(storage, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_spatial_anchors_storage
#ifdef XRTRANSPORT_EXT_XR_ML_system_notifications
void FunctionDispatch::handle_xrSetSystemNotificationsML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetSystemNotificationsML", function_loader.pfn_xrSetSystemNotificationsML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemNotificationsSetInfoML* info{};
    deserialize_ptr(&info, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetSystemNotificationsML(instance, info);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(info, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_system_notifications
#ifdef XRTRANSPORT_EXT_XR_ML_user_calibration
void FunctionDispatch::handle_xrEnableUserCalibrationEventsML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnableUserCalibrationEventsML", function_loader.pfn_xrEnableUserCalibrationEventsML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrUserCalibrationEnableEventsInfoML* enableInfo{};
    deserialize_ptr(&enableInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnableUserCalibrationEventsML(instance, enableInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(enableInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_user_calibration
#ifdef XRTRANSPORT_EXT_XR_ML_world_mesh_detection
void FunctionDispatch::handle_xrAllocateWorldMeshBufferML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrAllocateWorldMeshBufferML", function_loader.pfn_xrAllocateWorldMeshBufferML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrWorldMeshBufferSizeML* size{};
    deserialize_ptr(&size, d_ctx);
    XrWorldMeshBufferML* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrAllocateWorldMeshBufferML(detector, size, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(size->next, s_ctx);
    serialize_ptr(buffer, 1, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup_ptr(size, 1);
    cleanup_ptr(buffer, 1);
}

void FunctionDispatch::handle_xrCreateWorldMeshDetectorML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateWorldMeshDetectorML", function_loader.pfn_xrCreateWorldMeshDetectorML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrWorldMeshDetectorCreateInfoML* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrWorldMeshDetectorML* detector{};
    deserialize_ptr(&detector, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateWorldMeshDetectorML(session, createInfo, detector);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(detector, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(detector, 1);
}

void FunctionDispatch::handle_xrDestroyWorldMeshDetectorML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyWorldMeshDetectorML", function_loader.pfn_xrDestroyWorldMeshDetectorML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyWorldMeshDetectorML(detector);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&detector);
}

void FunctionDispatch::handle_xrFreeWorldMeshBufferML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrFreeWorldMeshBufferML", function_loader.pfn_xrFreeWorldMeshBufferML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrWorldMeshBufferML* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrFreeWorldMeshBufferML(detector, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(buffer->next, s_ctx);
    serialize_ptr(buffer->buffer, buffer->bufferSize, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup_ptr(buffer, 1);
}

void FunctionDispatch::handle_xrGetWorldMeshBufferRecommendSizeML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetWorldMeshBufferRecommendSizeML", function_loader.pfn_xrGetWorldMeshBufferRecommendSizeML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrWorldMeshBufferRecommendedSizeInfoML* sizeInfo{};
    deserialize_ptr(&sizeInfo, d_ctx);
    XrWorldMeshBufferSizeML* size{};
    deserialize_ptr(&size, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetWorldMeshBufferRecommendSizeML(detector, sizeInfo, size);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(size, 1, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup_ptr(sizeInfo, 1);
    cleanup_ptr(size, 1);
}

void FunctionDispatch::handle_xrRequestWorldMeshAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestWorldMeshAsyncML", function_loader.pfn_xrRequestWorldMeshAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrWorldMeshGetInfoML* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrWorldMeshBufferML* buffer{};
    deserialize_ptr(&buffer, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrRequestWorldMeshAsyncML(detector, getInfo, buffer, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(getInfo->blocks, getInfo->blockCount, s_ctx);
    serialize_ptr(buffer, 1, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(buffer, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrRequestWorldMeshCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestWorldMeshCompleteML", function_loader.pfn_xrRequestWorldMeshCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrWorldMeshRequestCompletionInfoML* completionInfo{};
    deserialize_ptr(&completionInfo, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrWorldMeshRequestCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrRequestWorldMeshCompleteML(detector, completionInfo, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup_ptr(completionInfo, 1);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrRequestWorldMeshStateAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestWorldMeshStateAsyncML", function_loader.pfn_xrRequestWorldMeshStateAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrWorldMeshStateRequestInfoML* stateRequest{};
    deserialize_ptr(&stateRequest, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrRequestWorldMeshStateAsyncML(detector, stateRequest, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup_ptr(stateRequest, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrRequestWorldMeshStateCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestWorldMeshStateCompleteML", function_loader.pfn_xrRequestWorldMeshStateCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrWorldMeshStateRequestCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrRequestWorldMeshStateCompleteML(detector, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_world_mesh_detection
#ifdef XRTRANSPORT_EXT_XR_MNDX_force_feedback_curl
void FunctionDispatch::handle_xrApplyForceFeedbackCurlMNDX(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrApplyForceFeedbackCurlMNDX", function_loader.pfn_xrApplyForceFeedbackCurlMNDX);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrHandTrackerEXT handTracker{};
    deserialize(&handTracker, d_ctx);
    XrForceFeedbackCurlApplyLocationsMNDX* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrApplyForceFeedbackCurlMNDX(handTracker, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations->locations, locations->locationCount, s_ctx);
    msg_out.flush();

    cleanup(&handTracker);
    cleanup_ptr(locations, 1);
}

#endif // XRTRANSPORT_EXT_XR_MNDX_force_feedback_curl
#ifdef XRTRANSPORT_EXT_XR_MSFT_composition_layer_reprojection
void FunctionDispatch::handle_xrEnumerateReprojectionModesMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateReprojectionModesMSFT", function_loader.pfn_xrEnumerateReprojectionModesMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrViewConfigurationType viewConfigurationType{};
    deserialize(&viewConfigurationType, d_ctx);
    uint32_t modeCapacityInput{};
    deserialize(&modeCapacityInput, d_ctx);
    uint32_t* modeCountOutput{};
    deserialize_ptr(&modeCountOutput, d_ctx);
    XrReprojectionModeMSFT* modes{};
    deserialize_ptr(&modes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateReprojectionModesMSFT(instance, systemId, viewConfigurationType, modeCapacityInput, modeCountOutput, modes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(modeCountOutput, 1, s_ctx);
    serialize_ptr(modes, modeCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&viewConfigurationType);
    cleanup(&modeCapacityInput);
    cleanup_ptr(modeCountOutput, 1);
    cleanup_ptr(modes, modeCapacityInput);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_composition_layer_reprojection
#ifdef XRTRANSPORT_EXT_XR_MSFT_controller_model
void FunctionDispatch::handle_xrGetControllerModelKeyMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetControllerModelKeyMSFT", function_loader.pfn_xrGetControllerModelKeyMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath topLevelUserPath{};
    deserialize(&topLevelUserPath, d_ctx);
    XrControllerModelKeyStateMSFT* controllerModelKeyState{};
    deserialize_ptr(&controllerModelKeyState, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetControllerModelKeyMSFT(session, topLevelUserPath, controllerModelKeyState);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(controllerModelKeyState, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&topLevelUserPath);
    cleanup_ptr(controllerModelKeyState, 1);
}

void FunctionDispatch::handle_xrGetControllerModelPropertiesMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetControllerModelPropertiesMSFT", function_loader.pfn_xrGetControllerModelPropertiesMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrControllerModelKeyMSFT modelKey{};
    deserialize(&modelKey, d_ctx);
    XrControllerModelPropertiesMSFT* properties{};
    deserialize_ptr(&properties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetControllerModelPropertiesMSFT(session, modelKey, properties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(properties, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&modelKey);
    cleanup_ptr(properties, 1);
}

void FunctionDispatch::handle_xrGetControllerModelStateMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetControllerModelStateMSFT", function_loader.pfn_xrGetControllerModelStateMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrControllerModelKeyMSFT modelKey{};
    deserialize(&modelKey, d_ctx);
    XrControllerModelStateMSFT* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetControllerModelStateMSFT(session, modelKey, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&modelKey);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrLoadControllerModelMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLoadControllerModelMSFT", function_loader.pfn_xrLoadControllerModelMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrControllerModelKeyMSFT modelKey{};
    deserialize(&modelKey, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    uint8_t* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrLoadControllerModelMSFT(session, modelKey, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&modelKey);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_controller_model
#ifdef XRTRANSPORT_EXT_XR_MSFT_hand_tracking_mesh
void FunctionDispatch::handle_xrCreateHandMeshSpaceMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateHandMeshSpaceMSFT", function_loader.pfn_xrCreateHandMeshSpaceMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrHandTrackerEXT handTracker{};
    deserialize(&handTracker, d_ctx);
    XrHandMeshSpaceCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateHandMeshSpaceMSFT(handTracker, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&handTracker);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrUpdateHandMeshMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUpdateHandMeshMSFT", function_loader.pfn_xrUpdateHandMeshMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrHandTrackerEXT handTracker{};
    deserialize(&handTracker, d_ctx);
    XrHandMeshUpdateInfoMSFT* updateInfo{};
    deserialize_ptr(&updateInfo, d_ctx);
    XrHandMeshMSFT* handMesh{};
    deserialize_ptr(&handMesh, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrUpdateHandMeshMSFT(handTracker, updateInfo, handMesh);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(handMesh, 1, s_ctx);
    msg_out.flush();

    cleanup(&handTracker);
    cleanup_ptr(updateInfo, 1);
    cleanup_ptr(handMesh, 1);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_hand_tracking_mesh
#ifdef XRTRANSPORT_EXT_XR_MSFT_perception_anchor_interop
void FunctionDispatch::handle_xrCreateSpatialAnchorFromPerceptionAnchorMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorFromPerceptionAnchorMSFT", function_loader.pfn_xrCreateSpatialAnchorFromPerceptionAnchorMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    IUnknown* perceptionAnchor{};
    deserialize_ptr(&perceptionAnchor, d_ctx);
    XrSpatialAnchorMSFT* anchor{};
    deserialize_ptr(&anchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorFromPerceptionAnchorMSFT(session, perceptionAnchor, anchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(perceptionAnchor, 1, s_ctx);
    serialize_ptr(anchor, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(perceptionAnchor, 1);
    cleanup_ptr(anchor, 1);
}

void FunctionDispatch::handle_xrTryGetPerceptionAnchorFromSpatialAnchorMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTryGetPerceptionAnchorFromSpatialAnchorMSFT", function_loader.pfn_xrTryGetPerceptionAnchorFromSpatialAnchorMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorMSFT anchor{};
    deserialize(&anchor, d_ctx);
    IUnknown** perceptionAnchor{};
    #error "auto-generator doesn't support double pointers (perceptionAnchor)"None

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrTryGetPerceptionAnchorFromSpatialAnchorMSFT(session, anchor, perceptionAnchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(perceptionAnchor, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&anchor);
    #error "auto-generator doesn't support double pointers (perceptionAnchor)"None
}

#endif // XRTRANSPORT_EXT_XR_MSFT_perception_anchor_interop
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_marker
void FunctionDispatch::handle_xrGetSceneMarkerDecodedStringMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSceneMarkerDecodedStringMSFT", function_loader.pfn_xrGetSceneMarkerDecodedStringMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);
    XrUuidMSFT* markerId{};
    deserialize_ptr(&markerId, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSceneMarkerDecodedStringMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&scene);
    cleanup_ptr(markerId, 1);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

void FunctionDispatch::handle_xrGetSceneMarkerRawDataMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSceneMarkerRawDataMSFT", function_loader.pfn_xrGetSceneMarkerRawDataMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);
    XrUuidMSFT* markerId{};
    deserialize_ptr(&markerId, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    uint8_t* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSceneMarkerRawDataMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&scene);
    cleanup_ptr(markerId, 1);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_scene_marker
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_understanding
void FunctionDispatch::handle_xrComputeNewSceneMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrComputeNewSceneMSFT", function_loader.pfn_xrComputeNewSceneMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSceneObserverMSFT sceneObserver{};
    deserialize(&sceneObserver, d_ctx);
    XrNewSceneComputeInfoMSFT* computeInfo{};
    deserialize_ptr(&computeInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrComputeNewSceneMSFT(sceneObserver, computeInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&sceneObserver);
    cleanup_ptr(computeInfo, 1);
}

void FunctionDispatch::handle_xrCreateSceneMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSceneMSFT", function_loader.pfn_xrCreateSceneMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSceneObserverMSFT sceneObserver{};
    deserialize(&sceneObserver, d_ctx);
    XrSceneCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSceneMSFT* scene{};
    deserialize_ptr(&scene, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSceneMSFT(sceneObserver, createInfo, scene);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(scene, 1, s_ctx);
    msg_out.flush();

    cleanup(&sceneObserver);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(scene, 1);
}

void FunctionDispatch::handle_xrCreateSceneObserverMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSceneObserverMSFT", function_loader.pfn_xrCreateSceneObserverMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSceneObserverCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSceneObserverMSFT* sceneObserver{};
    deserialize_ptr(&sceneObserver, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSceneObserverMSFT(session, createInfo, sceneObserver);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(sceneObserver, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(sceneObserver, 1);
}

void FunctionDispatch::handle_xrDestroySceneMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySceneMSFT", function_loader.pfn_xrDestroySceneMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroySceneMSFT(scene);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&scene);
}

void FunctionDispatch::handle_xrDestroySceneObserverMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySceneObserverMSFT", function_loader.pfn_xrDestroySceneObserverMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSceneObserverMSFT sceneObserver{};
    deserialize(&sceneObserver, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroySceneObserverMSFT(sceneObserver);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&sceneObserver);
}

void FunctionDispatch::handle_xrEnumerateSceneComputeFeaturesMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateSceneComputeFeaturesMSFT", function_loader.pfn_xrEnumerateSceneComputeFeaturesMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    uint32_t featureCapacityInput{};
    deserialize(&featureCapacityInput, d_ctx);
    uint32_t* featureCountOutput{};
    deserialize_ptr(&featureCountOutput, d_ctx);
    XrSceneComputeFeatureMSFT* features{};
    deserialize_ptr(&features, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateSceneComputeFeaturesMSFT(instance, systemId, featureCapacityInput, featureCountOutput, features);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(featureCountOutput, 1, s_ctx);
    serialize_ptr(features, featureCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&featureCapacityInput);
    cleanup_ptr(featureCountOutput, 1);
    cleanup_ptr(features, featureCapacityInput);
}

void FunctionDispatch::handle_xrGetSceneComponentsMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSceneComponentsMSFT", function_loader.pfn_xrGetSceneComponentsMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);
    XrSceneComponentsGetInfoMSFT* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrSceneComponentsMSFT* components{};
    deserialize_ptr(&components, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSceneComponentsMSFT(scene, getInfo, components);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(components, 1, s_ctx);
    msg_out.flush();

    cleanup(&scene);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(components, 1);
}

void FunctionDispatch::handle_xrGetSceneComputeStateMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSceneComputeStateMSFT", function_loader.pfn_xrGetSceneComputeStateMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSceneObserverMSFT sceneObserver{};
    deserialize(&sceneObserver, d_ctx);
    XrSceneComputeStateMSFT* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSceneComputeStateMSFT(sceneObserver, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&sceneObserver);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetSceneMeshBuffersMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSceneMeshBuffersMSFT", function_loader.pfn_xrGetSceneMeshBuffersMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);
    XrSceneMeshBuffersGetInfoMSFT* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrSceneMeshBuffersMSFT* buffers{};
    deserialize_ptr(&buffers, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSceneMeshBuffersMSFT(scene, getInfo, buffers);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(buffers, 1, s_ctx);
    msg_out.flush();

    cleanup(&scene);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(buffers, 1);
}

void FunctionDispatch::handle_xrLocateSceneComponentsMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateSceneComponentsMSFT", function_loader.pfn_xrLocateSceneComponentsMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);
    XrSceneComponentsLocateInfoMSFT* locateInfo{};
    deserialize_ptr(&locateInfo, d_ctx);
    XrSceneComponentLocationsMSFT* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrLocateSceneComponentsMSFT(scene, locateInfo, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations, 1, s_ctx);
    msg_out.flush();

    cleanup(&scene);
    cleanup_ptr(locateInfo, 1);
    cleanup_ptr(locations, 1);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_scene_understanding
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_understanding_serialization
void FunctionDispatch::handle_xrDeserializeSceneMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDeserializeSceneMSFT", function_loader.pfn_xrDeserializeSceneMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSceneObserverMSFT sceneObserver{};
    deserialize(&sceneObserver, d_ctx);
    XrSceneDeserializeInfoMSFT* deserializeInfo{};
    deserialize_ptr(&deserializeInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDeserializeSceneMSFT(sceneObserver, deserializeInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&sceneObserver);
    cleanup_ptr(deserializeInfo, 1);
}

void FunctionDispatch::handle_xrGetSerializedSceneFragmentDataMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSerializedSceneFragmentDataMSFT", function_loader.pfn_xrGetSerializedSceneFragmentDataMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);
    XrSerializedSceneFragmentDataGetInfoMSFT* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    uint32_t countInput{};
    deserialize(&countInput, d_ctx);
    uint32_t* readOutput{};
    deserialize_ptr(&readOutput, d_ctx);
    uint8_t* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSerializedSceneFragmentDataMSFT(scene, getInfo, countInput, readOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(readOutput, 1, s_ctx);
    serialize_ptr(buffer, countInput, s_ctx);
    msg_out.flush();

    cleanup(&scene);
    cleanup_ptr(getInfo, 1);
    cleanup(&countInput);
    cleanup_ptr(readOutput, 1);
    cleanup_ptr(buffer, countInput);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_scene_understanding_serialization
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_anchor
void FunctionDispatch::handle_xrCreateSpatialAnchorMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorMSFT", function_loader.pfn_xrCreateSpatialAnchorMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpatialAnchorMSFT* anchor{};
    deserialize_ptr(&anchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorMSFT(session, createInfo, anchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(anchor, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(anchor, 1);
}

void FunctionDispatch::handle_xrCreateSpatialAnchorSpaceMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorSpaceMSFT", function_loader.pfn_xrCreateSpatialAnchorSpaceMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorSpaceCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorSpaceMSFT(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrDestroySpatialAnchorMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySpatialAnchorMSFT", function_loader.pfn_xrDestroySpatialAnchorMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorMSFT anchor{};
    deserialize(&anchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroySpatialAnchorMSFT(anchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&anchor);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_anchor
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_anchor_persistence
void FunctionDispatch::handle_xrClearSpatialAnchorStoreMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrClearSpatialAnchorStoreMSFT", function_loader.pfn_xrClearSpatialAnchorStoreMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore{};
    deserialize(&spatialAnchorStore, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrClearSpatialAnchorStoreMSFT(spatialAnchorStore);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&spatialAnchorStore);
}

void FunctionDispatch::handle_xrCreateSpatialAnchorFromPersistedNameMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorFromPersistedNameMSFT", function_loader.pfn_xrCreateSpatialAnchorFromPersistedNameMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* spatialAnchorCreateInfo{};
    deserialize_ptr(&spatialAnchorCreateInfo, d_ctx);
    XrSpatialAnchorMSFT* spatialAnchor{};
    deserialize_ptr(&spatialAnchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorFromPersistedNameMSFT(session, spatialAnchorCreateInfo, spatialAnchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(spatialAnchor, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(spatialAnchorCreateInfo, 1);
    cleanup_ptr(spatialAnchor, 1);
}

void FunctionDispatch::handle_xrCreateSpatialAnchorStoreConnectionMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorStoreConnectionMSFT", function_loader.pfn_xrCreateSpatialAnchorStoreConnectionMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorStoreConnectionMSFT* spatialAnchorStore{};
    deserialize_ptr(&spatialAnchorStore, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialAnchorStoreConnectionMSFT(session, spatialAnchorStore);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(spatialAnchorStore, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(spatialAnchorStore, 1);
}

void FunctionDispatch::handle_xrDestroySpatialAnchorStoreConnectionMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySpatialAnchorStoreConnectionMSFT", function_loader.pfn_xrDestroySpatialAnchorStoreConnectionMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore{};
    deserialize(&spatialAnchorStore, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroySpatialAnchorStoreConnectionMSFT(spatialAnchorStore);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&spatialAnchorStore);
}

void FunctionDispatch::handle_xrEnumeratePersistedSpatialAnchorNamesMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumeratePersistedSpatialAnchorNamesMSFT", function_loader.pfn_xrEnumeratePersistedSpatialAnchorNamesMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore{};
    deserialize(&spatialAnchorStore, d_ctx);
    uint32_t spatialAnchorNameCapacityInput{};
    deserialize(&spatialAnchorNameCapacityInput, d_ctx);
    uint32_t* spatialAnchorNameCountOutput{};
    deserialize_ptr(&spatialAnchorNameCountOutput, d_ctx);
    XrSpatialAnchorPersistenceNameMSFT* spatialAnchorNames{};
    deserialize_ptr(&spatialAnchorNames, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumeratePersistedSpatialAnchorNamesMSFT(spatialAnchorStore, spatialAnchorNameCapacityInput, spatialAnchorNameCountOutput, spatialAnchorNames);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(spatialAnchorNameCountOutput, 1, s_ctx);
    serialize_ptr(spatialAnchorNames, spatialAnchorNameCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&spatialAnchorStore);
    cleanup(&spatialAnchorNameCapacityInput);
    cleanup_ptr(spatialAnchorNameCountOutput, 1);
    cleanup_ptr(spatialAnchorNames, spatialAnchorNameCapacityInput);
}

void FunctionDispatch::handle_xrPersistSpatialAnchorMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPersistSpatialAnchorMSFT", function_loader.pfn_xrPersistSpatialAnchorMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore{};
    deserialize(&spatialAnchorStore, d_ctx);
    XrSpatialAnchorPersistenceInfoMSFT* spatialAnchorPersistenceInfo{};
    deserialize_ptr(&spatialAnchorPersistenceInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&spatialAnchorStore);
    cleanup_ptr(spatialAnchorPersistenceInfo, 1);
}

void FunctionDispatch::handle_xrUnpersistSpatialAnchorMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUnpersistSpatialAnchorMSFT", function_loader.pfn_xrUnpersistSpatialAnchorMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore{};
    deserialize(&spatialAnchorStore, d_ctx);
    XrSpatialAnchorPersistenceNameMSFT* spatialAnchorPersistenceName{};
    deserialize_ptr(&spatialAnchorPersistenceName, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrUnpersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceName);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&spatialAnchorStore);
    cleanup_ptr(spatialAnchorPersistenceName, 1);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_anchor_persistence
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_graph_bridge
void FunctionDispatch::handle_xrCreateSpatialGraphNodeSpaceMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialGraphNodeSpaceMSFT", function_loader.pfn_xrCreateSpatialGraphNodeSpaceMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialGraphNodeSpaceCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSpatialGraphNodeSpaceMSFT(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrDestroySpatialGraphNodeBindingMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySpatialGraphNodeBindingMSFT", function_loader.pfn_xrDestroySpatialGraphNodeBindingMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialGraphNodeBindingMSFT nodeBinding{};
    deserialize(&nodeBinding, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroySpatialGraphNodeBindingMSFT(nodeBinding);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&nodeBinding);
}

void FunctionDispatch::handle_xrGetSpatialGraphNodeBindingPropertiesMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpatialGraphNodeBindingPropertiesMSFT", function_loader.pfn_xrGetSpatialGraphNodeBindingPropertiesMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpatialGraphNodeBindingMSFT nodeBinding{};
    deserialize(&nodeBinding, d_ctx);
    XrSpatialGraphNodeBindingPropertiesGetInfoMSFT* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrSpatialGraphNodeBindingPropertiesMSFT* properties{};
    deserialize_ptr(&properties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSpatialGraphNodeBindingPropertiesMSFT(nodeBinding, getInfo, properties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(properties, 1, s_ctx);
    msg_out.flush();

    cleanup(&nodeBinding);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(properties, 1);
}

void FunctionDispatch::handle_xrTryCreateSpatialGraphStaticNodeBindingMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTryCreateSpatialGraphStaticNodeBindingMSFT", function_loader.pfn_xrTryCreateSpatialGraphStaticNodeBindingMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialGraphStaticNodeBindingCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpatialGraphNodeBindingMSFT* nodeBinding{};
    deserialize_ptr(&nodeBinding, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrTryCreateSpatialGraphStaticNodeBindingMSFT(session, createInfo, nodeBinding);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(nodeBinding, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(nodeBinding, 1);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_graph_bridge
#ifdef XRTRANSPORT_EXT_XR_OCULUS_audio_device_guid
void FunctionDispatch::handle_xrGetAudioInputDeviceGuidOculus(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetAudioInputDeviceGuidOculus", function_loader.pfn_xrGetAudioInputDeviceGuidOculus);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS]{};
    deserialize_array(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetAudioInputDeviceGuidOculus(instance, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_array(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS);
}

void FunctionDispatch::handle_xrGetAudioOutputDeviceGuidOculus(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetAudioOutputDeviceGuidOculus", function_loader.pfn_xrGetAudioOutputDeviceGuidOculus);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS]{};
    deserialize_array(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetAudioOutputDeviceGuidOculus(instance, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_array(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS);
}

#endif // XRTRANSPORT_EXT_XR_OCULUS_audio_device_guid
#ifdef XRTRANSPORT_EXT_XR_OCULUS_external_camera
void FunctionDispatch::handle_xrEnumerateExternalCamerasOCULUS(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateExternalCamerasOCULUS", function_loader.pfn_xrEnumerateExternalCamerasOCULUS);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint32_t cameraCapacityInput{};
    deserialize(&cameraCapacityInput, d_ctx);
    uint32_t* cameraCountOutput{};
    deserialize_ptr(&cameraCountOutput, d_ctx);
    XrExternalCameraOCULUS* cameras{};
    deserialize_ptr(&cameras, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateExternalCamerasOCULUS(session, cameraCapacityInput, cameraCountOutput, cameras);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(cameraCountOutput, 1, s_ctx);
    serialize_ptr(cameras, cameraCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&cameraCapacityInput);
    cleanup_ptr(cameraCountOutput, 1);
    cleanup_ptr(cameras, cameraCapacityInput);
}

#endif // XRTRANSPORT_EXT_XR_OCULUS_external_camera
#ifdef XRTRANSPORT_EXT_XR_QCOM_tracking_optimization_settings
void FunctionDispatch::handle_xrSetTrackingOptimizationSettingsHintQCOM(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetTrackingOptimizationSettingsHintQCOM", function_loader.pfn_xrSetTrackingOptimizationSettingsHintQCOM);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrTrackingOptimizationSettingsDomainQCOM domain{};
    deserialize(&domain, d_ctx);
    XrTrackingOptimizationSettingsHintQCOM hint{};
    deserialize(&hint, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetTrackingOptimizationSettingsHintQCOM(session, domain, hint);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&domain);
    cleanup(&hint);
}

#endif // XRTRANSPORT_EXT_XR_QCOM_tracking_optimization_settings
#ifdef XRTRANSPORT_EXT_XR_VARJO_environment_depth_estimation
void FunctionDispatch::handle_xrSetEnvironmentDepthEstimationVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetEnvironmentDepthEstimationVARJO", function_loader.pfn_xrSetEnvironmentDepthEstimationVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrBool32 enabled{};
    deserialize(&enabled, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetEnvironmentDepthEstimationVARJO(session, enabled);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&enabled);
}

#endif // XRTRANSPORT_EXT_XR_VARJO_environment_depth_estimation
#ifdef XRTRANSPORT_EXT_XR_VARJO_marker_tracking
void FunctionDispatch::handle_xrCreateMarkerSpaceVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateMarkerSpaceVARJO", function_loader.pfn_xrCreateMarkerSpaceVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrMarkerSpaceCreateInfoVARJO* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateMarkerSpaceVARJO(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrGetMarkerSizeVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkerSizeVARJO", function_loader.pfn_xrGetMarkerSizeVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint64_t markerId{};
    deserialize(&markerId, d_ctx);
    XrExtent2Df* size{};
    deserialize_ptr(&size, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetMarkerSizeVARJO(session, markerId, size);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(size, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&markerId);
    cleanup_ptr(size, 1);
}

void FunctionDispatch::handle_xrSetMarkerTrackingPredictionVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetMarkerTrackingPredictionVARJO", function_loader.pfn_xrSetMarkerTrackingPredictionVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint64_t markerId{};
    deserialize(&markerId, d_ctx);
    XrBool32 enable{};
    deserialize(&enable, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetMarkerTrackingPredictionVARJO(session, markerId, enable);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&markerId);
    cleanup(&enable);
}

void FunctionDispatch::handle_xrSetMarkerTrackingTimeoutVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetMarkerTrackingTimeoutVARJO", function_loader.pfn_xrSetMarkerTrackingTimeoutVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint64_t markerId{};
    deserialize(&markerId, d_ctx);
    XrDuration timeout{};
    deserialize(&timeout, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetMarkerTrackingTimeoutVARJO(session, markerId, timeout);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&markerId);
    cleanup(&timeout);
}

void FunctionDispatch::handle_xrSetMarkerTrackingVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetMarkerTrackingVARJO", function_loader.pfn_xrSetMarkerTrackingVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrBool32 enabled{};
    deserialize(&enabled, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetMarkerTrackingVARJO(session, enabled);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&enabled);
}

#endif // XRTRANSPORT_EXT_XR_VARJO_marker_tracking
#ifdef XRTRANSPORT_EXT_XR_VARJO_view_offset
void FunctionDispatch::handle_xrSetViewOffsetVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetViewOffsetVARJO", function_loader.pfn_xrSetViewOffsetVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    float offset{};
    deserialize(&offset, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSetViewOffsetVARJO(session, offset);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&offset);
}

#endif // XRTRANSPORT_EXT_XR_VARJO_view_offset
void FunctionDispatch::handle_xrAcquireSwapchainImage(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrAcquireSwapchainImage", function_loader.pfn_xrAcquireSwapchainImage);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);
    XrSwapchainImageAcquireInfo* acquireInfo{};
    deserialize_ptr(&acquireInfo, d_ctx);
    uint32_t* index{};
    deserialize_ptr(&index, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrAcquireSwapchainImage(swapchain, acquireInfo, index);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(index, 1, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup_ptr(acquireInfo, 1);
    cleanup_ptr(index, 1);
}

void FunctionDispatch::handle_xrApplyHapticFeedback(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrApplyHapticFeedback", function_loader.pfn_xrApplyHapticFeedback);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrHapticActionInfo* hapticActionInfo{};
    deserialize_ptr(&hapticActionInfo, d_ctx);
    XrHapticBaseHeader* hapticFeedback{};
    deserialize_xr(&hapticFeedback, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrApplyHapticFeedback(session, hapticActionInfo, hapticFeedback);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(hapticActionInfo, 1);
    cleanup_xr(hapticFeedback);
}

void FunctionDispatch::handle_xrAttachSessionActionSets(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrAttachSessionActionSets", function_loader.pfn_xrAttachSessionActionSets);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSessionActionSetsAttachInfo* attachInfo{};
    deserialize_ptr(&attachInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrAttachSessionActionSets(session, attachInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(attachInfo, 1);
}

void FunctionDispatch::handle_xrBeginFrame(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrBeginFrame", function_loader.pfn_xrBeginFrame);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFrameBeginInfo* frameBeginInfo{};
    deserialize_ptr(&frameBeginInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrBeginFrame(session, frameBeginInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(frameBeginInfo, 1);
}

void FunctionDispatch::handle_xrBeginSession(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrBeginSession", function_loader.pfn_xrBeginSession);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSessionBeginInfo* beginInfo{};
    deserialize_ptr(&beginInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrBeginSession(session, beginInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(beginInfo, 1);
}

void FunctionDispatch::handle_xrCreateAction(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateAction", function_loader.pfn_xrCreateAction);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrActionSet actionSet{};
    deserialize(&actionSet, d_ctx);
    XrActionCreateInfo* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrAction* action{};
    deserialize_ptr(&action, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateAction(actionSet, createInfo, action);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(action, 1, s_ctx);
    msg_out.flush();

    cleanup(&actionSet);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(action, 1);
}

void FunctionDispatch::handle_xrCreateActionSet(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateActionSet", function_loader.pfn_xrCreateActionSet);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrActionSetCreateInfo* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrActionSet* actionSet{};
    deserialize_ptr(&actionSet, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateActionSet(instance, createInfo, actionSet);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(actionSet, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(actionSet, 1);
}

void FunctionDispatch::handle_xrCreateActionSpace(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateActionSpace", function_loader.pfn_xrCreateActionSpace);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrActionSpaceCreateInfo* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateActionSpace(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrCreateInstance(MessageLockIn msg_in) {
    // redirect to supplied xrCreateInstance handler
    instance_handler(std::move(msg_in));
}

void FunctionDispatch::handle_xrCreateReferenceSpace(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateReferenceSpace", function_loader.pfn_xrCreateReferenceSpace);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrReferenceSpaceCreateInfo* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateReferenceSpace(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrCreateSession(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSession", function_loader.pfn_xrCreateSession);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSessionCreateInfo* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSession* session{};
    deserialize_ptr(&session, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSession(instance, createInfo, session);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(session, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(session, 1);
}

void FunctionDispatch::handle_xrCreateSwapchain(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSwapchain", function_loader.pfn_xrCreateSwapchain);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSwapchainCreateInfo* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSwapchain* swapchain{};
    deserialize_ptr(&swapchain, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrCreateSwapchain(session, createInfo, swapchain);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(swapchain, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(swapchain, 1);
}

void FunctionDispatch::handle_xrDestroyAction(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyAction", function_loader.pfn_xrDestroyAction);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrAction action{};
    deserialize(&action, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyAction(action);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&action);
}

void FunctionDispatch::handle_xrDestroyActionSet(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyActionSet", function_loader.pfn_xrDestroyActionSet);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrActionSet actionSet{};
    deserialize(&actionSet, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyActionSet(actionSet);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&actionSet);
}

void FunctionDispatch::handle_xrDestroyInstance(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyInstance", function_loader.pfn_xrDestroyInstance);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroyInstance(instance);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
}

void FunctionDispatch::handle_xrDestroySession(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySession", function_loader.pfn_xrDestroySession);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroySession(session);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
}

void FunctionDispatch::handle_xrDestroySpace(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySpace", function_loader.pfn_xrDestroySpace);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpace space{};
    deserialize(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroySpace(space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&space);
}

void FunctionDispatch::handle_xrDestroySwapchain(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySwapchain", function_loader.pfn_xrDestroySwapchain);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrDestroySwapchain(swapchain);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
}

void FunctionDispatch::handle_xrEndFrame(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEndFrame", function_loader.pfn_xrEndFrame);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFrameEndInfo* frameEndInfo{};
    deserialize_ptr(&frameEndInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEndFrame(session, frameEndInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(frameEndInfo, 1);
}

void FunctionDispatch::handle_xrEndSession(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEndSession", function_loader.pfn_xrEndSession);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEndSession(session);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
}

void FunctionDispatch::handle_xrEnumerateApiLayerProperties(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateApiLayerProperties", function_loader.pfn_xrEnumerateApiLayerProperties);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    uint32_t propertyCapacityInput{};
    deserialize(&propertyCapacityInput, d_ctx);
    uint32_t* propertyCountOutput{};
    deserialize_ptr(&propertyCountOutput, d_ctx);
    XrApiLayerProperties* properties{};
    deserialize_ptr(&properties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateApiLayerProperties(propertyCapacityInput, propertyCountOutput, properties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(propertyCountOutput, 1, s_ctx);
    serialize_ptr(properties, propertyCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&propertyCapacityInput);
    cleanup_ptr(propertyCountOutput, 1);
    cleanup_ptr(properties, propertyCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateBoundSourcesForAction(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateBoundSourcesForAction", function_loader.pfn_xrEnumerateBoundSourcesForAction);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrBoundSourcesForActionEnumerateInfo* enumerateInfo{};
    deserialize_ptr(&enumerateInfo, d_ctx);
    uint32_t sourceCapacityInput{};
    deserialize(&sourceCapacityInput, d_ctx);
    uint32_t* sourceCountOutput{};
    deserialize_ptr(&sourceCountOutput, d_ctx);
    XrPath* sources{};
    deserialize_ptr(&sources, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateBoundSourcesForAction(session, enumerateInfo, sourceCapacityInput, sourceCountOutput, sources);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(sourceCountOutput, 1, s_ctx);
    serialize_ptr(sources, sourceCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(enumerateInfo, 1);
    cleanup(&sourceCapacityInput);
    cleanup_ptr(sourceCountOutput, 1);
    cleanup_ptr(sources, sourceCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateEnvironmentBlendModes(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateEnvironmentBlendModes", function_loader.pfn_xrEnumerateEnvironmentBlendModes);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrViewConfigurationType viewConfigurationType{};
    deserialize(&viewConfigurationType, d_ctx);
    uint32_t environmentBlendModeCapacityInput{};
    deserialize(&environmentBlendModeCapacityInput, d_ctx);
    uint32_t* environmentBlendModeCountOutput{};
    deserialize_ptr(&environmentBlendModeCountOutput, d_ctx);
    XrEnvironmentBlendMode* environmentBlendModes{};
    deserialize_ptr(&environmentBlendModes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateEnvironmentBlendModes(instance, systemId, viewConfigurationType, environmentBlendModeCapacityInput, environmentBlendModeCountOutput, environmentBlendModes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(environmentBlendModeCountOutput, 1, s_ctx);
    serialize_ptr(environmentBlendModes, environmentBlendModeCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&viewConfigurationType);
    cleanup(&environmentBlendModeCapacityInput);
    cleanup_ptr(environmentBlendModeCountOutput, 1);
    cleanup_ptr(environmentBlendModes, environmentBlendModeCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateInstanceExtensionProperties(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateInstanceExtensionProperties", function_loader.pfn_xrEnumerateInstanceExtensionProperties);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    char* layerName{};
    deserialize_ptr(&layerName, d_ctx);
    uint32_t propertyCapacityInput{};
    deserialize(&propertyCapacityInput, d_ctx);
    uint32_t* propertyCountOutput{};
    deserialize_ptr(&propertyCountOutput, d_ctx);
    XrExtensionProperties* properties{};
    deserialize_ptr(&properties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateInstanceExtensionProperties(layerName, propertyCapacityInput, propertyCountOutput, properties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(propertyCountOutput, 1, s_ctx);
    serialize_ptr(properties, propertyCapacityInput, s_ctx);
    msg_out.flush();

    cleanup_ptr(layerName, count_null_terminated(layerName));
    cleanup(&propertyCapacityInput);
    cleanup_ptr(propertyCountOutput, 1);
    cleanup_ptr(properties, propertyCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateReferenceSpaces(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateReferenceSpaces", function_loader.pfn_xrEnumerateReferenceSpaces);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint32_t spaceCapacityInput{};
    deserialize(&spaceCapacityInput, d_ctx);
    uint32_t* spaceCountOutput{};
    deserialize_ptr(&spaceCountOutput, d_ctx);
    XrReferenceSpaceType* spaces{};
    deserialize_ptr(&spaces, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateReferenceSpaces(session, spaceCapacityInput, spaceCountOutput, spaces);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(spaceCountOutput, 1, s_ctx);
    serialize_ptr(spaces, spaceCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&spaceCapacityInput);
    cleanup_ptr(spaceCountOutput, 1);
    cleanup_ptr(spaces, spaceCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateSwapchainFormats(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateSwapchainFormats", function_loader.pfn_xrEnumerateSwapchainFormats);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint32_t formatCapacityInput{};
    deserialize(&formatCapacityInput, d_ctx);
    uint32_t* formatCountOutput{};
    deserialize_ptr(&formatCountOutput, d_ctx);
    int64_t* formats{};
    deserialize_ptr(&formats, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateSwapchainFormats(session, formatCapacityInput, formatCountOutput, formats);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(formatCountOutput, 1, s_ctx);
    serialize_ptr(formats, formatCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&formatCapacityInput);
    cleanup_ptr(formatCountOutput, 1);
    cleanup_ptr(formats, formatCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateSwapchainImages(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateSwapchainImages", function_loader.pfn_xrEnumerateSwapchainImages);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);
    uint32_t imageCapacityInput{};
    deserialize(&imageCapacityInput, d_ctx);
    uint32_t* imageCountOutput{};
    deserialize_ptr(&imageCountOutput, d_ctx);
    XrSwapchainImageBaseHeader* images{};
    deserialize_xr_array(&images, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateSwapchainImages(swapchain, imageCapacityInput, imageCountOutput, images);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(imageCountOutput, 1, s_ctx);
    serialize_xr_array(images, imageCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup(&imageCapacityInput);
    cleanup_ptr(imageCountOutput, 1);
    cleanup_xr_array(images, imageCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateViewConfigurationViews(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateViewConfigurationViews", function_loader.pfn_xrEnumerateViewConfigurationViews);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrViewConfigurationType viewConfigurationType{};
    deserialize(&viewConfigurationType, d_ctx);
    uint32_t viewCapacityInput{};
    deserialize(&viewCapacityInput, d_ctx);
    uint32_t* viewCountOutput{};
    deserialize_ptr(&viewCountOutput, d_ctx);
    XrViewConfigurationView* views{};
    deserialize_ptr(&views, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateViewConfigurationViews(instance, systemId, viewConfigurationType, viewCapacityInput, viewCountOutput, views);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(viewCountOutput, 1, s_ctx);
    serialize_ptr(views, viewCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&viewConfigurationType);
    cleanup(&viewCapacityInput);
    cleanup_ptr(viewCountOutput, 1);
    cleanup_ptr(views, viewCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateViewConfigurations(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateViewConfigurations", function_loader.pfn_xrEnumerateViewConfigurations);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    uint32_t viewConfigurationTypeCapacityInput{};
    deserialize(&viewConfigurationTypeCapacityInput, d_ctx);
    uint32_t* viewConfigurationTypeCountOutput{};
    deserialize_ptr(&viewConfigurationTypeCountOutput, d_ctx);
    XrViewConfigurationType* viewConfigurationTypes{};
    deserialize_ptr(&viewConfigurationTypes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrEnumerateViewConfigurations(instance, systemId, viewConfigurationTypeCapacityInput, viewConfigurationTypeCountOutput, viewConfigurationTypes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(viewConfigurationTypeCountOutput, 1, s_ctx);
    serialize_ptr(viewConfigurationTypes, viewConfigurationTypeCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&viewConfigurationTypeCapacityInput);
    cleanup_ptr(viewConfigurationTypeCountOutput, 1);
    cleanup_ptr(viewConfigurationTypes, viewConfigurationTypeCapacityInput);
}

void FunctionDispatch::handle_xrGetActionStateBoolean(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetActionStateBoolean", function_loader.pfn_xrGetActionStateBoolean);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrActionStateGetInfo* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrActionStateBoolean* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetActionStateBoolean(session, getInfo, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetActionStateFloat(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetActionStateFloat", function_loader.pfn_xrGetActionStateFloat);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrActionStateGetInfo* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrActionStateFloat* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetActionStateFloat(session, getInfo, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetActionStatePose(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetActionStatePose", function_loader.pfn_xrGetActionStatePose);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrActionStateGetInfo* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrActionStatePose* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetActionStatePose(session, getInfo, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetActionStateVector2f(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetActionStateVector2f", function_loader.pfn_xrGetActionStateVector2f);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrActionStateGetInfo* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrActionStateVector2f* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetActionStateVector2f(session, getInfo, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetCurrentInteractionProfile(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetCurrentInteractionProfile", function_loader.pfn_xrGetCurrentInteractionProfile);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath topLevelUserPath{};
    deserialize(&topLevelUserPath, d_ctx);
    XrInteractionProfileState* interactionProfile{};
    deserialize_ptr(&interactionProfile, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetCurrentInteractionProfile(session, topLevelUserPath, interactionProfile);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(interactionProfile, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&topLevelUserPath);
    cleanup_ptr(interactionProfile, 1);
}

void FunctionDispatch::handle_xrGetInputSourceLocalizedName(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetInputSourceLocalizedName", function_loader.pfn_xrGetInputSourceLocalizedName);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrInputSourceLocalizedNameGetInfo* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetInputSourceLocalizedName(session, getInfo, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(getInfo, 1);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

void FunctionDispatch::handle_xrGetInstanceProperties(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetInstanceProperties", function_loader.pfn_xrGetInstanceProperties);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrInstanceProperties* instanceProperties{};
    deserialize_ptr(&instanceProperties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetInstanceProperties(instance, instanceProperties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(instanceProperties, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(instanceProperties, 1);
}

void FunctionDispatch::handle_xrGetReferenceSpaceBoundsRect(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetReferenceSpaceBoundsRect", function_loader.pfn_xrGetReferenceSpaceBoundsRect);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrReferenceSpaceType referenceSpaceType{};
    deserialize(&referenceSpaceType, d_ctx);
    XrExtent2Df* bounds{};
    deserialize_ptr(&bounds, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetReferenceSpaceBoundsRect(session, referenceSpaceType, bounds);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bounds, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&referenceSpaceType);
    cleanup_ptr(bounds, 1);
}

void FunctionDispatch::handle_xrGetSystem(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSystem", function_loader.pfn_xrGetSystem);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemGetInfo* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrSystemId* systemId{};
    deserialize_ptr(&systemId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSystem(instance, getInfo, systemId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(systemId, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(systemId, 1);
}

void FunctionDispatch::handle_xrGetSystemProperties(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSystemProperties", function_loader.pfn_xrGetSystemProperties);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrSystemProperties* properties{};
    deserialize_ptr(&properties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetSystemProperties(instance, systemId, properties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(properties, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(properties, 1);
}

void FunctionDispatch::handle_xrGetViewConfigurationProperties(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetViewConfigurationProperties", function_loader.pfn_xrGetViewConfigurationProperties);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrViewConfigurationType viewConfigurationType{};
    deserialize(&viewConfigurationType, d_ctx);
    XrViewConfigurationProperties* configurationProperties{};
    deserialize_ptr(&configurationProperties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrGetViewConfigurationProperties(instance, systemId, viewConfigurationType, configurationProperties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(configurationProperties, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&viewConfigurationType);
    cleanup_ptr(configurationProperties, 1);
}

void FunctionDispatch::handle_xrLocateSpace(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateSpace", function_loader.pfn_xrLocateSpace);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrSpace baseSpace{};
    deserialize(&baseSpace, d_ctx);
    XrTime time{};
    deserialize_time(&time, d_ctx);
    XrSpaceLocation* location{};
    deserialize_ptr(&location, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrLocateSpace(space, baseSpace, time, location);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(location, 1, s_ctx);
    msg_out.flush();

    cleanup(&space);
    cleanup(&baseSpace);
    cleanup(&time);
    cleanup_ptr(location, 1);
}

void FunctionDispatch::handle_xrLocateSpaces(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateSpaces", function_loader.pfn_xrLocateSpaces);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpacesLocateInfo* locateInfo{};
    deserialize_ptr(&locateInfo, d_ctx);
    XrSpaceLocations* spaceLocations{};
    deserialize_ptr(&spaceLocations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrLocateSpaces(session, locateInfo, spaceLocations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(spaceLocations, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(locateInfo, 1);
    cleanup_ptr(spaceLocations, 1);
}

void FunctionDispatch::handle_xrLocateViews(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateViews", function_loader.pfn_xrLocateViews);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrViewLocateInfo* viewLocateInfo{};
    deserialize_ptr(&viewLocateInfo, d_ctx);
    XrViewState* viewState{};
    deserialize_ptr(&viewState, d_ctx);
    uint32_t viewCapacityInput{};
    deserialize(&viewCapacityInput, d_ctx);
    uint32_t* viewCountOutput{};
    deserialize_ptr(&viewCountOutput, d_ctx);
    XrView* views{};
    deserialize_ptr(&views, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrLocateViews(session, viewLocateInfo, viewState, viewCapacityInput, viewCountOutput, views);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(viewState, 1, s_ctx);
    serialize_ptr(viewCountOutput, 1, s_ctx);
    serialize_ptr(views, viewCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(viewLocateInfo, 1);
    cleanup_ptr(viewState, 1);
    cleanup(&viewCapacityInput);
    cleanup_ptr(viewCountOutput, 1);
    cleanup_ptr(views, viewCapacityInput);
}

void FunctionDispatch::handle_xrPathToString(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPathToString", function_loader.pfn_xrPathToString);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrPath path{};
    deserialize(&path, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPathToString(instance, path, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&path);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

void FunctionDispatch::handle_xrPollEvent(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPollEvent", function_loader.pfn_xrPollEvent);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrEventDataBuffer* eventData{};
    deserialize_ptr(&eventData, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrPollEvent(instance, eventData);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(eventData, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(eventData, 1);
}

void FunctionDispatch::handle_xrReleaseSwapchainImage(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrReleaseSwapchainImage", function_loader.pfn_xrReleaseSwapchainImage);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);
    XrSwapchainImageReleaseInfo* releaseInfo{};
    deserialize_ptr(&releaseInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrReleaseSwapchainImage(swapchain, releaseInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup_ptr(releaseInfo, 1);
}

void FunctionDispatch::handle_xrRequestExitSession(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestExitSession", function_loader.pfn_xrRequestExitSession);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrRequestExitSession(session);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
}

void FunctionDispatch::handle_xrResultToString(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrResultToString", function_loader.pfn_xrResultToString);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrResult value{};
    deserialize(&value, d_ctx);
    char buffer[XR_MAX_RESULT_STRING_SIZE]{};
    deserialize_array(buffer, XR_MAX_RESULT_STRING_SIZE, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrResultToString(instance, value, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(buffer, XR_MAX_RESULT_STRING_SIZE, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&value);
    cleanup_array(buffer, XR_MAX_RESULT_STRING_SIZE);
}

void FunctionDispatch::handle_xrStopHapticFeedback(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStopHapticFeedback", function_loader.pfn_xrStopHapticFeedback);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrHapticActionInfo* hapticActionInfo{};
    deserialize_ptr(&hapticActionInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrStopHapticFeedback(session, hapticActionInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(hapticActionInfo, 1);
}

void FunctionDispatch::handle_xrStringToPath(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStringToPath", function_loader.pfn_xrStringToPath);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    char* pathString{};
    deserialize_ptr(&pathString, d_ctx);
    XrPath* path{};
    deserialize_ptr(&path, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrStringToPath(instance, pathString, path);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(path, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(pathString, count_null_terminated(pathString));
    cleanup_ptr(path, 1);
}

void FunctionDispatch::handle_xrStructureTypeToString(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStructureTypeToString", function_loader.pfn_xrStructureTypeToString);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrStructureType value{};
    deserialize(&value, d_ctx);
    char buffer[XR_MAX_STRUCTURE_NAME_SIZE]{};
    deserialize_array(buffer, XR_MAX_STRUCTURE_NAME_SIZE, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrStructureTypeToString(instance, value, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(buffer, XR_MAX_STRUCTURE_NAME_SIZE, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&value);
    cleanup_array(buffer, XR_MAX_STRUCTURE_NAME_SIZE);
}

void FunctionDispatch::handle_xrSuggestInteractionProfileBindings(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSuggestInteractionProfileBindings", function_loader.pfn_xrSuggestInteractionProfileBindings);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrInteractionProfileSuggestedBinding* suggestedBindings{};
    deserialize_ptr(&suggestedBindings, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSuggestInteractionProfileBindings(instance, suggestedBindings);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(suggestedBindings, 1);
}

void FunctionDispatch::handle_xrSyncActions(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSyncActions", function_loader.pfn_xrSyncActions);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrActionsSyncInfo* syncInfo{};
    deserialize_ptr(&syncInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrSyncActions(session, syncInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(syncInfo, 1);
}

void FunctionDispatch::handle_xrWaitFrame(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrWaitFrame", function_loader.pfn_xrWaitFrame);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFrameWaitInfo* frameWaitInfo{};
    deserialize_ptr(&frameWaitInfo, d_ctx);
    XrFrameState* frameState{};
    deserialize_ptr(&frameState, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrWaitFrame(session, frameWaitInfo, frameState);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(frameState, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(frameWaitInfo, 1);
    cleanup_ptr(frameState, 1);
}

void FunctionDispatch::handle_xrWaitSwapchainImage(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrWaitSwapchainImage", function_loader.pfn_xrWaitSwapchainImage);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.stream);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);
    XrSwapchainImageWaitInfo* waitInfo{};
    deserialize_ptr(&waitInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.pfn_xrWaitSwapchainImage(swapchain, waitInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup_ptr(waitInfo, 1);
}



std::unordered_map<uint32_t, FunctionDispatch::Handler> FunctionDispatch::handlers = {
#ifdef XRTRANSPORT_EXT_XR_ALMALENCE_digital_lens_control
    {197001, &FunctionDispatch::handle_xrSetDigitalLensControlALMALENCE},
#endif // XRTRANSPORT_EXT_XR_ALMALENCE_digital_lens_control
#ifdef XRTRANSPORT_EXT_XR_BD_body_tracking
    {386001, &FunctionDispatch::handle_xrCreateBodyTrackerBD},
    {386002, &FunctionDispatch::handle_xrDestroyBodyTrackerBD},
    {386003, &FunctionDispatch::handle_xrLocateBodyJointsBD},
#endif // XRTRANSPORT_EXT_XR_BD_body_tracking
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_anchor
    {391001, &FunctionDispatch::handle_xrCreateSpatialAnchorAsyncBD},
    {391002, &FunctionDispatch::handle_xrCreateSpatialAnchorCompleteBD},
    {391003, &FunctionDispatch::handle_xrPersistSpatialAnchorAsyncBD},
    {391004, &FunctionDispatch::handle_xrPersistSpatialAnchorCompleteBD},
    {391005, &FunctionDispatch::handle_xrUnpersistSpatialAnchorAsyncBD},
    {391006, &FunctionDispatch::handle_xrUnpersistSpatialAnchorCompleteBD},
#endif // XRTRANSPORT_EXT_XR_BD_spatial_anchor
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_anchor_sharing
    {392001, &FunctionDispatch::handle_xrDownloadSharedSpatialAnchorAsyncBD},
    {392002, &FunctionDispatch::handle_xrDownloadSharedSpatialAnchorCompleteBD},
    {392003, &FunctionDispatch::handle_xrShareSpatialAnchorAsyncBD},
    {392004, &FunctionDispatch::handle_xrShareSpatialAnchorCompleteBD},
#endif // XRTRANSPORT_EXT_XR_BD_spatial_anchor_sharing
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_scene
    {393001, &FunctionDispatch::handle_xrCaptureSceneAsyncBD},
    {393002, &FunctionDispatch::handle_xrCaptureSceneCompleteBD},
#endif // XRTRANSPORT_EXT_XR_BD_spatial_scene
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_sensing
    {390001, &FunctionDispatch::handle_xrCreateAnchorSpaceBD},
    {390002, &FunctionDispatch::handle_xrCreateSenseDataProviderBD},
    {390003, &FunctionDispatch::handle_xrCreateSpatialEntityAnchorBD},
    {390004, &FunctionDispatch::handle_xrDestroyAnchorBD},
    {390005, &FunctionDispatch::handle_xrDestroySenseDataProviderBD},
    {390006, &FunctionDispatch::handle_xrDestroySenseDataSnapshotBD},
    {390007, &FunctionDispatch::handle_xrEnumerateSpatialEntityComponentTypesBD},
    {390008, &FunctionDispatch::handle_xrGetAnchorUuidBD},
    {390009, &FunctionDispatch::handle_xrGetQueriedSenseDataBD},
    {390010, &FunctionDispatch::handle_xrGetSenseDataProviderStateBD},
    {390011, &FunctionDispatch::handle_xrGetSpatialEntityComponentDataBD},
    {390012, &FunctionDispatch::handle_xrGetSpatialEntityUuidBD},
    {390013, &FunctionDispatch::handle_xrQuerySenseDataAsyncBD},
    {390014, &FunctionDispatch::handle_xrQuerySenseDataCompleteBD},
    {390015, &FunctionDispatch::handle_xrStartSenseDataProviderAsyncBD},
    {390016, &FunctionDispatch::handle_xrStartSenseDataProviderCompleteBD},
    {390017, &FunctionDispatch::handle_xrStopSenseDataProviderBD},
#endif // XRTRANSPORT_EXT_XR_BD_spatial_sensing
#ifdef XRTRANSPORT_EXT_XR_EXT_conformance_automation
    {48001, &FunctionDispatch::handle_xrSetInputDeviceActiveEXT},
    {48002, &FunctionDispatch::handle_xrSetInputDeviceLocationEXT},
    {48003, &FunctionDispatch::handle_xrSetInputDeviceStateBoolEXT},
    {48004, &FunctionDispatch::handle_xrSetInputDeviceStateFloatEXT},
    {48005, &FunctionDispatch::handle_xrSetInputDeviceStateVector2fEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_conformance_automation
#ifdef XRTRANSPORT_EXT_XR_EXT_debug_utils
    {20001, &FunctionDispatch::handle_xrCreateDebugUtilsMessengerEXT},
    {20002, &FunctionDispatch::handle_xrDestroyDebugUtilsMessengerEXT},
    {20003, &FunctionDispatch::handle_xrSessionBeginDebugUtilsLabelRegionEXT},
    {20004, &FunctionDispatch::handle_xrSessionEndDebugUtilsLabelRegionEXT},
    {20005, &FunctionDispatch::handle_xrSessionInsertDebugUtilsLabelEXT},
    {20006, &FunctionDispatch::handle_xrSetDebugUtilsObjectNameEXT},
    {20007, &FunctionDispatch::handle_xrSubmitDebugUtilsMessageEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_debug_utils
#ifdef XRTRANSPORT_EXT_XR_EXT_future
    {470001, &FunctionDispatch::handle_xrCancelFutureEXT},
    {470002, &FunctionDispatch::handle_xrPollFutureEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_future
#ifdef XRTRANSPORT_EXT_XR_EXT_hand_tracking
    {52001, &FunctionDispatch::handle_xrCreateHandTrackerEXT},
    {52002, &FunctionDispatch::handle_xrDestroyHandTrackerEXT},
    {52003, &FunctionDispatch::handle_xrLocateHandJointsEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_hand_tracking
#ifdef XRTRANSPORT_EXT_XR_EXT_performance_settings
    {16001, &FunctionDispatch::handle_xrPerfSettingsSetPerformanceLevelEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_performance_settings
#ifdef XRTRANSPORT_EXT_XR_EXT_plane_detection
    {430001, &FunctionDispatch::handle_xrBeginPlaneDetectionEXT},
    {430002, &FunctionDispatch::handle_xrCreatePlaneDetectorEXT},
    {430003, &FunctionDispatch::handle_xrDestroyPlaneDetectorEXT},
    {430004, &FunctionDispatch::handle_xrGetPlaneDetectionStateEXT},
    {430005, &FunctionDispatch::handle_xrGetPlaneDetectionsEXT},
    {430006, &FunctionDispatch::handle_xrGetPlanePolygonBufferEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_plane_detection
#ifdef XRTRANSPORT_EXT_XR_EXT_thermal_query
    {17001, &FunctionDispatch::handle_xrThermalGetTemperatureTrendEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_thermal_query
#ifdef XRTRANSPORT_EXT_XR_FB_body_tracking
    {77001, &FunctionDispatch::handle_xrCreateBodyTrackerFB},
    {77002, &FunctionDispatch::handle_xrDestroyBodyTrackerFB},
    {77003, &FunctionDispatch::handle_xrGetBodySkeletonFB},
    {77004, &FunctionDispatch::handle_xrLocateBodyJointsFB},
#endif // XRTRANSPORT_EXT_XR_FB_body_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_color_space
    {109001, &FunctionDispatch::handle_xrEnumerateColorSpacesFB},
    {109002, &FunctionDispatch::handle_xrSetColorSpaceFB},
#endif // XRTRANSPORT_EXT_XR_FB_color_space
#ifdef XRTRANSPORT_EXT_XR_FB_display_refresh_rate
    {102001, &FunctionDispatch::handle_xrEnumerateDisplayRefreshRatesFB},
    {102002, &FunctionDispatch::handle_xrGetDisplayRefreshRateFB},
    {102003, &FunctionDispatch::handle_xrRequestDisplayRefreshRateFB},
#endif // XRTRANSPORT_EXT_XR_FB_display_refresh_rate
#ifdef XRTRANSPORT_EXT_XR_FB_eye_tracking_social
    {203001, &FunctionDispatch::handle_xrCreateEyeTrackerFB},
    {203002, &FunctionDispatch::handle_xrDestroyEyeTrackerFB},
    {203003, &FunctionDispatch::handle_xrGetEyeGazesFB},
#endif // XRTRANSPORT_EXT_XR_FB_eye_tracking_social
#ifdef XRTRANSPORT_EXT_XR_FB_face_tracking
    {202001, &FunctionDispatch::handle_xrCreateFaceTrackerFB},
    {202002, &FunctionDispatch::handle_xrDestroyFaceTrackerFB},
    {202003, &FunctionDispatch::handle_xrGetFaceExpressionWeightsFB},
#endif // XRTRANSPORT_EXT_XR_FB_face_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_face_tracking2
    {288001, &FunctionDispatch::handle_xrCreateFaceTracker2FB},
    {288002, &FunctionDispatch::handle_xrDestroyFaceTracker2FB},
    {288003, &FunctionDispatch::handle_xrGetFaceExpressionWeights2FB},
#endif // XRTRANSPORT_EXT_XR_FB_face_tracking2
#ifdef XRTRANSPORT_EXT_XR_FB_foveation
    {115001, &FunctionDispatch::handle_xrCreateFoveationProfileFB},
    {115002, &FunctionDispatch::handle_xrDestroyFoveationProfileFB},
#endif // XRTRANSPORT_EXT_XR_FB_foveation
#ifdef XRTRANSPORT_EXT_XR_FB_hand_tracking_mesh
    {111001, &FunctionDispatch::handle_xrGetHandMeshFB},
#endif // XRTRANSPORT_EXT_XR_FB_hand_tracking_mesh
#ifdef XRTRANSPORT_EXT_XR_FB_haptic_pcm
    {210001, &FunctionDispatch::handle_xrGetDeviceSampleRateFB},
#endif // XRTRANSPORT_EXT_XR_FB_haptic_pcm
#ifdef XRTRANSPORT_EXT_XR_FB_keyboard_tracking
    {117001, &FunctionDispatch::handle_xrCreateKeyboardSpaceFB},
    {117002, &FunctionDispatch::handle_xrQuerySystemTrackedKeyboardFB},
#endif // XRTRANSPORT_EXT_XR_FB_keyboard_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_passthrough
    {119001, &FunctionDispatch::handle_xrCreateGeometryInstanceFB},
    {119002, &FunctionDispatch::handle_xrCreatePassthroughFB},
    {119003, &FunctionDispatch::handle_xrCreatePassthroughLayerFB},
    {119004, &FunctionDispatch::handle_xrDestroyGeometryInstanceFB},
    {119005, &FunctionDispatch::handle_xrDestroyPassthroughFB},
    {119006, &FunctionDispatch::handle_xrDestroyPassthroughLayerFB},
    {119007, &FunctionDispatch::handle_xrGeometryInstanceSetTransformFB},
    {119008, &FunctionDispatch::handle_xrPassthroughLayerPauseFB},
    {119009, &FunctionDispatch::handle_xrPassthroughLayerResumeFB},
    {119010, &FunctionDispatch::handle_xrPassthroughLayerSetStyleFB},
    {119011, &FunctionDispatch::handle_xrPassthroughPauseFB},
    {119012, &FunctionDispatch::handle_xrPassthroughStartFB},
#endif // XRTRANSPORT_EXT_XR_FB_passthrough
#ifdef XRTRANSPORT_EXT_XR_FB_passthrough_keyboard_hands
    {204001, &FunctionDispatch::handle_xrPassthroughLayerSetKeyboardHandsIntensityFB},
#endif // XRTRANSPORT_EXT_XR_FB_passthrough_keyboard_hands
#ifdef XRTRANSPORT_EXT_XR_FB_render_model
    {120001, &FunctionDispatch::handle_xrEnumerateRenderModelPathsFB},
    {120002, &FunctionDispatch::handle_xrGetRenderModelPropertiesFB},
    {120003, &FunctionDispatch::handle_xrLoadRenderModelFB},
#endif // XRTRANSPORT_EXT_XR_FB_render_model
#ifdef XRTRANSPORT_EXT_XR_FB_scene
    {176001, &FunctionDispatch::handle_xrGetSpaceBoundary2DFB},
    {176002, &FunctionDispatch::handle_xrGetSpaceBoundingBox2DFB},
    {176003, &FunctionDispatch::handle_xrGetSpaceBoundingBox3DFB},
    {176004, &FunctionDispatch::handle_xrGetSpaceRoomLayoutFB},
    {176005, &FunctionDispatch::handle_xrGetSpaceSemanticLabelsFB},
#endif // XRTRANSPORT_EXT_XR_FB_scene
#ifdef XRTRANSPORT_EXT_XR_FB_scene_capture
    {199001, &FunctionDispatch::handle_xrRequestSceneCaptureFB},
#endif // XRTRANSPORT_EXT_XR_FB_scene_capture
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity
    {114001, &FunctionDispatch::handle_xrCreateSpatialAnchorFB},
    {114002, &FunctionDispatch::handle_xrEnumerateSpaceSupportedComponentsFB},
    {114003, &FunctionDispatch::handle_xrGetSpaceComponentStatusFB},
    {114004, &FunctionDispatch::handle_xrGetSpaceUuidFB},
    {114005, &FunctionDispatch::handle_xrSetSpaceComponentStatusFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_container
    {200001, &FunctionDispatch::handle_xrGetSpaceContainerFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_container
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_query
    {157001, &FunctionDispatch::handle_xrQuerySpacesFB},
    {157002, &FunctionDispatch::handle_xrRetrieveSpaceQueryResultsFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_query
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_sharing
    {170001, &FunctionDispatch::handle_xrShareSpacesFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_sharing
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_storage
    {159001, &FunctionDispatch::handle_xrEraseSpaceFB},
    {159002, &FunctionDispatch::handle_xrSaveSpaceFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_storage
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_storage_batch
    {239001, &FunctionDispatch::handle_xrSaveSpaceListFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_storage_batch
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_user
    {242001, &FunctionDispatch::handle_xrCreateSpaceUserFB},
    {242002, &FunctionDispatch::handle_xrDestroySpaceUserFB},
    {242003, &FunctionDispatch::handle_xrGetSpaceUserIdFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_user
#ifdef XRTRANSPORT_EXT_XR_FB_swapchain_update_state
    {72001, &FunctionDispatch::handle_xrGetSwapchainStateFB},
    {72002, &FunctionDispatch::handle_xrUpdateSwapchainFB},
#endif // XRTRANSPORT_EXT_XR_FB_swapchain_update_state
#ifdef XRTRANSPORT_EXT_XR_FB_triangle_mesh
    {118001, &FunctionDispatch::handle_xrCreateTriangleMeshFB},
    {118002, &FunctionDispatch::handle_xrDestroyTriangleMeshFB},
    {118003, &FunctionDispatch::handle_xrTriangleMeshBeginUpdateFB},
    {118004, &FunctionDispatch::handle_xrTriangleMeshBeginVertexBufferUpdateFB},
    {118005, &FunctionDispatch::handle_xrTriangleMeshEndUpdateFB},
    {118006, &FunctionDispatch::handle_xrTriangleMeshEndVertexBufferUpdateFB},
    {118007, &FunctionDispatch::handle_xrTriangleMeshGetIndexBufferFB},
    {118008, &FunctionDispatch::handle_xrTriangleMeshGetVertexBufferFB},
#endif // XRTRANSPORT_EXT_XR_FB_triangle_mesh
#ifdef XRTRANSPORT_EXT_XR_HTCX_vive_tracker_interaction
    {104001, &FunctionDispatch::handle_xrEnumerateViveTrackerPathsHTCX},
#endif // XRTRANSPORT_EXT_XR_HTCX_vive_tracker_interaction
#ifdef XRTRANSPORT_EXT_XR_HTC_anchor
    {320001, &FunctionDispatch::handle_xrCreateSpatialAnchorHTC},
    {320002, &FunctionDispatch::handle_xrGetSpatialAnchorNameHTC},
#endif // XRTRANSPORT_EXT_XR_HTC_anchor
#ifdef XRTRANSPORT_EXT_XR_HTC_body_tracking
    {321001, &FunctionDispatch::handle_xrCreateBodyTrackerHTC},
    {321002, &FunctionDispatch::handle_xrDestroyBodyTrackerHTC},
    {321003, &FunctionDispatch::handle_xrGetBodySkeletonHTC},
    {321004, &FunctionDispatch::handle_xrLocateBodyJointsHTC},
#endif // XRTRANSPORT_EXT_XR_HTC_body_tracking
#ifdef XRTRANSPORT_EXT_XR_HTC_facial_tracking
    {105001, &FunctionDispatch::handle_xrCreateFacialTrackerHTC},
    {105002, &FunctionDispatch::handle_xrDestroyFacialTrackerHTC},
    {105003, &FunctionDispatch::handle_xrGetFacialExpressionsHTC},
#endif // XRTRANSPORT_EXT_XR_HTC_facial_tracking
#ifdef XRTRANSPORT_EXT_XR_HTC_foveation
    {319001, &FunctionDispatch::handle_xrApplyFoveationHTC},
#endif // XRTRANSPORT_EXT_XR_HTC_foveation
#ifdef XRTRANSPORT_EXT_XR_HTC_passthrough
    {318001, &FunctionDispatch::handle_xrCreatePassthroughHTC},
    {318002, &FunctionDispatch::handle_xrDestroyPassthroughHTC},
#endif // XRTRANSPORT_EXT_XR_HTC_passthrough
#ifdef XRTRANSPORT_EXT_XR_KHR_D3D11_enable
    {28001, &FunctionDispatch::handle_xrGetD3D11GraphicsRequirementsKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_D3D11_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_D3D12_enable
    {29001, &FunctionDispatch::handle_xrGetD3D12GraphicsRequirementsKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_D3D12_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_android_surface_swapchain
    {5001, &FunctionDispatch::handle_xrCreateSwapchainAndroidSurfaceKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_android_surface_swapchain
#ifdef XRTRANSPORT_EXT_XR_KHR_android_thread_settings
    {4001, &FunctionDispatch::handle_xrSetAndroidApplicationThreadKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_android_thread_settings
#ifdef XRTRANSPORT_EXT_XR_KHR_convert_timespec_time
    {37001, &FunctionDispatch::handle_xrConvertTimeToTimespecTimeKHR},
    {37002, &FunctionDispatch::handle_xrConvertTimespecTimeToTimeKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_convert_timespec_time
#ifdef XRTRANSPORT_EXT_XR_KHR_extended_struct_name_lengths
    {149001, &FunctionDispatch::handle_xrStructureTypeToString2KHR},
#endif // XRTRANSPORT_EXT_XR_KHR_extended_struct_name_lengths
#ifdef XRTRANSPORT_EXT_XR_KHR_loader_init
    {89001, &FunctionDispatch::handle_xrInitializeLoaderKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_loader_init
#ifdef XRTRANSPORT_EXT_XR_KHR_metal_enable
    {30001, &FunctionDispatch::handle_xrGetMetalGraphicsRequirementsKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_metal_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_opengl_enable
    {24001, &FunctionDispatch::handle_xrGetOpenGLGraphicsRequirementsKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_opengl_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_opengl_es_enable
    {25001, &FunctionDispatch::handle_xrGetOpenGLESGraphicsRequirementsKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_opengl_es_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_visibility_mask
    {32001, &FunctionDispatch::handle_xrGetVisibilityMaskKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_visibility_mask
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_enable
    {26001, &FunctionDispatch::handle_xrGetVulkanDeviceExtensionsKHR},
    {26002, &FunctionDispatch::handle_xrGetVulkanGraphicsDeviceKHR},
    {26003, &FunctionDispatch::handle_xrGetVulkanGraphicsRequirementsKHR},
    {26004, &FunctionDispatch::handle_xrGetVulkanInstanceExtensionsKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_enable2
    {91001, &FunctionDispatch::handle_xrCreateVulkanDeviceKHR},
    {91002, &FunctionDispatch::handle_xrCreateVulkanInstanceKHR},
    {91003, &FunctionDispatch::handle_xrGetVulkanGraphicsDevice2KHR},
#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_enable2
#ifdef XRTRANSPORT_EXT_XR_KHR_win32_convert_performance_counter_time
    {36001, &FunctionDispatch::handle_xrConvertTimeToWin32PerformanceCounterKHR},
    {36002, &FunctionDispatch::handle_xrConvertWin32PerformanceCounterToTimeKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_win32_convert_performance_counter_time
#ifdef XRTRANSPORT_EXT_XR_META_colocation_discovery
    {572001, &FunctionDispatch::handle_xrStartColocationAdvertisementMETA},
    {572002, &FunctionDispatch::handle_xrStartColocationDiscoveryMETA},
    {572003, &FunctionDispatch::handle_xrStopColocationAdvertisementMETA},
    {572004, &FunctionDispatch::handle_xrStopColocationDiscoveryMETA},
#endif // XRTRANSPORT_EXT_XR_META_colocation_discovery
#ifdef XRTRANSPORT_EXT_XR_META_environment_depth
    {292001, &FunctionDispatch::handle_xrAcquireEnvironmentDepthImageMETA},
    {292002, &FunctionDispatch::handle_xrCreateEnvironmentDepthProviderMETA},
    {292003, &FunctionDispatch::handle_xrCreateEnvironmentDepthSwapchainMETA},
    {292004, &FunctionDispatch::handle_xrDestroyEnvironmentDepthProviderMETA},
    {292005, &FunctionDispatch::handle_xrDestroyEnvironmentDepthSwapchainMETA},
    {292006, &FunctionDispatch::handle_xrEnumerateEnvironmentDepthSwapchainImagesMETA},
    {292007, &FunctionDispatch::handle_xrGetEnvironmentDepthSwapchainStateMETA},
    {292008, &FunctionDispatch::handle_xrSetEnvironmentDepthHandRemovalMETA},
    {292009, &FunctionDispatch::handle_xrStartEnvironmentDepthProviderMETA},
    {292010, &FunctionDispatch::handle_xrStopEnvironmentDepthProviderMETA},
#endif // XRTRANSPORT_EXT_XR_META_environment_depth
#ifdef XRTRANSPORT_EXT_XR_META_foveation_eye_tracked
    {201001, &FunctionDispatch::handle_xrGetFoveationEyeTrackedStateMETA},
#endif // XRTRANSPORT_EXT_XR_META_foveation_eye_tracked
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_color_lut
    {267001, &FunctionDispatch::handle_xrCreatePassthroughColorLutMETA},
    {267002, &FunctionDispatch::handle_xrDestroyPassthroughColorLutMETA},
    {267003, &FunctionDispatch::handle_xrUpdatePassthroughColorLutMETA},
#endif // XRTRANSPORT_EXT_XR_META_passthrough_color_lut
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_preferences
    {218001, &FunctionDispatch::handle_xrGetPassthroughPreferencesMETA},
#endif // XRTRANSPORT_EXT_XR_META_passthrough_preferences
#ifdef XRTRANSPORT_EXT_XR_META_performance_metrics
    {233001, &FunctionDispatch::handle_xrEnumeratePerformanceMetricsCounterPathsMETA},
    {233002, &FunctionDispatch::handle_xrGetPerformanceMetricsStateMETA},
    {233003, &FunctionDispatch::handle_xrQueryPerformanceMetricsCounterMETA},
    {233004, &FunctionDispatch::handle_xrSetPerformanceMetricsStateMETA},
#endif // XRTRANSPORT_EXT_XR_META_performance_metrics
#ifdef XRTRANSPORT_EXT_XR_META_recommended_layer_resolution
    {255001, &FunctionDispatch::handle_xrGetRecommendedLayerResolutionMETA},
#endif // XRTRANSPORT_EXT_XR_META_recommended_layer_resolution
#ifdef XRTRANSPORT_EXT_XR_META_simultaneous_hands_and_controllers
    {533001, &FunctionDispatch::handle_xrPauseSimultaneousHandsAndControllersTrackingMETA},
    {533002, &FunctionDispatch::handle_xrResumeSimultaneousHandsAndControllersTrackingMETA},
#endif // XRTRANSPORT_EXT_XR_META_simultaneous_hands_and_controllers
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_mesh
    {270001, &FunctionDispatch::handle_xrGetSpaceTriangleMeshMETA},
#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_mesh
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_sharing
    {291001, &FunctionDispatch::handle_xrShareSpacesMETA},
#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_sharing
#ifdef XRTRANSPORT_EXT_XR_META_virtual_keyboard
    {220001, &FunctionDispatch::handle_xrChangeVirtualKeyboardTextContextMETA},
    {220002, &FunctionDispatch::handle_xrCreateVirtualKeyboardMETA},
    {220003, &FunctionDispatch::handle_xrCreateVirtualKeyboardSpaceMETA},
    {220004, &FunctionDispatch::handle_xrDestroyVirtualKeyboardMETA},
    {220005, &FunctionDispatch::handle_xrGetVirtualKeyboardDirtyTexturesMETA},
    {220006, &FunctionDispatch::handle_xrGetVirtualKeyboardModelAnimationStatesMETA},
    {220007, &FunctionDispatch::handle_xrGetVirtualKeyboardScaleMETA},
    {220008, &FunctionDispatch::handle_xrGetVirtualKeyboardTextureDataMETA},
    {220009, &FunctionDispatch::handle_xrSendVirtualKeyboardInputMETA},
    {220010, &FunctionDispatch::handle_xrSetVirtualKeyboardModelVisibilityMETA},
    {220011, &FunctionDispatch::handle_xrSuggestVirtualKeyboardLocationMETA},
#endif // XRTRANSPORT_EXT_XR_META_virtual_keyboard
#ifdef XRTRANSPORT_EXT_XR_ML_compat
    {138001, &FunctionDispatch::handle_xrCreateSpaceFromCoordinateFrameUIDML},
#endif // XRTRANSPORT_EXT_XR_ML_compat
#ifdef XRTRANSPORT_EXT_XR_ML_facial_expression
    {483001, &FunctionDispatch::handle_xrCreateFacialExpressionClientML},
    {483002, &FunctionDispatch::handle_xrDestroyFacialExpressionClientML},
    {483003, &FunctionDispatch::handle_xrGetFacialExpressionBlendShapePropertiesML},
#endif // XRTRANSPORT_EXT_XR_ML_facial_expression
#ifdef XRTRANSPORT_EXT_XR_ML_localization_map
    {140001, &FunctionDispatch::handle_xrCreateExportedLocalizationMapML},
    {140002, &FunctionDispatch::handle_xrDestroyExportedLocalizationMapML},
    {140003, &FunctionDispatch::handle_xrEnableLocalizationEventsML},
    {140004, &FunctionDispatch::handle_xrGetExportedLocalizationMapDataML},
    {140005, &FunctionDispatch::handle_xrImportLocalizationMapML},
    {140006, &FunctionDispatch::handle_xrQueryLocalizationMapsML},
    {140007, &FunctionDispatch::handle_xrRequestMapLocalizationML},
#endif // XRTRANSPORT_EXT_XR_ML_localization_map
#ifdef XRTRANSPORT_EXT_XR_ML_marker_understanding
    {139001, &FunctionDispatch::handle_xrCreateMarkerDetectorML},
    {139002, &FunctionDispatch::handle_xrCreateMarkerSpaceML},
    {139003, &FunctionDispatch::handle_xrDestroyMarkerDetectorML},
    {139004, &FunctionDispatch::handle_xrGetMarkerDetectorStateML},
    {139005, &FunctionDispatch::handle_xrGetMarkerLengthML},
    {139006, &FunctionDispatch::handle_xrGetMarkerNumberML},
    {139007, &FunctionDispatch::handle_xrGetMarkerReprojectionErrorML},
    {139008, &FunctionDispatch::handle_xrGetMarkerStringML},
    {139009, &FunctionDispatch::handle_xrGetMarkersML},
    {139010, &FunctionDispatch::handle_xrSnapshotMarkerDetectorML},
#endif // XRTRANSPORT_EXT_XR_ML_marker_understanding
#ifdef XRTRANSPORT_EXT_XR_ML_spatial_anchors
    {141001, &FunctionDispatch::handle_xrCreateSpatialAnchorsAsyncML},
    {141002, &FunctionDispatch::handle_xrCreateSpatialAnchorsCompleteML},
    {141003, &FunctionDispatch::handle_xrGetSpatialAnchorStateML},
#endif // XRTRANSPORT_EXT_XR_ML_spatial_anchors
#ifdef XRTRANSPORT_EXT_XR_ML_spatial_anchors_storage
    {142001, &FunctionDispatch::handle_xrCreateSpatialAnchorsStorageML},
    {142002, &FunctionDispatch::handle_xrDeleteSpatialAnchorsAsyncML},
    {142003, &FunctionDispatch::handle_xrDeleteSpatialAnchorsCompleteML},
    {142004, &FunctionDispatch::handle_xrDestroySpatialAnchorsStorageML},
    {142005, &FunctionDispatch::handle_xrPublishSpatialAnchorsAsyncML},
    {142006, &FunctionDispatch::handle_xrPublishSpatialAnchorsCompleteML},
    {142007, &FunctionDispatch::handle_xrQuerySpatialAnchorsAsyncML},
    {142008, &FunctionDispatch::handle_xrQuerySpatialAnchorsCompleteML},
    {142009, &FunctionDispatch::handle_xrUpdateSpatialAnchorsExpirationAsyncML},
    {142010, &FunctionDispatch::handle_xrUpdateSpatialAnchorsExpirationCompleteML},
#endif // XRTRANSPORT_EXT_XR_ML_spatial_anchors_storage
#ifdef XRTRANSPORT_EXT_XR_ML_system_notifications
    {474001, &FunctionDispatch::handle_xrSetSystemNotificationsML},
#endif // XRTRANSPORT_EXT_XR_ML_system_notifications
#ifdef XRTRANSPORT_EXT_XR_ML_user_calibration
    {473001, &FunctionDispatch::handle_xrEnableUserCalibrationEventsML},
#endif // XRTRANSPORT_EXT_XR_ML_user_calibration
#ifdef XRTRANSPORT_EXT_XR_ML_world_mesh_detection
    {475001, &FunctionDispatch::handle_xrAllocateWorldMeshBufferML},
    {475002, &FunctionDispatch::handle_xrCreateWorldMeshDetectorML},
    {475003, &FunctionDispatch::handle_xrDestroyWorldMeshDetectorML},
    {475004, &FunctionDispatch::handle_xrFreeWorldMeshBufferML},
    {475005, &FunctionDispatch::handle_xrGetWorldMeshBufferRecommendSizeML},
    {475006, &FunctionDispatch::handle_xrRequestWorldMeshAsyncML},
    {475007, &FunctionDispatch::handle_xrRequestWorldMeshCompleteML},
    {475008, &FunctionDispatch::handle_xrRequestWorldMeshStateAsyncML},
    {475009, &FunctionDispatch::handle_xrRequestWorldMeshStateCompleteML},
#endif // XRTRANSPORT_EXT_XR_ML_world_mesh_detection
#ifdef XRTRANSPORT_EXT_XR_MNDX_force_feedback_curl
    {376001, &FunctionDispatch::handle_xrApplyForceFeedbackCurlMNDX},
#endif // XRTRANSPORT_EXT_XR_MNDX_force_feedback_curl
#ifdef XRTRANSPORT_EXT_XR_MSFT_composition_layer_reprojection
    {67001, &FunctionDispatch::handle_xrEnumerateReprojectionModesMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_composition_layer_reprojection
#ifdef XRTRANSPORT_EXT_XR_MSFT_controller_model
    {56001, &FunctionDispatch::handle_xrGetControllerModelKeyMSFT},
    {56002, &FunctionDispatch::handle_xrGetControllerModelPropertiesMSFT},
    {56003, &FunctionDispatch::handle_xrGetControllerModelStateMSFT},
    {56004, &FunctionDispatch::handle_xrLoadControllerModelMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_controller_model
#ifdef XRTRANSPORT_EXT_XR_MSFT_hand_tracking_mesh
    {53001, &FunctionDispatch::handle_xrCreateHandMeshSpaceMSFT},
    {53002, &FunctionDispatch::handle_xrUpdateHandMeshMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_hand_tracking_mesh
#ifdef XRTRANSPORT_EXT_XR_MSFT_perception_anchor_interop
    {57001, &FunctionDispatch::handle_xrCreateSpatialAnchorFromPerceptionAnchorMSFT},
    {57002, &FunctionDispatch::handle_xrTryGetPerceptionAnchorFromSpatialAnchorMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_perception_anchor_interop
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_marker
    {148001, &FunctionDispatch::handle_xrGetSceneMarkerDecodedStringMSFT},
    {148002, &FunctionDispatch::handle_xrGetSceneMarkerRawDataMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_scene_marker
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_understanding
    {98001, &FunctionDispatch::handle_xrComputeNewSceneMSFT},
    {98002, &FunctionDispatch::handle_xrCreateSceneMSFT},
    {98003, &FunctionDispatch::handle_xrCreateSceneObserverMSFT},
    {98004, &FunctionDispatch::handle_xrDestroySceneMSFT},
    {98005, &FunctionDispatch::handle_xrDestroySceneObserverMSFT},
    {98006, &FunctionDispatch::handle_xrEnumerateSceneComputeFeaturesMSFT},
    {98007, &FunctionDispatch::handle_xrGetSceneComponentsMSFT},
    {98008, &FunctionDispatch::handle_xrGetSceneComputeStateMSFT},
    {98009, &FunctionDispatch::handle_xrGetSceneMeshBuffersMSFT},
    {98010, &FunctionDispatch::handle_xrLocateSceneComponentsMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_scene_understanding
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_understanding_serialization
    {99001, &FunctionDispatch::handle_xrDeserializeSceneMSFT},
    {99002, &FunctionDispatch::handle_xrGetSerializedSceneFragmentDataMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_scene_understanding_serialization
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_anchor
    {40001, &FunctionDispatch::handle_xrCreateSpatialAnchorMSFT},
    {40002, &FunctionDispatch::handle_xrCreateSpatialAnchorSpaceMSFT},
    {40003, &FunctionDispatch::handle_xrDestroySpatialAnchorMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_anchor
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_anchor_persistence
    {143001, &FunctionDispatch::handle_xrClearSpatialAnchorStoreMSFT},
    {143002, &FunctionDispatch::handle_xrCreateSpatialAnchorFromPersistedNameMSFT},
    {143003, &FunctionDispatch::handle_xrCreateSpatialAnchorStoreConnectionMSFT},
    {143004, &FunctionDispatch::handle_xrDestroySpatialAnchorStoreConnectionMSFT},
    {143005, &FunctionDispatch::handle_xrEnumeratePersistedSpatialAnchorNamesMSFT},
    {143006, &FunctionDispatch::handle_xrPersistSpatialAnchorMSFT},
    {143007, &FunctionDispatch::handle_xrUnpersistSpatialAnchorMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_anchor_persistence
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_graph_bridge
    {50001, &FunctionDispatch::handle_xrCreateSpatialGraphNodeSpaceMSFT},
    {50002, &FunctionDispatch::handle_xrDestroySpatialGraphNodeBindingMSFT},
    {50003, &FunctionDispatch::handle_xrGetSpatialGraphNodeBindingPropertiesMSFT},
    {50004, &FunctionDispatch::handle_xrTryCreateSpatialGraphStaticNodeBindingMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_graph_bridge
#ifdef XRTRANSPORT_EXT_XR_OCULUS_audio_device_guid
    {160001, &FunctionDispatch::handle_xrGetAudioInputDeviceGuidOculus},
    {160002, &FunctionDispatch::handle_xrGetAudioOutputDeviceGuidOculus},
#endif // XRTRANSPORT_EXT_XR_OCULUS_audio_device_guid
#ifdef XRTRANSPORT_EXT_XR_OCULUS_external_camera
    {227001, &FunctionDispatch::handle_xrEnumerateExternalCamerasOCULUS},
#endif // XRTRANSPORT_EXT_XR_OCULUS_external_camera
#ifdef XRTRANSPORT_EXT_XR_QCOM_tracking_optimization_settings
    {307001, &FunctionDispatch::handle_xrSetTrackingOptimizationSettingsHintQCOM},
#endif // XRTRANSPORT_EXT_XR_QCOM_tracking_optimization_settings
#ifdef XRTRANSPORT_EXT_XR_VARJO_environment_depth_estimation
    {124001, &FunctionDispatch::handle_xrSetEnvironmentDepthEstimationVARJO},
#endif // XRTRANSPORT_EXT_XR_VARJO_environment_depth_estimation
#ifdef XRTRANSPORT_EXT_XR_VARJO_marker_tracking
    {125001, &FunctionDispatch::handle_xrCreateMarkerSpaceVARJO},
    {125002, &FunctionDispatch::handle_xrGetMarkerSizeVARJO},
    {125003, &FunctionDispatch::handle_xrSetMarkerTrackingPredictionVARJO},
    {125004, &FunctionDispatch::handle_xrSetMarkerTrackingTimeoutVARJO},
    {125005, &FunctionDispatch::handle_xrSetMarkerTrackingVARJO},
#endif // XRTRANSPORT_EXT_XR_VARJO_marker_tracking
#ifdef XRTRANSPORT_EXT_XR_VARJO_view_offset
    {126001, &FunctionDispatch::handle_xrSetViewOffsetVARJO},
#endif // XRTRANSPORT_EXT_XR_VARJO_view_offset
    {1, &FunctionDispatch::handle_xrAcquireSwapchainImage},
    {2, &FunctionDispatch::handle_xrApplyHapticFeedback},
    {3, &FunctionDispatch::handle_xrAttachSessionActionSets},
    {4, &FunctionDispatch::handle_xrBeginFrame},
    {5, &FunctionDispatch::handle_xrBeginSession},
    {6, &FunctionDispatch::handle_xrCreateAction},
    {7, &FunctionDispatch::handle_xrCreateActionSet},
    {8, &FunctionDispatch::handle_xrCreateActionSpace},
    {9, &FunctionDispatch::handle_xrCreateInstance},
    {10, &FunctionDispatch::handle_xrCreateReferenceSpace},
    {11, &FunctionDispatch::handle_xrCreateSession},
    {12, &FunctionDispatch::handle_xrCreateSwapchain},
    {13, &FunctionDispatch::handle_xrDestroyAction},
    {14, &FunctionDispatch::handle_xrDestroyActionSet},
    {15, &FunctionDispatch::handle_xrDestroyInstance},
    {16, &FunctionDispatch::handle_xrDestroySession},
    {17, &FunctionDispatch::handle_xrDestroySpace},
    {18, &FunctionDispatch::handle_xrDestroySwapchain},
    {19, &FunctionDispatch::handle_xrEndFrame},
    {20, &FunctionDispatch::handle_xrEndSession},
    {21, &FunctionDispatch::handle_xrEnumerateApiLayerProperties},
    {22, &FunctionDispatch::handle_xrEnumerateBoundSourcesForAction},
    {23, &FunctionDispatch::handle_xrEnumerateEnvironmentBlendModes},
    {24, &FunctionDispatch::handle_xrEnumerateInstanceExtensionProperties},
    {25, &FunctionDispatch::handle_xrEnumerateReferenceSpaces},
    {26, &FunctionDispatch::handle_xrEnumerateSwapchainFormats},
    {27, &FunctionDispatch::handle_xrEnumerateSwapchainImages},
    {28, &FunctionDispatch::handle_xrEnumerateViewConfigurationViews},
    {29, &FunctionDispatch::handle_xrEnumerateViewConfigurations},
    {30, &FunctionDispatch::handle_xrGetActionStateBoolean},
    {31, &FunctionDispatch::handle_xrGetActionStateFloat},
    {32, &FunctionDispatch::handle_xrGetActionStatePose},
    {33, &FunctionDispatch::handle_xrGetActionStateVector2f},
    {34, &FunctionDispatch::handle_xrGetCurrentInteractionProfile},
    {35, &FunctionDispatch::handle_xrGetInputSourceLocalizedName},
    {36, &FunctionDispatch::handle_xrGetInstanceProperties},
    {37, &FunctionDispatch::handle_xrGetReferenceSpaceBoundsRect},
    {38, &FunctionDispatch::handle_xrGetSystem},
    {39, &FunctionDispatch::handle_xrGetSystemProperties},
    {40, &FunctionDispatch::handle_xrGetViewConfigurationProperties},
    {41, &FunctionDispatch::handle_xrLocateSpace},
    {42, &FunctionDispatch::handle_xrLocateSpaces},
    {43, &FunctionDispatch::handle_xrLocateViews},
    {44, &FunctionDispatch::handle_xrPathToString},
    {45, &FunctionDispatch::handle_xrPollEvent},
    {46, &FunctionDispatch::handle_xrReleaseSwapchainImage},
    {47, &FunctionDispatch::handle_xrRequestExitSession},
    {48, &FunctionDispatch::handle_xrResultToString},
    {49, &FunctionDispatch::handle_xrStopHapticFeedback},
    {50, &FunctionDispatch::handle_xrStringToPath},
    {51, &FunctionDispatch::handle_xrStructureTypeToString},
    {52, &FunctionDispatch::handle_xrSuggestInteractionProfileBindings},
    {53, &FunctionDispatch::handle_xrSyncActions},
    {54, &FunctionDispatch::handle_xrWaitFrame},
    {55, &FunctionDispatch::handle_xrWaitSwapchainImage},

};

} // namespace xrtransport
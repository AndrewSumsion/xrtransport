/*
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file was automatically generated by the code_generation module.
 * Any changes made to this file will be lost when regenerated.
 *
 * To modify this file, edit the corresponding template in:
 * code_generation/templates/server/function_dispatch_impl.mako
 */
#include "function_dispatch.h"

#include "xrtransport/server/function_loader.h"
#include "xrtransport/transport/transport.h"
#include "xrtransport/serialization/serializer.h"
#include "xrtransport/serialization/deserializer.h"
#include "xrtransport/util.h"
#include "xrtransport/time.h"

#include "openxr/openxr.h"

#include <spdlog/spdlog.h>

#include <unordered_map>
#include <string>

using std::uint32_t;

namespace xrtransport {

static XrTime start_runtime_timer() {
    return get_time();
}

static XrDuration end_runtime_timer(XrTime start_time) {
    return get_time() - start_time;
}

#ifdef XRTRANSPORT_EXT_XR_ALMALENCE_digital_lens_control
void FunctionDispatch::handle_xrSetDigitalLensControlALMALENCE(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetDigitalLensControlALMALENCE", function_loader.SetDigitalLensControlALMALENCE);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrDigitalLensControlALMALENCE* digitalLensControl{};
    deserialize_ptr(&digitalLensControl, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetDigitalLensControlALMALENCE(session, digitalLensControl);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(digitalLensControl, 1);
}

#endif // XRTRANSPORT_EXT_XR_ALMALENCE_digital_lens_control
#ifdef XRTRANSPORT_EXT_XR_BD_body_tracking
void FunctionDispatch::handle_xrCreateBodyTrackerBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateBodyTrackerBD", function_loader.CreateBodyTrackerBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrBodyTrackerCreateInfoBD* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrBodyTrackerBD* bodyTracker{};
    deserialize_ptr(&bodyTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateBodyTrackerBD(session, createInfo, bodyTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bodyTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(bodyTracker, 1);
}

void FunctionDispatch::handle_xrDestroyBodyTrackerBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyBodyTrackerBD", function_loader.DestroyBodyTrackerBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrBodyTrackerBD bodyTracker{};
    deserialize(&bodyTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyBodyTrackerBD(bodyTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
}

void FunctionDispatch::handle_xrLocateBodyJointsBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateBodyJointsBD", function_loader.LocateBodyJointsBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrBodyTrackerBD bodyTracker{};
    deserialize(&bodyTracker, d_ctx);
    XrBodyJointsLocateInfoBD* locateInfo{};
    deserialize_ptr(&locateInfo, d_ctx);
    XrBodyJointLocationsBD* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.LocateBodyJointsBD(bodyTracker, locateInfo, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations, 1, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
    cleanup_ptr(locateInfo, 1);
    cleanup_ptr(locations, 1);
}

#endif // XRTRANSPORT_EXT_XR_BD_body_tracking
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_anchor
void FunctionDispatch::handle_xrCreateSpatialAnchorAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorAsyncBD", function_loader.CreateSpatialAnchorAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSpatialAnchorCreateInfoBD* info{};
    deserialize_ptr(&info, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialAnchorAsyncBD(provider, info, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(info, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrCreateSpatialAnchorCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorCompleteBD", function_loader.CreateSpatialAnchorCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrSpatialAnchorCreateCompletionBD* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialAnchorCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrPersistSpatialAnchorAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPersistSpatialAnchorAsyncBD", function_loader.PersistSpatialAnchorAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSpatialAnchorPersistInfoBD* info{};
    deserialize_ptr(&info, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PersistSpatialAnchorAsyncBD(provider, info, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(info, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrPersistSpatialAnchorCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPersistSpatialAnchorCompleteBD", function_loader.PersistSpatialAnchorCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrFutureCompletionEXT* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PersistSpatialAnchorCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrUnpersistSpatialAnchorAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUnpersistSpatialAnchorAsyncBD", function_loader.UnpersistSpatialAnchorAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSpatialAnchorUnpersistInfoBD* info{};
    deserialize_ptr(&info, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.UnpersistSpatialAnchorAsyncBD(provider, info, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(info, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrUnpersistSpatialAnchorCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUnpersistSpatialAnchorCompleteBD", function_loader.UnpersistSpatialAnchorCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrFutureCompletionEXT* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.UnpersistSpatialAnchorCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

#endif // XRTRANSPORT_EXT_XR_BD_spatial_anchor
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_anchor_sharing
void FunctionDispatch::handle_xrDownloadSharedSpatialAnchorAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDownloadSharedSpatialAnchorAsyncBD", function_loader.DownloadSharedSpatialAnchorAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSharedSpatialAnchorDownloadInfoBD* info{};
    deserialize_ptr(&info, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DownloadSharedSpatialAnchorAsyncBD(provider, info, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(info, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrDownloadSharedSpatialAnchorCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDownloadSharedSpatialAnchorCompleteBD", function_loader.DownloadSharedSpatialAnchorCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrFutureCompletionEXT* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DownloadSharedSpatialAnchorCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrShareSpatialAnchorAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrShareSpatialAnchorAsyncBD", function_loader.ShareSpatialAnchorAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSpatialAnchorShareInfoBD* info{};
    deserialize_ptr(&info, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ShareSpatialAnchorAsyncBD(provider, info, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(info, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrShareSpatialAnchorCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrShareSpatialAnchorCompleteBD", function_loader.ShareSpatialAnchorCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrFutureCompletionEXT* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ShareSpatialAnchorCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

#endif // XRTRANSPORT_EXT_XR_BD_spatial_anchor_sharing
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_scene
void FunctionDispatch::handle_xrCaptureSceneAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCaptureSceneAsyncBD", function_loader.CaptureSceneAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSceneCaptureInfoBD* info{};
    deserialize_ptr(&info, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CaptureSceneAsyncBD(provider, info, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(info, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrCaptureSceneCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCaptureSceneCompleteBD", function_loader.CaptureSceneCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrFutureCompletionEXT* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CaptureSceneCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

#endif // XRTRANSPORT_EXT_XR_BD_spatial_scene
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_sensing
void FunctionDispatch::handle_xrCreateAnchorSpaceBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateAnchorSpaceBD", function_loader.CreateAnchorSpaceBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrAnchorSpaceCreateInfoBD* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateAnchorSpaceBD(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrCreateSenseDataProviderBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSenseDataProviderBD", function_loader.CreateSenseDataProviderBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSenseDataProviderCreateInfoBD* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSenseDataProviderBD* provider{};
    deserialize_ptr(&provider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSenseDataProviderBD(session, createInfo, provider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(provider, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(provider, 1);
}

void FunctionDispatch::handle_xrCreateSpatialEntityAnchorBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialEntityAnchorBD", function_loader.CreateSpatialEntityAnchorBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSpatialEntityAnchorCreateInfoBD* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrAnchorBD* anchor{};
    deserialize_ptr(&anchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialEntityAnchorBD(provider, createInfo, anchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(anchor, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(anchor, 1);
}

void FunctionDispatch::handle_xrDestroyAnchorBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyAnchorBD", function_loader.DestroyAnchorBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrAnchorBD anchor{};
    deserialize(&anchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyAnchorBD(anchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&anchor);
}

void FunctionDispatch::handle_xrDestroySenseDataProviderBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySenseDataProviderBD", function_loader.DestroySenseDataProviderBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroySenseDataProviderBD(provider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&provider);
}

void FunctionDispatch::handle_xrDestroySenseDataSnapshotBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySenseDataSnapshotBD", function_loader.DestroySenseDataSnapshotBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataSnapshotBD snapshot{};
    deserialize(&snapshot, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroySenseDataSnapshotBD(snapshot);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&snapshot);
}

void FunctionDispatch::handle_xrEnumerateSpatialEntityComponentTypesBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateSpatialEntityComponentTypesBD", function_loader.EnumerateSpatialEntityComponentTypesBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataSnapshotBD snapshot{};
    deserialize(&snapshot, d_ctx);
    XrSpatialEntityIdBD entityId{};
    deserialize(&entityId, d_ctx);
    uint32_t componentTypeCapacityInput{};
    deserialize(&componentTypeCapacityInput, d_ctx);
    uint32_t* componentTypeCountOutput{};
    deserialize_ptr(&componentTypeCountOutput, d_ctx);
    XrSpatialEntityComponentTypeBD* componentTypes{};
    deserialize_ptr(&componentTypes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateSpatialEntityComponentTypesBD(snapshot, entityId, componentTypeCapacityInput, componentTypeCountOutput, componentTypes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(componentTypeCountOutput, 1, s_ctx);
    serialize_ptr(componentTypes, componentTypeCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&snapshot);
    cleanup(&entityId);
    cleanup(&componentTypeCapacityInput);
    cleanup_ptr(componentTypeCountOutput, 1);
    cleanup_ptr(componentTypes, componentTypeCapacityInput);
}

void FunctionDispatch::handle_xrGetAnchorUuidBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetAnchorUuidBD", function_loader.GetAnchorUuidBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrAnchorBD anchor{};
    deserialize(&anchor, d_ctx);
    XrUuidEXT* uuid{};
    deserialize_ptr(&uuid, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetAnchorUuidBD(anchor, uuid);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(uuid, 1, s_ctx);
    msg_out.flush();

    cleanup(&anchor);
    cleanup_ptr(uuid, 1);
}

void FunctionDispatch::handle_xrGetQueriedSenseDataBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetQueriedSenseDataBD", function_loader.GetQueriedSenseDataBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataSnapshotBD snapshot{};
    deserialize(&snapshot, d_ctx);
    XrQueriedSenseDataGetInfoBD* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrQueriedSenseDataBD* queriedSenseData{};
    deserialize_ptr(&queriedSenseData, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetQueriedSenseDataBD(snapshot, getInfo, queriedSenseData);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(getInfo, 1, s_ctx);
    serialize_ptr(queriedSenseData, 1, s_ctx);
    msg_out.flush();

    cleanup(&snapshot);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(queriedSenseData, 1);
}

void FunctionDispatch::handle_xrGetSenseDataProviderStateBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSenseDataProviderStateBD", function_loader.GetSenseDataProviderStateBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSenseDataProviderStateBD* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSenseDataProviderStateBD(provider, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetSpatialEntityComponentDataBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpatialEntityComponentDataBD", function_loader.GetSpatialEntityComponentDataBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataSnapshotBD snapshot{};
    deserialize(&snapshot, d_ctx);
    XrSpatialEntityComponentGetInfoBD* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrSpatialEntityComponentDataBaseHeaderBD* componentData{};
    deserialize_xr(&componentData, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpatialEntityComponentDataBD(snapshot, getInfo, componentData);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(componentData, s_ctx);
    msg_out.flush();

    cleanup(&snapshot);
    cleanup_ptr(getInfo, 1);
    cleanup_xr(componentData);
}

void FunctionDispatch::handle_xrGetSpatialEntityUuidBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpatialEntityUuidBD", function_loader.GetSpatialEntityUuidBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataSnapshotBD snapshot{};
    deserialize(&snapshot, d_ctx);
    XrSpatialEntityIdBD entityId{};
    deserialize(&entityId, d_ctx);
    XrUuidEXT* uuid{};
    deserialize_ptr(&uuid, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpatialEntityUuidBD(snapshot, entityId, uuid);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(uuid, 1, s_ctx);
    msg_out.flush();

    cleanup(&snapshot);
    cleanup(&entityId);
    cleanup_ptr(uuid, 1);
}

void FunctionDispatch::handle_xrQuerySenseDataAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQuerySenseDataAsyncBD", function_loader.QuerySenseDataAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSenseDataQueryInfoBD* queryInfo{};
    deserialize_ptr(&queryInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.QuerySenseDataAsyncBD(provider, queryInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(queryInfo, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrQuerySenseDataCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQuerySenseDataCompleteBD", function_loader.QuerySenseDataCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrSenseDataQueryCompletionBD* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.QuerySenseDataCompleteBD(provider, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrStartSenseDataProviderAsyncBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStartSenseDataProviderAsyncBD", function_loader.StartSenseDataProviderAsyncBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);
    XrSenseDataProviderStartInfoBD* startInfo{};
    deserialize_ptr(&startInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.StartSenseDataProviderAsyncBD(provider, startInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&provider);
    cleanup_ptr(startInfo, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrStartSenseDataProviderCompleteBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStartSenseDataProviderCompleteBD", function_loader.StartSenseDataProviderCompleteBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrFutureCompletionEXT* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.StartSenseDataProviderCompleteBD(session, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrStopSenseDataProviderBD(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStopSenseDataProviderBD", function_loader.StopSenseDataProviderBD);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSenseDataProviderBD provider{};
    deserialize(&provider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.StopSenseDataProviderBD(provider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&provider);
}

#endif // XRTRANSPORT_EXT_XR_BD_spatial_sensing
#ifdef XRTRANSPORT_EXT_XR_EXT_conformance_automation
void FunctionDispatch::handle_xrSetInputDeviceActiveEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetInputDeviceActiveEXT", function_loader.SetInputDeviceActiveEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath interactionProfile{};
    deserialize(&interactionProfile, d_ctx);
    XrPath topLevelPath{};
    deserialize(&topLevelPath, d_ctx);
    XrBool32 isActive{};
    deserialize(&isActive, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetInputDeviceActiveEXT(session, interactionProfile, topLevelPath, isActive);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&interactionProfile);
    cleanup(&topLevelPath);
    cleanup(&isActive);
}

void FunctionDispatch::handle_xrSetInputDeviceLocationEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetInputDeviceLocationEXT", function_loader.SetInputDeviceLocationEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath topLevelPath{};
    deserialize(&topLevelPath, d_ctx);
    XrPath inputSourcePath{};
    deserialize(&inputSourcePath, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrPosef pose{};
    deserialize(&pose, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetInputDeviceLocationEXT(session, topLevelPath, inputSourcePath, space, pose);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&topLevelPath);
    cleanup(&inputSourcePath);
    cleanup(&space);
    cleanup(&pose);
}

void FunctionDispatch::handle_xrSetInputDeviceStateBoolEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetInputDeviceStateBoolEXT", function_loader.SetInputDeviceStateBoolEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath topLevelPath{};
    deserialize(&topLevelPath, d_ctx);
    XrPath inputSourcePath{};
    deserialize(&inputSourcePath, d_ctx);
    XrBool32 state{};
    deserialize(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetInputDeviceStateBoolEXT(session, topLevelPath, inputSourcePath, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&topLevelPath);
    cleanup(&inputSourcePath);
    cleanup(&state);
}

void FunctionDispatch::handle_xrSetInputDeviceStateFloatEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetInputDeviceStateFloatEXT", function_loader.SetInputDeviceStateFloatEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath topLevelPath{};
    deserialize(&topLevelPath, d_ctx);
    XrPath inputSourcePath{};
    deserialize(&inputSourcePath, d_ctx);
    float state{};
    deserialize(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetInputDeviceStateFloatEXT(session, topLevelPath, inputSourcePath, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&topLevelPath);
    cleanup(&inputSourcePath);
    cleanup(&state);
}

void FunctionDispatch::handle_xrSetInputDeviceStateVector2fEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetInputDeviceStateVector2fEXT", function_loader.SetInputDeviceStateVector2fEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath topLevelPath{};
    deserialize(&topLevelPath, d_ctx);
    XrPath inputSourcePath{};
    deserialize(&inputSourcePath, d_ctx);
    XrVector2f state{};
    deserialize(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetInputDeviceStateVector2fEXT(session, topLevelPath, inputSourcePath, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&topLevelPath);
    cleanup(&inputSourcePath);
    cleanup(&state);
}

#endif // XRTRANSPORT_EXT_XR_EXT_conformance_automation
#ifdef XRTRANSPORT_EXT_XR_EXT_debug_utils
void FunctionDispatch::handle_xrCreateDebugUtilsMessengerEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateDebugUtilsMessengerEXT", function_loader.CreateDebugUtilsMessengerEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrDebugUtilsMessengerCreateInfoEXT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrDebugUtilsMessengerEXT* messenger{};
    deserialize_ptr(&messenger, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateDebugUtilsMessengerEXT(instance, createInfo, messenger);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(createInfo->userData, 1, s_ctx);
    serialize_ptr(messenger, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(messenger, 1);
}

void FunctionDispatch::handle_xrDestroyDebugUtilsMessengerEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyDebugUtilsMessengerEXT", function_loader.DestroyDebugUtilsMessengerEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrDebugUtilsMessengerEXT messenger{};
    deserialize(&messenger, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyDebugUtilsMessengerEXT(messenger);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&messenger);
}

void FunctionDispatch::handle_xrSessionBeginDebugUtilsLabelRegionEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSessionBeginDebugUtilsLabelRegionEXT", function_loader.SessionBeginDebugUtilsLabelRegionEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrDebugUtilsLabelEXT* labelInfo{};
    deserialize_ptr(&labelInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SessionBeginDebugUtilsLabelRegionEXT(session, labelInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(labelInfo, 1);
}

void FunctionDispatch::handle_xrSessionEndDebugUtilsLabelRegionEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSessionEndDebugUtilsLabelRegionEXT", function_loader.SessionEndDebugUtilsLabelRegionEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SessionEndDebugUtilsLabelRegionEXT(session);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
}

void FunctionDispatch::handle_xrSessionInsertDebugUtilsLabelEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSessionInsertDebugUtilsLabelEXT", function_loader.SessionInsertDebugUtilsLabelEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrDebugUtilsLabelEXT* labelInfo{};
    deserialize_ptr(&labelInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SessionInsertDebugUtilsLabelEXT(session, labelInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(labelInfo, 1);
}

void FunctionDispatch::handle_xrSetDebugUtilsObjectNameEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetDebugUtilsObjectNameEXT", function_loader.SetDebugUtilsObjectNameEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrDebugUtilsObjectNameInfoEXT* nameInfo{};
    deserialize_ptr(&nameInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetDebugUtilsObjectNameEXT(instance, nameInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(nameInfo, 1);
}

void FunctionDispatch::handle_xrSubmitDebugUtilsMessageEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSubmitDebugUtilsMessageEXT", function_loader.SubmitDebugUtilsMessageEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrDebugUtilsMessageSeverityFlagsEXT messageSeverity{};
    deserialize(&messageSeverity, d_ctx);
    XrDebugUtilsMessageTypeFlagsEXT messageTypes{};
    deserialize(&messageTypes, d_ctx);
    XrDebugUtilsMessengerCallbackDataEXT* callbackData{};
    deserialize_ptr(&callbackData, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SubmitDebugUtilsMessageEXT(instance, messageSeverity, messageTypes, callbackData);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(callbackData->objects, callbackData->objectCount, s_ctx);
    serialize_ptr(callbackData->sessionLabels, callbackData->sessionLabelCount, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&messageSeverity);
    cleanup(&messageTypes);
    cleanup_ptr(callbackData, 1);
}

#endif // XRTRANSPORT_EXT_XR_EXT_debug_utils
#ifdef XRTRANSPORT_EXT_XR_EXT_future
void FunctionDispatch::handle_xrCancelFutureEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCancelFutureEXT", function_loader.CancelFutureEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrFutureCancelInfoEXT* cancelInfo{};
    deserialize_ptr(&cancelInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CancelFutureEXT(instance, cancelInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(cancelInfo, 1);
}

void FunctionDispatch::handle_xrPollFutureEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPollFutureEXT", function_loader.PollFutureEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrFuturePollInfoEXT* pollInfo{};
    deserialize_ptr(&pollInfo, d_ctx);
    XrFuturePollResultEXT* pollResult{};
    deserialize_ptr(&pollResult, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PollFutureEXT(instance, pollInfo, pollResult);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(pollResult, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(pollInfo, 1);
    cleanup_ptr(pollResult, 1);
}

#endif // XRTRANSPORT_EXT_XR_EXT_future
#ifdef XRTRANSPORT_EXT_XR_EXT_hand_tracking
void FunctionDispatch::handle_xrCreateHandTrackerEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateHandTrackerEXT", function_loader.CreateHandTrackerEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrHandTrackerCreateInfoEXT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrHandTrackerEXT* handTracker{};
    deserialize_ptr(&handTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateHandTrackerEXT(session, createInfo, handTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(handTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(handTracker, 1);
}

void FunctionDispatch::handle_xrDestroyHandTrackerEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyHandTrackerEXT", function_loader.DestroyHandTrackerEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrHandTrackerEXT handTracker{};
    deserialize(&handTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyHandTrackerEXT(handTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&handTracker);
}

void FunctionDispatch::handle_xrLocateHandJointsEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateHandJointsEXT", function_loader.LocateHandJointsEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrHandTrackerEXT handTracker{};
    deserialize(&handTracker, d_ctx);
    XrHandJointsLocateInfoEXT* locateInfo{};
    deserialize_ptr(&locateInfo, d_ctx);
    XrHandJointLocationsEXT* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.LocateHandJointsEXT(handTracker, locateInfo, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations, 1, s_ctx);
    msg_out.flush();

    cleanup(&handTracker);
    cleanup_ptr(locateInfo, 1);
    cleanup_ptr(locations, 1);
}

#endif // XRTRANSPORT_EXT_XR_EXT_hand_tracking
#ifdef XRTRANSPORT_EXT_XR_EXT_performance_settings
void FunctionDispatch::handle_xrPerfSettingsSetPerformanceLevelEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPerfSettingsSetPerformanceLevelEXT", function_loader.PerfSettingsSetPerformanceLevelEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPerfSettingsDomainEXT domain{};
    deserialize(&domain, d_ctx);
    XrPerfSettingsLevelEXT level{};
    deserialize(&level, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PerfSettingsSetPerformanceLevelEXT(session, domain, level);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&domain);
    cleanup(&level);
}

#endif // XRTRANSPORT_EXT_XR_EXT_performance_settings
#ifdef XRTRANSPORT_EXT_XR_EXT_plane_detection
void FunctionDispatch::handle_xrBeginPlaneDetectionEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrBeginPlaneDetectionEXT", function_loader.BeginPlaneDetectionEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPlaneDetectorEXT planeDetector{};
    deserialize(&planeDetector, d_ctx);
    XrPlaneDetectorBeginInfoEXT* beginInfo{};
    deserialize_ptr(&beginInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.BeginPlaneDetectionEXT(planeDetector, beginInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&planeDetector);
    cleanup_ptr(beginInfo, 1);
}

void FunctionDispatch::handle_xrCreatePlaneDetectorEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreatePlaneDetectorEXT", function_loader.CreatePlaneDetectorEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPlaneDetectorCreateInfoEXT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrPlaneDetectorEXT* planeDetector{};
    deserialize_ptr(&planeDetector, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreatePlaneDetectorEXT(session, createInfo, planeDetector);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(planeDetector, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(planeDetector, 1);
}

void FunctionDispatch::handle_xrDestroyPlaneDetectorEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyPlaneDetectorEXT", function_loader.DestroyPlaneDetectorEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPlaneDetectorEXT planeDetector{};
    deserialize(&planeDetector, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyPlaneDetectorEXT(planeDetector);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&planeDetector);
}

void FunctionDispatch::handle_xrGetPlaneDetectionStateEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetPlaneDetectionStateEXT", function_loader.GetPlaneDetectionStateEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPlaneDetectorEXT planeDetector{};
    deserialize(&planeDetector, d_ctx);
    XrPlaneDetectionStateEXT* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetPlaneDetectionStateEXT(planeDetector, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&planeDetector);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetPlaneDetectionsEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetPlaneDetectionsEXT", function_loader.GetPlaneDetectionsEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPlaneDetectorEXT planeDetector{};
    deserialize(&planeDetector, d_ctx);
    XrPlaneDetectorGetInfoEXT* info{};
    deserialize_ptr(&info, d_ctx);
    XrPlaneDetectorLocationsEXT* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetPlaneDetectionsEXT(planeDetector, info, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations, 1, s_ctx);
    msg_out.flush();

    cleanup(&planeDetector);
    cleanup_ptr(info, 1);
    cleanup_ptr(locations, 1);
}

void FunctionDispatch::handle_xrGetPlanePolygonBufferEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetPlanePolygonBufferEXT", function_loader.GetPlanePolygonBufferEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPlaneDetectorEXT planeDetector{};
    deserialize(&planeDetector, d_ctx);
    uint64_t planeId{};
    deserialize(&planeId, d_ctx);
    uint32_t polygonBufferIndex{};
    deserialize(&polygonBufferIndex, d_ctx);
    XrPlaneDetectorPolygonBufferEXT* polygonBuffer{};
    deserialize_ptr(&polygonBuffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetPlanePolygonBufferEXT(planeDetector, planeId, polygonBufferIndex, polygonBuffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(polygonBuffer, 1, s_ctx);
    msg_out.flush();

    cleanup(&planeDetector);
    cleanup(&planeId);
    cleanup(&polygonBufferIndex);
    cleanup_ptr(polygonBuffer, 1);
}

#endif // XRTRANSPORT_EXT_XR_EXT_plane_detection
#ifdef XRTRANSPORT_EXT_XR_EXT_thermal_query
void FunctionDispatch::handle_xrThermalGetTemperatureTrendEXT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrThermalGetTemperatureTrendEXT", function_loader.ThermalGetTemperatureTrendEXT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPerfSettingsDomainEXT domain{};
    deserialize(&domain, d_ctx);
    XrPerfSettingsNotificationLevelEXT* notificationLevel{};
    deserialize_ptr(&notificationLevel, d_ctx);
    float* tempHeadroom{};
    deserialize_ptr(&tempHeadroom, d_ctx);
    float* tempSlope{};
    deserialize_ptr(&tempSlope, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ThermalGetTemperatureTrendEXT(session, domain, notificationLevel, tempHeadroom, tempSlope);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(notificationLevel, 1, s_ctx);
    serialize_ptr(tempHeadroom, 1, s_ctx);
    serialize_ptr(tempSlope, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&domain);
    cleanup_ptr(notificationLevel, 1);
    cleanup_ptr(tempHeadroom, 1);
    cleanup_ptr(tempSlope, 1);
}

#endif // XRTRANSPORT_EXT_XR_EXT_thermal_query
#ifdef XRTRANSPORT_EXT_XR_FB_body_tracking
void FunctionDispatch::handle_xrCreateBodyTrackerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateBodyTrackerFB", function_loader.CreateBodyTrackerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrBodyTrackerCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrBodyTrackerFB* bodyTracker{};
    deserialize_ptr(&bodyTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateBodyTrackerFB(session, createInfo, bodyTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bodyTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(bodyTracker, 1);
}

void FunctionDispatch::handle_xrDestroyBodyTrackerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyBodyTrackerFB", function_loader.DestroyBodyTrackerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrBodyTrackerFB bodyTracker{};
    deserialize(&bodyTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyBodyTrackerFB(bodyTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
}

void FunctionDispatch::handle_xrGetBodySkeletonFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetBodySkeletonFB", function_loader.GetBodySkeletonFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrBodyTrackerFB bodyTracker{};
    deserialize(&bodyTracker, d_ctx);
    XrBodySkeletonFB* skeleton{};
    deserialize_ptr(&skeleton, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetBodySkeletonFB(bodyTracker, skeleton);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(skeleton, 1, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
    cleanup_ptr(skeleton, 1);
}

void FunctionDispatch::handle_xrLocateBodyJointsFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateBodyJointsFB", function_loader.LocateBodyJointsFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrBodyTrackerFB bodyTracker{};
    deserialize(&bodyTracker, d_ctx);
    XrBodyJointsLocateInfoFB* locateInfo{};
    deserialize_ptr(&locateInfo, d_ctx);
    XrBodyJointLocationsFB* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.LocateBodyJointsFB(bodyTracker, locateInfo, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations, 1, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
    cleanup_ptr(locateInfo, 1);
    cleanup_ptr(locations, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_body_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_color_space
void FunctionDispatch::handle_xrEnumerateColorSpacesFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateColorSpacesFB", function_loader.EnumerateColorSpacesFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint32_t colorSpaceCapacityInput{};
    deserialize(&colorSpaceCapacityInput, d_ctx);
    uint32_t* colorSpaceCountOutput{};
    deserialize_ptr(&colorSpaceCountOutput, d_ctx);
    XrColorSpaceFB* colorSpaces{};
    deserialize_ptr(&colorSpaces, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateColorSpacesFB(session, colorSpaceCapacityInput, colorSpaceCountOutput, colorSpaces);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(colorSpaceCountOutput, 1, s_ctx);
    serialize_ptr(colorSpaces, colorSpaceCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&colorSpaceCapacityInput);
    cleanup_ptr(colorSpaceCountOutput, 1);
    cleanup_ptr(colorSpaces, colorSpaceCapacityInput);
}

void FunctionDispatch::handle_xrSetColorSpaceFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetColorSpaceFB", function_loader.SetColorSpaceFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrColorSpaceFB colorSpace{};
    deserialize(&colorSpace, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetColorSpaceFB(session, colorSpace);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&colorSpace);
}

#endif // XRTRANSPORT_EXT_XR_FB_color_space
#ifdef XRTRANSPORT_EXT_XR_FB_display_refresh_rate
void FunctionDispatch::handle_xrEnumerateDisplayRefreshRatesFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateDisplayRefreshRatesFB", function_loader.EnumerateDisplayRefreshRatesFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint32_t displayRefreshRateCapacityInput{};
    deserialize(&displayRefreshRateCapacityInput, d_ctx);
    uint32_t* displayRefreshRateCountOutput{};
    deserialize_ptr(&displayRefreshRateCountOutput, d_ctx);
    float* displayRefreshRates{};
    deserialize_ptr(&displayRefreshRates, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateDisplayRefreshRatesFB(session, displayRefreshRateCapacityInput, displayRefreshRateCountOutput, displayRefreshRates);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(displayRefreshRateCountOutput, 1, s_ctx);
    serialize_ptr(displayRefreshRates, displayRefreshRateCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&displayRefreshRateCapacityInput);
    cleanup_ptr(displayRefreshRateCountOutput, 1);
    cleanup_ptr(displayRefreshRates, displayRefreshRateCapacityInput);
}

void FunctionDispatch::handle_xrGetDisplayRefreshRateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetDisplayRefreshRateFB", function_loader.GetDisplayRefreshRateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    float* displayRefreshRate{};
    deserialize_ptr(&displayRefreshRate, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetDisplayRefreshRateFB(session, displayRefreshRate);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(displayRefreshRate, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(displayRefreshRate, 1);
}

void FunctionDispatch::handle_xrRequestDisplayRefreshRateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestDisplayRefreshRateFB", function_loader.RequestDisplayRefreshRateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    float displayRefreshRate{};
    deserialize(&displayRefreshRate, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.RequestDisplayRefreshRateFB(session, displayRefreshRate);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&displayRefreshRate);
}

#endif // XRTRANSPORT_EXT_XR_FB_display_refresh_rate
#ifdef XRTRANSPORT_EXT_XR_FB_eye_tracking_social
void FunctionDispatch::handle_xrCreateEyeTrackerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateEyeTrackerFB", function_loader.CreateEyeTrackerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrEyeTrackerCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrEyeTrackerFB* eyeTracker{};
    deserialize_ptr(&eyeTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateEyeTrackerFB(session, createInfo, eyeTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(eyeTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(eyeTracker, 1);
}

void FunctionDispatch::handle_xrDestroyEyeTrackerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyEyeTrackerFB", function_loader.DestroyEyeTrackerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrEyeTrackerFB eyeTracker{};
    deserialize(&eyeTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyEyeTrackerFB(eyeTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&eyeTracker);
}

void FunctionDispatch::handle_xrGetEyeGazesFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetEyeGazesFB", function_loader.GetEyeGazesFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrEyeTrackerFB eyeTracker{};
    deserialize(&eyeTracker, d_ctx);
    XrEyeGazesInfoFB* gazeInfo{};
    deserialize_ptr(&gazeInfo, d_ctx);
    XrEyeGazesFB* eyeGazes{};
    deserialize_ptr(&eyeGazes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetEyeGazesFB(eyeTracker, gazeInfo, eyeGazes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(eyeGazes, 1, s_ctx);
    msg_out.flush();

    cleanup(&eyeTracker);
    cleanup_ptr(gazeInfo, 1);
    cleanup_ptr(eyeGazes, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_eye_tracking_social
#ifdef XRTRANSPORT_EXT_XR_FB_face_tracking
void FunctionDispatch::handle_xrCreateFaceTrackerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateFaceTrackerFB", function_loader.CreateFaceTrackerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFaceTrackerCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrFaceTrackerFB* faceTracker{};
    deserialize_ptr(&faceTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateFaceTrackerFB(session, createInfo, faceTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(faceTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(faceTracker, 1);
}

void FunctionDispatch::handle_xrDestroyFaceTrackerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyFaceTrackerFB", function_loader.DestroyFaceTrackerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrFaceTrackerFB faceTracker{};
    deserialize(&faceTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyFaceTrackerFB(faceTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&faceTracker);
}

void FunctionDispatch::handle_xrGetFaceExpressionWeightsFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetFaceExpressionWeightsFB", function_loader.GetFaceExpressionWeightsFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrFaceTrackerFB faceTracker{};
    deserialize(&faceTracker, d_ctx);
    XrFaceExpressionInfoFB* expressionInfo{};
    deserialize_ptr(&expressionInfo, d_ctx);
    XrFaceExpressionWeightsFB* expressionWeights{};
    deserialize_ptr(&expressionWeights, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetFaceExpressionWeightsFB(faceTracker, expressionInfo, expressionWeights);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(expressionWeights, 1, s_ctx);
    msg_out.flush();

    cleanup(&faceTracker);
    cleanup_ptr(expressionInfo, 1);
    cleanup_ptr(expressionWeights, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_face_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_face_tracking2
void FunctionDispatch::handle_xrCreateFaceTracker2FB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateFaceTracker2FB", function_loader.CreateFaceTracker2FB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFaceTrackerCreateInfo2FB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrFaceTracker2FB* faceTracker{};
    deserialize_ptr(&faceTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateFaceTracker2FB(session, createInfo, faceTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(createInfo->requestedDataSources, createInfo->requestedDataSourceCount, s_ctx);
    serialize_ptr(faceTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(faceTracker, 1);
}

void FunctionDispatch::handle_xrDestroyFaceTracker2FB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyFaceTracker2FB", function_loader.DestroyFaceTracker2FB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrFaceTracker2FB faceTracker{};
    deserialize(&faceTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyFaceTracker2FB(faceTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&faceTracker);
}

void FunctionDispatch::handle_xrGetFaceExpressionWeights2FB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetFaceExpressionWeights2FB", function_loader.GetFaceExpressionWeights2FB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrFaceTracker2FB faceTracker{};
    deserialize(&faceTracker, d_ctx);
    XrFaceExpressionInfo2FB* expressionInfo{};
    deserialize_ptr(&expressionInfo, d_ctx);
    XrFaceExpressionWeights2FB* expressionWeights{};
    deserialize_ptr(&expressionWeights, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetFaceExpressionWeights2FB(faceTracker, expressionInfo, expressionWeights);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(expressionWeights, 1, s_ctx);
    msg_out.flush();

    cleanup(&faceTracker);
    cleanup_ptr(expressionInfo, 1);
    cleanup_ptr(expressionWeights, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_face_tracking2
#ifdef XRTRANSPORT_EXT_XR_FB_foveation
void FunctionDispatch::handle_xrCreateFoveationProfileFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateFoveationProfileFB", function_loader.CreateFoveationProfileFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFoveationProfileCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrFoveationProfileFB* profile{};
    deserialize_ptr(&profile, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateFoveationProfileFB(session, createInfo, profile);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(createInfo->next, s_ctx);
    serialize_ptr(profile, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(profile, 1);
}

void FunctionDispatch::handle_xrDestroyFoveationProfileFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyFoveationProfileFB", function_loader.DestroyFoveationProfileFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrFoveationProfileFB profile{};
    deserialize(&profile, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyFoveationProfileFB(profile);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&profile);
}

#endif // XRTRANSPORT_EXT_XR_FB_foveation
#ifdef XRTRANSPORT_EXT_XR_FB_hand_tracking_mesh
void FunctionDispatch::handle_xrGetHandMeshFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetHandMeshFB", function_loader.GetHandMeshFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrHandTrackerEXT handTracker{};
    deserialize(&handTracker, d_ctx);
    XrHandTrackingMeshFB* mesh{};
    deserialize_ptr(&mesh, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetHandMeshFB(handTracker, mesh);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(mesh, 1, s_ctx);
    msg_out.flush();

    cleanup(&handTracker);
    cleanup_ptr(mesh, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_hand_tracking_mesh
#ifdef XRTRANSPORT_EXT_XR_FB_haptic_pcm
void FunctionDispatch::handle_xrGetDeviceSampleRateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetDeviceSampleRateFB", function_loader.GetDeviceSampleRateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrHapticActionInfo* hapticActionInfo{};
    deserialize_ptr(&hapticActionInfo, d_ctx);
    XrDevicePcmSampleRateGetInfoFB* deviceSampleRate{};
    deserialize_ptr(&deviceSampleRate, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetDeviceSampleRateFB(session, hapticActionInfo, deviceSampleRate);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(deviceSampleRate, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(hapticActionInfo, 1);
    cleanup_ptr(deviceSampleRate, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_haptic_pcm
#ifdef XRTRANSPORT_EXT_XR_FB_keyboard_tracking
void FunctionDispatch::handle_xrCreateKeyboardSpaceFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateKeyboardSpaceFB", function_loader.CreateKeyboardSpaceFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrKeyboardSpaceCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* keyboardSpace{};
    deserialize_ptr(&keyboardSpace, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateKeyboardSpaceFB(session, createInfo, keyboardSpace);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(createInfo->next, s_ctx);
    serialize_ptr(keyboardSpace, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(keyboardSpace, 1);
}

void FunctionDispatch::handle_xrQuerySystemTrackedKeyboardFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQuerySystemTrackedKeyboardFB", function_loader.QuerySystemTrackedKeyboardFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrKeyboardTrackingQueryFB* queryInfo{};
    deserialize_ptr(&queryInfo, d_ctx);
    XrKeyboardTrackingDescriptionFB* keyboard{};
    deserialize_ptr(&keyboard, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.QuerySystemTrackedKeyboardFB(session, queryInfo, keyboard);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(queryInfo->next, s_ctx);
    serialize_ptr(keyboard, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(queryInfo, 1);
    cleanup_ptr(keyboard, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_keyboard_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_passthrough
void FunctionDispatch::handle_xrCreateGeometryInstanceFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateGeometryInstanceFB", function_loader.CreateGeometryInstanceFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrGeometryInstanceCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrGeometryInstanceFB* outGeometryInstance{};
    deserialize_ptr(&outGeometryInstance, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateGeometryInstanceFB(session, createInfo, outGeometryInstance);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outGeometryInstance, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(outGeometryInstance, 1);
}

void FunctionDispatch::handle_xrCreatePassthroughFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreatePassthroughFB", function_loader.CreatePassthroughFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPassthroughCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrPassthroughFB* outPassthrough{};
    deserialize_ptr(&outPassthrough, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreatePassthroughFB(session, createInfo, outPassthrough);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outPassthrough, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(outPassthrough, 1);
}

void FunctionDispatch::handle_xrCreatePassthroughLayerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreatePassthroughLayerFB", function_loader.CreatePassthroughLayerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPassthroughLayerCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrPassthroughLayerFB* outLayer{};
    deserialize_ptr(&outLayer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreatePassthroughLayerFB(session, createInfo, outLayer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outLayer, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(outLayer, 1);
}

void FunctionDispatch::handle_xrDestroyGeometryInstanceFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyGeometryInstanceFB", function_loader.DestroyGeometryInstanceFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrGeometryInstanceFB instance{};
    deserialize(&instance, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyGeometryInstanceFB(instance);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
}

void FunctionDispatch::handle_xrDestroyPassthroughFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyPassthroughFB", function_loader.DestroyPassthroughFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPassthroughFB passthrough{};
    deserialize(&passthrough, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyPassthroughFB(passthrough);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&passthrough);
}

void FunctionDispatch::handle_xrDestroyPassthroughLayerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyPassthroughLayerFB", function_loader.DestroyPassthroughLayerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPassthroughLayerFB layer{};
    deserialize(&layer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyPassthroughLayerFB(layer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&layer);
}

void FunctionDispatch::handle_xrGeometryInstanceSetTransformFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGeometryInstanceSetTransformFB", function_loader.GeometryInstanceSetTransformFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrGeometryInstanceFB instance{};
    deserialize(&instance, d_ctx);
    XrGeometryInstanceTransformFB* transformation{};
    deserialize_ptr(&transformation, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GeometryInstanceSetTransformFB(instance, transformation);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(transformation, 1);
}

void FunctionDispatch::handle_xrPassthroughLayerPauseFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPassthroughLayerPauseFB", function_loader.PassthroughLayerPauseFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPassthroughLayerFB layer{};
    deserialize(&layer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PassthroughLayerPauseFB(layer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&layer);
}

void FunctionDispatch::handle_xrPassthroughLayerResumeFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPassthroughLayerResumeFB", function_loader.PassthroughLayerResumeFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPassthroughLayerFB layer{};
    deserialize(&layer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PassthroughLayerResumeFB(layer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&layer);
}

void FunctionDispatch::handle_xrPassthroughLayerSetStyleFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPassthroughLayerSetStyleFB", function_loader.PassthroughLayerSetStyleFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPassthroughLayerFB layer{};
    deserialize(&layer, d_ctx);
    XrPassthroughStyleFB* style{};
    deserialize_ptr(&style, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PassthroughLayerSetStyleFB(layer, style);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&layer);
    cleanup_ptr(style, 1);
}

void FunctionDispatch::handle_xrPassthroughPauseFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPassthroughPauseFB", function_loader.PassthroughPauseFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPassthroughFB passthrough{};
    deserialize(&passthrough, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PassthroughPauseFB(passthrough);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&passthrough);
}

void FunctionDispatch::handle_xrPassthroughStartFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPassthroughStartFB", function_loader.PassthroughStartFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPassthroughFB passthrough{};
    deserialize(&passthrough, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PassthroughStartFB(passthrough);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&passthrough);
}

#endif // XRTRANSPORT_EXT_XR_FB_passthrough
#ifdef XRTRANSPORT_EXT_XR_FB_passthrough_keyboard_hands
void FunctionDispatch::handle_xrPassthroughLayerSetKeyboardHandsIntensityFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPassthroughLayerSetKeyboardHandsIntensityFB", function_loader.PassthroughLayerSetKeyboardHandsIntensityFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPassthroughLayerFB layer{};
    deserialize(&layer, d_ctx);
    XrPassthroughKeyboardHandsIntensityFB* intensity{};
    deserialize_ptr(&intensity, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PassthroughLayerSetKeyboardHandsIntensityFB(layer, intensity);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&layer);
    cleanup_ptr(intensity, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_passthrough_keyboard_hands
#ifdef XRTRANSPORT_EXT_XR_FB_render_model
void FunctionDispatch::handle_xrEnumerateRenderModelPathsFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateRenderModelPathsFB", function_loader.EnumerateRenderModelPathsFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint32_t pathCapacityInput{};
    deserialize(&pathCapacityInput, d_ctx);
    uint32_t* pathCountOutput{};
    deserialize_ptr(&pathCountOutput, d_ctx);
    XrRenderModelPathInfoFB* paths{};
    deserialize_ptr(&paths, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateRenderModelPathsFB(session, pathCapacityInput, pathCountOutput, paths);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(pathCountOutput, 1, s_ctx);
    serialize_ptr(paths, pathCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&pathCapacityInput);
    cleanup_ptr(pathCountOutput, 1);
    cleanup_ptr(paths, pathCapacityInput);
}

void FunctionDispatch::handle_xrGetRenderModelPropertiesFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetRenderModelPropertiesFB", function_loader.GetRenderModelPropertiesFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath path{};
    deserialize(&path, d_ctx);
    XrRenderModelPropertiesFB* properties{};
    deserialize_ptr(&properties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetRenderModelPropertiesFB(session, path, properties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(properties, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&path);
    cleanup_ptr(properties, 1);
}

void FunctionDispatch::handle_xrLoadRenderModelFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLoadRenderModelFB", function_loader.LoadRenderModelFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrRenderModelLoadInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrRenderModelBufferFB* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.LoadRenderModelFB(session, info, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(info->next, s_ctx);
    serialize_ptr(buffer, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(buffer, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_render_model
#ifdef XRTRANSPORT_EXT_XR_FB_scene
void FunctionDispatch::handle_xrGetSpaceBoundary2DFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceBoundary2DFB", function_loader.GetSpaceBoundary2DFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrBoundary2DFB* boundary2DOutput{};
    deserialize_ptr(&boundary2DOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpaceBoundary2DFB(session, space, boundary2DOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(boundary2DOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&space);
    cleanup_ptr(boundary2DOutput, 1);
}

void FunctionDispatch::handle_xrGetSpaceBoundingBox2DFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceBoundingBox2DFB", function_loader.GetSpaceBoundingBox2DFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrRect2Df* boundingBox2DOutput{};
    deserialize_ptr(&boundingBox2DOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpaceBoundingBox2DFB(session, space, boundingBox2DOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(boundingBox2DOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&space);
    cleanup_ptr(boundingBox2DOutput, 1);
}

void FunctionDispatch::handle_xrGetSpaceBoundingBox3DFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceBoundingBox3DFB", function_loader.GetSpaceBoundingBox3DFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrRect3DfFB* boundingBox3DOutput{};
    deserialize_ptr(&boundingBox3DOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpaceBoundingBox3DFB(session, space, boundingBox3DOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(boundingBox3DOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&space);
    cleanup_ptr(boundingBox3DOutput, 1);
}

void FunctionDispatch::handle_xrGetSpaceRoomLayoutFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceRoomLayoutFB", function_loader.GetSpaceRoomLayoutFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrRoomLayoutFB* roomLayoutOutput{};
    deserialize_ptr(&roomLayoutOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpaceRoomLayoutFB(session, space, roomLayoutOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(roomLayoutOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&space);
    cleanup_ptr(roomLayoutOutput, 1);
}

void FunctionDispatch::handle_xrGetSpaceSemanticLabelsFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceSemanticLabelsFB", function_loader.GetSpaceSemanticLabelsFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrSemanticLabelsFB* semanticLabelsOutput{};
    deserialize_ptr(&semanticLabelsOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpaceSemanticLabelsFB(session, space, semanticLabelsOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(semanticLabelsOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&space);
    cleanup_ptr(semanticLabelsOutput, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_scene
#ifdef XRTRANSPORT_EXT_XR_FB_scene_capture
void FunctionDispatch::handle_xrRequestSceneCaptureFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestSceneCaptureFB", function_loader.RequestSceneCaptureFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSceneCaptureRequestInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.RequestSceneCaptureFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_scene_capture
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity
void FunctionDispatch::handle_xrCreateSpatialAnchorFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorFB", function_loader.CreateSpatialAnchorFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorCreateInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialAnchorFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

void FunctionDispatch::handle_xrEnumerateSpaceSupportedComponentsFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateSpaceSupportedComponentsFB", function_loader.EnumerateSpaceSupportedComponentsFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpace space{};
    deserialize(&space, d_ctx);
    uint32_t componentTypeCapacityInput{};
    deserialize(&componentTypeCapacityInput, d_ctx);
    uint32_t* componentTypeCountOutput{};
    deserialize_ptr(&componentTypeCountOutput, d_ctx);
    XrSpaceComponentTypeFB* componentTypes{};
    deserialize_ptr(&componentTypes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateSpaceSupportedComponentsFB(space, componentTypeCapacityInput, componentTypeCountOutput, componentTypes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(componentTypeCountOutput, 1, s_ctx);
    serialize_ptr(componentTypes, componentTypeCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&space);
    cleanup(&componentTypeCapacityInput);
    cleanup_ptr(componentTypeCountOutput, 1);
    cleanup_ptr(componentTypes, componentTypeCapacityInput);
}

void FunctionDispatch::handle_xrGetSpaceComponentStatusFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceComponentStatusFB", function_loader.GetSpaceComponentStatusFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrSpaceComponentTypeFB componentType{};
    deserialize(&componentType, d_ctx);
    XrSpaceComponentStatusFB* status{};
    deserialize_ptr(&status, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpaceComponentStatusFB(space, componentType, status);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(status, 1, s_ctx);
    msg_out.flush();

    cleanup(&space);
    cleanup(&componentType);
    cleanup_ptr(status, 1);
}

void FunctionDispatch::handle_xrGetSpaceUuidFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceUuidFB", function_loader.GetSpaceUuidFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrUuidEXT* uuid{};
    deserialize_ptr(&uuid, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpaceUuidFB(space, uuid);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(uuid, 1, s_ctx);
    msg_out.flush();

    cleanup(&space);
    cleanup_ptr(uuid, 1);
}

void FunctionDispatch::handle_xrSetSpaceComponentStatusFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetSpaceComponentStatusFB", function_loader.SetSpaceComponentStatusFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrSpaceComponentStatusSetInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetSpaceComponentStatusFB(space, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&space);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_container
void FunctionDispatch::handle_xrGetSpaceContainerFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceContainerFB", function_loader.GetSpaceContainerFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrSpaceContainerFB* spaceContainerOutput{};
    deserialize_ptr(&spaceContainerOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpaceContainerFB(session, space, spaceContainerOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(spaceContainerOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&space);
    cleanup_ptr(spaceContainerOutput, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_container
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_query
void FunctionDispatch::handle_xrQuerySpacesFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQuerySpacesFB", function_loader.QuerySpacesFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpaceQueryInfoBaseHeaderFB* info{};
    deserialize_xr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.QuerySpacesFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_xr(info);
    cleanup_ptr(requestId, 1);
}

void FunctionDispatch::handle_xrRetrieveSpaceQueryResultsFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRetrieveSpaceQueryResultsFB", function_loader.RetrieveSpaceQueryResultsFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrAsyncRequestIdFB requestId{};
    deserialize(&requestId, d_ctx);
    XrSpaceQueryResultsFB* results{};
    deserialize_ptr(&results, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.RetrieveSpaceQueryResultsFB(session, requestId, results);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(results, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&requestId);
    cleanup_ptr(results, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_query
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_sharing
void FunctionDispatch::handle_xrShareSpacesFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrShareSpacesFB", function_loader.ShareSpacesFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpaceShareInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ShareSpacesFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(info->spaces, info->spaceCount, s_ctx);
    serialize_ptr(info->users, info->userCount, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_sharing
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_storage
void FunctionDispatch::handle_xrEraseSpaceFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEraseSpaceFB", function_loader.EraseSpaceFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpaceEraseInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EraseSpaceFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

void FunctionDispatch::handle_xrSaveSpaceFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSaveSpaceFB", function_loader.SaveSpaceFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpaceSaveInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SaveSpaceFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_storage
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_storage_batch
void FunctionDispatch::handle_xrSaveSpaceListFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSaveSpaceListFB", function_loader.SaveSpaceListFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpaceListSaveInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SaveSpaceListFB(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(info->spaces, info->spaceCount, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_storage_batch
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_user
void FunctionDispatch::handle_xrCreateSpaceUserFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpaceUserFB", function_loader.CreateSpaceUserFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpaceUserCreateInfoFB* info{};
    deserialize_ptr(&info, d_ctx);
    XrSpaceUserFB* user{};
    deserialize_ptr(&user, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpaceUserFB(session, info, user);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(user, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(user, 1);
}

void FunctionDispatch::handle_xrDestroySpaceUserFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySpaceUserFB", function_loader.DestroySpaceUserFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpaceUserFB user{};
    deserialize(&user, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroySpaceUserFB(user);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&user);
}

void FunctionDispatch::handle_xrGetSpaceUserIdFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceUserIdFB", function_loader.GetSpaceUserIdFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpaceUserFB user{};
    deserialize(&user, d_ctx);
    XrSpaceUserIdFB* userId{};
    deserialize_ptr(&userId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpaceUserIdFB(user, userId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(userId, 1, s_ctx);
    msg_out.flush();

    cleanup(&user);
    cleanup_ptr(userId, 1);
}

#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_user
#ifdef XRTRANSPORT_EXT_XR_FB_swapchain_update_state
void FunctionDispatch::handle_xrGetSwapchainStateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSwapchainStateFB", function_loader.GetSwapchainStateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);
    XrSwapchainStateBaseHeaderFB* state{};
    deserialize_xr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSwapchainStateFB(swapchain, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(state, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup_xr(state);
}

void FunctionDispatch::handle_xrUpdateSwapchainFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUpdateSwapchainFB", function_loader.UpdateSwapchainFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);
    XrSwapchainStateBaseHeaderFB* state{};
    deserialize_xr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.UpdateSwapchainFB(swapchain, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup_xr(state);
}

#endif // XRTRANSPORT_EXT_XR_FB_swapchain_update_state
#ifdef XRTRANSPORT_EXT_XR_FB_triangle_mesh
void FunctionDispatch::handle_xrCreateTriangleMeshFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateTriangleMeshFB", function_loader.CreateTriangleMeshFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrTriangleMeshCreateInfoFB* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrTriangleMeshFB* outTriangleMesh{};
    deserialize_ptr(&outTriangleMesh, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateTriangleMeshFB(session, createInfo, outTriangleMesh);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outTriangleMesh, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(outTriangleMesh, 1);
}

void FunctionDispatch::handle_xrDestroyTriangleMeshFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyTriangleMeshFB", function_loader.DestroyTriangleMeshFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyTriangleMeshFB(mesh);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
}

void FunctionDispatch::handle_xrTriangleMeshBeginUpdateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTriangleMeshBeginUpdateFB", function_loader.TriangleMeshBeginUpdateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.TriangleMeshBeginUpdateFB(mesh);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
}

void FunctionDispatch::handle_xrTriangleMeshBeginVertexBufferUpdateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTriangleMeshBeginVertexBufferUpdateFB", function_loader.TriangleMeshBeginVertexBufferUpdateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);
    uint32_t* outVertexCount{};
    deserialize_ptr(&outVertexCount, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.TriangleMeshBeginVertexBufferUpdateFB(mesh, outVertexCount);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outVertexCount, 1, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
    cleanup_ptr(outVertexCount, 1);
}

void FunctionDispatch::handle_xrTriangleMeshEndUpdateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTriangleMeshEndUpdateFB", function_loader.TriangleMeshEndUpdateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);
    uint32_t vertexCount{};
    deserialize(&vertexCount, d_ctx);
    uint32_t triangleCount{};
    deserialize(&triangleCount, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.TriangleMeshEndUpdateFB(mesh, vertexCount, triangleCount);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
    cleanup(&vertexCount);
    cleanup(&triangleCount);
}

void FunctionDispatch::handle_xrTriangleMeshEndVertexBufferUpdateFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTriangleMeshEndVertexBufferUpdateFB", function_loader.TriangleMeshEndVertexBufferUpdateFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.TriangleMeshEndVertexBufferUpdateFB(mesh);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
}

void FunctionDispatch::handle_xrTriangleMeshGetIndexBufferFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTriangleMeshGetIndexBufferFB", function_loader.TriangleMeshGetIndexBufferFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);
    uint32_t** outIndexBuffer{};
    #error "auto-generator doesn't support double pointers (outIndexBuffer)"None

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.TriangleMeshGetIndexBufferFB(mesh, outIndexBuffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outIndexBuffer, 1, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
    #error "auto-generator doesn't support double pointers (outIndexBuffer)"None
}

void FunctionDispatch::handle_xrTriangleMeshGetVertexBufferFB(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTriangleMeshGetVertexBufferFB", function_loader.TriangleMeshGetVertexBufferFB);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrTriangleMeshFB mesh{};
    deserialize(&mesh, d_ctx);
    XrVector3f** outVertexBuffer{};
    #error "auto-generator doesn't support double pointers (outVertexBuffer)"None

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.TriangleMeshGetVertexBufferFB(mesh, outVertexBuffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(outVertexBuffer, 1, s_ctx);
    msg_out.flush();

    cleanup(&mesh);
    #error "auto-generator doesn't support double pointers (outVertexBuffer)"None
}

#endif // XRTRANSPORT_EXT_XR_FB_triangle_mesh
#ifdef XRTRANSPORT_EXT_XR_HTCX_vive_tracker_interaction
void FunctionDispatch::handle_xrEnumerateViveTrackerPathsHTCX(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateViveTrackerPathsHTCX", function_loader.EnumerateViveTrackerPathsHTCX);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    uint32_t pathCapacityInput{};
    deserialize(&pathCapacityInput, d_ctx);
    uint32_t* pathCountOutput{};
    deserialize_ptr(&pathCountOutput, d_ctx);
    XrViveTrackerPathsHTCX* paths{};
    deserialize_ptr(&paths, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateViveTrackerPathsHTCX(instance, pathCapacityInput, pathCountOutput, paths);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(pathCountOutput, 1, s_ctx);
    serialize_ptr(paths, pathCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&pathCapacityInput);
    cleanup_ptr(pathCountOutput, 1);
    cleanup_ptr(paths, pathCapacityInput);
}

#endif // XRTRANSPORT_EXT_XR_HTCX_vive_tracker_interaction
#ifdef XRTRANSPORT_EXT_XR_HTC_anchor
void FunctionDispatch::handle_xrCreateSpatialAnchorHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorHTC", function_loader.CreateSpatialAnchorHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorCreateInfoHTC* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* anchor{};
    deserialize_ptr(&anchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialAnchorHTC(session, createInfo, anchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(anchor, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(anchor, 1);
}

void FunctionDispatch::handle_xrGetSpatialAnchorNameHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpatialAnchorNameHTC", function_loader.GetSpatialAnchorNameHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpace anchor{};
    deserialize(&anchor, d_ctx);
    XrSpatialAnchorNameHTC* name{};
    deserialize_ptr(&name, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpatialAnchorNameHTC(anchor, name);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(name, 1, s_ctx);
    msg_out.flush();

    cleanup(&anchor);
    cleanup_ptr(name, 1);
}

#endif // XRTRANSPORT_EXT_XR_HTC_anchor
#ifdef XRTRANSPORT_EXT_XR_HTC_body_tracking
void FunctionDispatch::handle_xrCreateBodyTrackerHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateBodyTrackerHTC", function_loader.CreateBodyTrackerHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrBodyTrackerCreateInfoHTC* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrBodyTrackerHTC* bodyTracker{};
    deserialize_ptr(&bodyTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateBodyTrackerHTC(session, createInfo, bodyTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bodyTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(bodyTracker, 1);
}

void FunctionDispatch::handle_xrDestroyBodyTrackerHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyBodyTrackerHTC", function_loader.DestroyBodyTrackerHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrBodyTrackerHTC bodyTracker{};
    deserialize(&bodyTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyBodyTrackerHTC(bodyTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
}

void FunctionDispatch::handle_xrGetBodySkeletonHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetBodySkeletonHTC", function_loader.GetBodySkeletonHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrBodyTrackerHTC bodyTracker{};
    deserialize(&bodyTracker, d_ctx);
    XrSpace baseSpace{};
    deserialize(&baseSpace, d_ctx);
    uint32_t skeletonGenerationId{};
    deserialize(&skeletonGenerationId, d_ctx);
    XrBodySkeletonHTC* skeleton{};
    deserialize_ptr(&skeleton, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetBodySkeletonHTC(bodyTracker, baseSpace, skeletonGenerationId, skeleton);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(skeleton, 1, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
    cleanup(&baseSpace);
    cleanup(&skeletonGenerationId);
    cleanup_ptr(skeleton, 1);
}

void FunctionDispatch::handle_xrLocateBodyJointsHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateBodyJointsHTC", function_loader.LocateBodyJointsHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrBodyTrackerHTC bodyTracker{};
    deserialize(&bodyTracker, d_ctx);
    XrBodyJointsLocateInfoHTC* locateInfo{};
    deserialize_ptr(&locateInfo, d_ctx);
    XrBodyJointLocationsHTC* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.LocateBodyJointsHTC(bodyTracker, locateInfo, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations, 1, s_ctx);
    msg_out.flush();

    cleanup(&bodyTracker);
    cleanup_ptr(locateInfo, 1);
    cleanup_ptr(locations, 1);
}

#endif // XRTRANSPORT_EXT_XR_HTC_body_tracking
#ifdef XRTRANSPORT_EXT_XR_HTC_facial_tracking
void FunctionDispatch::handle_xrCreateFacialTrackerHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateFacialTrackerHTC", function_loader.CreateFacialTrackerHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFacialTrackerCreateInfoHTC* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrFacialTrackerHTC* facialTracker{};
    deserialize_ptr(&facialTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateFacialTrackerHTC(session, createInfo, facialTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(facialTracker, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(facialTracker, 1);
}

void FunctionDispatch::handle_xrDestroyFacialTrackerHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyFacialTrackerHTC", function_loader.DestroyFacialTrackerHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrFacialTrackerHTC facialTracker{};
    deserialize(&facialTracker, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyFacialTrackerHTC(facialTracker);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&facialTracker);
}

void FunctionDispatch::handle_xrGetFacialExpressionsHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetFacialExpressionsHTC", function_loader.GetFacialExpressionsHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrFacialTrackerHTC facialTracker{};
    deserialize(&facialTracker, d_ctx);
    XrFacialExpressionsHTC* facialExpressions{};
    deserialize_ptr(&facialExpressions, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetFacialExpressionsHTC(facialTracker, facialExpressions);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(facialExpressions, 1, s_ctx);
    msg_out.flush();

    cleanup(&facialTracker);
    cleanup_ptr(facialExpressions, 1);
}

#endif // XRTRANSPORT_EXT_XR_HTC_facial_tracking
#ifdef XRTRANSPORT_EXT_XR_HTC_foveation
void FunctionDispatch::handle_xrApplyFoveationHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrApplyFoveationHTC", function_loader.ApplyFoveationHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFoveationApplyInfoHTC* applyInfo{};
    deserialize_ptr(&applyInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ApplyFoveationHTC(session, applyInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(applyInfo->subImages, applyInfo->subImageCount, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(applyInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_HTC_foveation
#ifdef XRTRANSPORT_EXT_XR_HTC_passthrough
void FunctionDispatch::handle_xrCreatePassthroughHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreatePassthroughHTC", function_loader.CreatePassthroughHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPassthroughCreateInfoHTC* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrPassthroughHTC* passthrough{};
    deserialize_ptr(&passthrough, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreatePassthroughHTC(session, createInfo, passthrough);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(passthrough, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(passthrough, 1);
}

void FunctionDispatch::handle_xrDestroyPassthroughHTC(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyPassthroughHTC", function_loader.DestroyPassthroughHTC);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPassthroughHTC passthrough{};
    deserialize(&passthrough, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyPassthroughHTC(passthrough);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&passthrough);
}

#endif // XRTRANSPORT_EXT_XR_HTC_passthrough
#ifdef XRTRANSPORT_EXT_XR_KHR_D3D11_enable
void FunctionDispatch::handle_xrGetD3D11GraphicsRequirementsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetD3D11GraphicsRequirementsKHR", function_loader.GetD3D11GraphicsRequirementsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrGraphicsRequirementsD3D11KHR* graphicsRequirements{};
    deserialize_ptr(&graphicsRequirements, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetD3D11GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(graphicsRequirements, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(graphicsRequirements, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_D3D11_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_D3D12_enable
void FunctionDispatch::handle_xrGetD3D12GraphicsRequirementsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetD3D12GraphicsRequirementsKHR", function_loader.GetD3D12GraphicsRequirementsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrGraphicsRequirementsD3D12KHR* graphicsRequirements{};
    deserialize_ptr(&graphicsRequirements, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetD3D12GraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(graphicsRequirements, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(graphicsRequirements, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_D3D12_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_android_surface_swapchain
void FunctionDispatch::handle_xrCreateSwapchainAndroidSurfaceKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSwapchainAndroidSurfaceKHR", function_loader.CreateSwapchainAndroidSurfaceKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSwapchainCreateInfo* info{};
    deserialize_ptr(&info, d_ctx);
    XrSwapchain* swapchain{};
    deserialize_ptr(&swapchain, d_ctx);
    jobject* surface{};
    deserialize_ptr(&surface, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSwapchainAndroidSurfaceKHR(session, info, swapchain, surface);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(swapchain, 1, s_ctx);
    serialize_ptr(surface, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(swapchain, 1);
    cleanup_ptr(surface, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_android_surface_swapchain
#ifdef XRTRANSPORT_EXT_XR_KHR_android_thread_settings
void FunctionDispatch::handle_xrSetAndroidApplicationThreadKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetAndroidApplicationThreadKHR", function_loader.SetAndroidApplicationThreadKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrAndroidThreadTypeKHR threadType{};
    deserialize(&threadType, d_ctx);
    uint32_t threadId{};
    deserialize(&threadId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetAndroidApplicationThreadKHR(session, threadType, threadId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&threadType);
    cleanup(&threadId);
}

#endif // XRTRANSPORT_EXT_XR_KHR_android_thread_settings
#ifdef XRTRANSPORT_EXT_XR_KHR_convert_timespec_time
void FunctionDispatch::handle_xrConvertTimeToTimespecTimeKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrConvertTimeToTimespecTimeKHR", function_loader.ConvertTimeToTimespecTimeKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrTime time{};
    deserialize_time(&time, d_ctx);
    timespec* timespecTime{};
    deserialize_ptr(&timespecTime, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ConvertTimeToTimespecTimeKHR(instance, time, timespecTime);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(timespecTime, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&time);
    cleanup_ptr(timespecTime, 1);
}

void FunctionDispatch::handle_xrConvertTimespecTimeToTimeKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrConvertTimespecTimeToTimeKHR", function_loader.ConvertTimespecTimeToTimeKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    timespec* timespecTime{};
    deserialize_ptr(&timespecTime, d_ctx);
    XrTime* time{};
    deserialize_ptr(&time, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ConvertTimespecTimeToTimeKHR(instance, timespecTime, time);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(timespecTime, 1, s_ctx);
    serialize_ptr(time, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(timespecTime, 1);
    cleanup_ptr(time, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_convert_timespec_time
#ifdef XRTRANSPORT_EXT_XR_KHR_extended_struct_name_lengths
void FunctionDispatch::handle_xrStructureTypeToString2KHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStructureTypeToString2KHR", function_loader.StructureTypeToString2KHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrStructureType value{};
    deserialize(&value, d_ctx);
    char buffer[XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR]{};
    deserialize_array(buffer, XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.StructureTypeToString2KHR(instance, value, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(buffer, XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&value);
    cleanup_array(buffer, XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR);
}

#endif // XRTRANSPORT_EXT_XR_KHR_extended_struct_name_lengths
#ifdef XRTRANSPORT_EXT_XR_KHR_loader_init
void FunctionDispatch::handle_xrInitializeLoaderKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrInitializeLoaderKHR", function_loader.InitializeLoaderKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrLoaderInitInfoBaseHeaderKHR* loaderInitInfo{};
    deserialize_xr(&loaderInitInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.InitializeLoaderKHR(loaderInitInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup_xr(loaderInitInfo);
}

#endif // XRTRANSPORT_EXT_XR_KHR_loader_init
#ifdef XRTRANSPORT_EXT_XR_KHR_metal_enable
void FunctionDispatch::handle_xrGetMetalGraphicsRequirementsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMetalGraphicsRequirementsKHR", function_loader.GetMetalGraphicsRequirementsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrGraphicsRequirementsMetalKHR* graphicsRequirements{};
    deserialize_ptr(&graphicsRequirements, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetMetalGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(graphicsRequirements, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(graphicsRequirements, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_metal_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_opengl_enable
void FunctionDispatch::handle_xrGetOpenGLGraphicsRequirementsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetOpenGLGraphicsRequirementsKHR", function_loader.GetOpenGLGraphicsRequirementsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrGraphicsRequirementsOpenGLKHR* graphicsRequirements{};
    deserialize_ptr(&graphicsRequirements, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetOpenGLGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(graphicsRequirements, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(graphicsRequirements, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_opengl_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_opengl_es_enable
void FunctionDispatch::handle_xrGetOpenGLESGraphicsRequirementsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetOpenGLESGraphicsRequirementsKHR", function_loader.GetOpenGLESGraphicsRequirementsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrGraphicsRequirementsOpenGLESKHR* graphicsRequirements{};
    deserialize_ptr(&graphicsRequirements, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetOpenGLESGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(graphicsRequirements, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(graphicsRequirements, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_opengl_es_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_visibility_mask
void FunctionDispatch::handle_xrGetVisibilityMaskKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVisibilityMaskKHR", function_loader.GetVisibilityMaskKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrViewConfigurationType viewConfigurationType{};
    deserialize(&viewConfigurationType, d_ctx);
    uint32_t viewIndex{};
    deserialize(&viewIndex, d_ctx);
    XrVisibilityMaskTypeKHR visibilityMaskType{};
    deserialize(&visibilityMaskType, d_ctx);
    XrVisibilityMaskKHR* visibilityMask{};
    deserialize_ptr(&visibilityMask, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetVisibilityMaskKHR(session, viewConfigurationType, viewIndex, visibilityMaskType, visibilityMask);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(visibilityMask, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&viewConfigurationType);
    cleanup(&viewIndex);
    cleanup(&visibilityMaskType);
    cleanup_ptr(visibilityMask, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_visibility_mask
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_enable
void FunctionDispatch::handle_xrGetVulkanDeviceExtensionsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVulkanDeviceExtensionsKHR", function_loader.GetVulkanDeviceExtensionsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetVulkanDeviceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

void FunctionDispatch::handle_xrGetVulkanGraphicsDeviceKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVulkanGraphicsDeviceKHR", function_loader.GetVulkanGraphicsDeviceKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    VkInstance vkInstance{};
    deserialize(&vkInstance, d_ctx);
    VkPhysicalDevice* vkPhysicalDevice{};
    deserialize_ptr(&vkPhysicalDevice, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetVulkanGraphicsDeviceKHR(instance, systemId, vkInstance, vkPhysicalDevice);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(vkPhysicalDevice, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&vkInstance);
    cleanup_ptr(vkPhysicalDevice, 1);
}

void FunctionDispatch::handle_xrGetVulkanGraphicsRequirementsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVulkanGraphicsRequirementsKHR", function_loader.GetVulkanGraphicsRequirementsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrGraphicsRequirementsVulkanKHR* graphicsRequirements{};
    deserialize_ptr(&graphicsRequirements, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetVulkanGraphicsRequirementsKHR(instance, systemId, graphicsRequirements);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(graphicsRequirements, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(graphicsRequirements, 1);
}

void FunctionDispatch::handle_xrGetVulkanInstanceExtensionsKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVulkanInstanceExtensionsKHR", function_loader.GetVulkanInstanceExtensionsKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetVulkanInstanceExtensionsKHR(instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_enable2
void FunctionDispatch::handle_xrCreateVulkanDeviceKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateVulkanDeviceKHR", function_loader.CreateVulkanDeviceKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrVulkanDeviceCreateInfoKHR* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    VkDevice* vulkanDevice{};
    deserialize_ptr(&vulkanDevice, d_ctx);
    VkResult* vulkanResult{};
    deserialize_ptr(&vulkanResult, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateVulkanDeviceKHR(instance, createInfo, vulkanDevice, vulkanResult);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(vulkanDevice, 1, s_ctx);
    serialize_ptr(vulkanResult, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(vulkanDevice, 1);
    cleanup_ptr(vulkanResult, 1);
}

void FunctionDispatch::handle_xrCreateVulkanInstanceKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateVulkanInstanceKHR", function_loader.CreateVulkanInstanceKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrVulkanInstanceCreateInfoKHR* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    VkInstance* vulkanInstance{};
    deserialize_ptr(&vulkanInstance, d_ctx);
    VkResult* vulkanResult{};
    deserialize_ptr(&vulkanResult, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateVulkanInstanceKHR(instance, createInfo, vulkanInstance, vulkanResult);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(vulkanInstance, 1, s_ctx);
    serialize_ptr(vulkanResult, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(vulkanInstance, 1);
    cleanup_ptr(vulkanResult, 1);
}

void FunctionDispatch::handle_xrGetVulkanGraphicsDevice2KHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVulkanGraphicsDevice2KHR", function_loader.GetVulkanGraphicsDevice2KHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrVulkanGraphicsDeviceGetInfoKHR* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    VkPhysicalDevice* vulkanPhysicalDevice{};
    deserialize_ptr(&vulkanPhysicalDevice, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetVulkanGraphicsDevice2KHR(instance, getInfo, vulkanPhysicalDevice);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(vulkanPhysicalDevice, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(vulkanPhysicalDevice, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_enable2
#ifdef XRTRANSPORT_EXT_XR_KHR_win32_convert_performance_counter_time
void FunctionDispatch::handle_xrConvertTimeToWin32PerformanceCounterKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrConvertTimeToWin32PerformanceCounterKHR", function_loader.ConvertTimeToWin32PerformanceCounterKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrTime time{};
    deserialize_time(&time, d_ctx);
    LARGE_INTEGER* performanceCounter{};
    deserialize_ptr(&performanceCounter, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ConvertTimeToWin32PerformanceCounterKHR(instance, time, performanceCounter);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(performanceCounter, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&time);
    cleanup_ptr(performanceCounter, 1);
}

void FunctionDispatch::handle_xrConvertWin32PerformanceCounterToTimeKHR(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrConvertWin32PerformanceCounterToTimeKHR", function_loader.ConvertWin32PerformanceCounterToTimeKHR);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    LARGE_INTEGER* performanceCounter{};
    deserialize_ptr(&performanceCounter, d_ctx);
    XrTime* time{};
    deserialize_ptr(&time, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ConvertWin32PerformanceCounterToTimeKHR(instance, performanceCounter, time);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(time, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(performanceCounter, 1);
    cleanup_ptr(time, 1);
}

#endif // XRTRANSPORT_EXT_XR_KHR_win32_convert_performance_counter_time
#ifdef XRTRANSPORT_EXT_XR_META_colocation_discovery
void FunctionDispatch::handle_xrStartColocationAdvertisementMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStartColocationAdvertisementMETA", function_loader.StartColocationAdvertisementMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrColocationAdvertisementStartInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* advertisementRequestId{};
    deserialize_ptr(&advertisementRequestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.StartColocationAdvertisementMETA(session, info, advertisementRequestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(info->buffer, info->bufferSize, s_ctx);
    serialize_ptr(advertisementRequestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(advertisementRequestId, 1);
}

void FunctionDispatch::handle_xrStartColocationDiscoveryMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStartColocationDiscoveryMETA", function_loader.StartColocationDiscoveryMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrColocationDiscoveryStartInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* discoveryRequestId{};
    deserialize_ptr(&discoveryRequestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.StartColocationDiscoveryMETA(session, info, discoveryRequestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(discoveryRequestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(discoveryRequestId, 1);
}

void FunctionDispatch::handle_xrStopColocationAdvertisementMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStopColocationAdvertisementMETA", function_loader.StopColocationAdvertisementMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrColocationAdvertisementStopInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.StopColocationAdvertisementMETA(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

void FunctionDispatch::handle_xrStopColocationDiscoveryMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStopColocationDiscoveryMETA", function_loader.StopColocationDiscoveryMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrColocationDiscoveryStopInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.StopColocationDiscoveryMETA(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_colocation_discovery
#ifdef XRTRANSPORT_EXT_XR_META_environment_depth
void FunctionDispatch::handle_xrAcquireEnvironmentDepthImageMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrAcquireEnvironmentDepthImageMETA", function_loader.AcquireEnvironmentDepthImageMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrEnvironmentDepthProviderMETA environmentDepthProvider{};
    deserialize(&environmentDepthProvider, d_ctx);
    XrEnvironmentDepthImageAcquireInfoMETA* acquireInfo{};
    deserialize_ptr(&acquireInfo, d_ctx);
    XrEnvironmentDepthImageMETA* environmentDepthImage{};
    deserialize_ptr(&environmentDepthImage, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.AcquireEnvironmentDepthImageMETA(environmentDepthProvider, acquireInfo, environmentDepthImage);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(environmentDepthImage, 1, s_ctx);
    msg_out.flush();

    cleanup(&environmentDepthProvider);
    cleanup_ptr(acquireInfo, 1);
    cleanup_ptr(environmentDepthImage, 1);
}

void FunctionDispatch::handle_xrCreateEnvironmentDepthProviderMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateEnvironmentDepthProviderMETA", function_loader.CreateEnvironmentDepthProviderMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrEnvironmentDepthProviderCreateInfoMETA* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrEnvironmentDepthProviderMETA* environmentDepthProvider{};
    deserialize_ptr(&environmentDepthProvider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateEnvironmentDepthProviderMETA(session, createInfo, environmentDepthProvider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(environmentDepthProvider, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(environmentDepthProvider, 1);
}

void FunctionDispatch::handle_xrCreateEnvironmentDepthSwapchainMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateEnvironmentDepthSwapchainMETA", function_loader.CreateEnvironmentDepthSwapchainMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrEnvironmentDepthProviderMETA environmentDepthProvider{};
    deserialize(&environmentDepthProvider, d_ctx);
    XrEnvironmentDepthSwapchainCreateInfoMETA* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrEnvironmentDepthSwapchainMETA* swapchain{};
    deserialize_ptr(&swapchain, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateEnvironmentDepthSwapchainMETA(environmentDepthProvider, createInfo, swapchain);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(swapchain, 1, s_ctx);
    msg_out.flush();

    cleanup(&environmentDepthProvider);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(swapchain, 1);
}

void FunctionDispatch::handle_xrDestroyEnvironmentDepthProviderMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyEnvironmentDepthProviderMETA", function_loader.DestroyEnvironmentDepthProviderMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrEnvironmentDepthProviderMETA environmentDepthProvider{};
    deserialize(&environmentDepthProvider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyEnvironmentDepthProviderMETA(environmentDepthProvider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&environmentDepthProvider);
}

void FunctionDispatch::handle_xrDestroyEnvironmentDepthSwapchainMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyEnvironmentDepthSwapchainMETA", function_loader.DestroyEnvironmentDepthSwapchainMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrEnvironmentDepthSwapchainMETA swapchain{};
    deserialize(&swapchain, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyEnvironmentDepthSwapchainMETA(swapchain);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
}

void FunctionDispatch::handle_xrEnumerateEnvironmentDepthSwapchainImagesMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateEnvironmentDepthSwapchainImagesMETA", function_loader.EnumerateEnvironmentDepthSwapchainImagesMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrEnvironmentDepthSwapchainMETA swapchain{};
    deserialize(&swapchain, d_ctx);
    uint32_t imageCapacityInput{};
    deserialize(&imageCapacityInput, d_ctx);
    uint32_t* imageCountOutput{};
    deserialize_ptr(&imageCountOutput, d_ctx);
    XrSwapchainImageBaseHeader* images{};
    deserialize_xr_array(&images, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateEnvironmentDepthSwapchainImagesMETA(swapchain, imageCapacityInput, imageCountOutput, images);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(imageCountOutput, 1, s_ctx);
    serialize_xr_array(images, imageCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup(&imageCapacityInput);
    cleanup_ptr(imageCountOutput, 1);
    cleanup_xr_array(images, imageCapacityInput);
}

void FunctionDispatch::handle_xrGetEnvironmentDepthSwapchainStateMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetEnvironmentDepthSwapchainStateMETA", function_loader.GetEnvironmentDepthSwapchainStateMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrEnvironmentDepthSwapchainMETA swapchain{};
    deserialize(&swapchain, d_ctx);
    XrEnvironmentDepthSwapchainStateMETA* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetEnvironmentDepthSwapchainStateMETA(swapchain, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrSetEnvironmentDepthHandRemovalMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetEnvironmentDepthHandRemovalMETA", function_loader.SetEnvironmentDepthHandRemovalMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrEnvironmentDepthProviderMETA environmentDepthProvider{};
    deserialize(&environmentDepthProvider, d_ctx);
    XrEnvironmentDepthHandRemovalSetInfoMETA* setInfo{};
    deserialize_ptr(&setInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetEnvironmentDepthHandRemovalMETA(environmentDepthProvider, setInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&environmentDepthProvider);
    cleanup_ptr(setInfo, 1);
}

void FunctionDispatch::handle_xrStartEnvironmentDepthProviderMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStartEnvironmentDepthProviderMETA", function_loader.StartEnvironmentDepthProviderMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrEnvironmentDepthProviderMETA environmentDepthProvider{};
    deserialize(&environmentDepthProvider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.StartEnvironmentDepthProviderMETA(environmentDepthProvider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&environmentDepthProvider);
}

void FunctionDispatch::handle_xrStopEnvironmentDepthProviderMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStopEnvironmentDepthProviderMETA", function_loader.StopEnvironmentDepthProviderMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrEnvironmentDepthProviderMETA environmentDepthProvider{};
    deserialize(&environmentDepthProvider, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.StopEnvironmentDepthProviderMETA(environmentDepthProvider);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&environmentDepthProvider);
}

#endif // XRTRANSPORT_EXT_XR_META_environment_depth
#ifdef XRTRANSPORT_EXT_XR_META_foveation_eye_tracked
void FunctionDispatch::handle_xrGetFoveationEyeTrackedStateMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetFoveationEyeTrackedStateMETA", function_loader.GetFoveationEyeTrackedStateMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFoveationEyeTrackedStateMETA* foveationState{};
    deserialize_ptr(&foveationState, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetFoveationEyeTrackedStateMETA(session, foveationState);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(foveationState, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(foveationState, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_foveation_eye_tracked
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_color_lut
void FunctionDispatch::handle_xrCreatePassthroughColorLutMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreatePassthroughColorLutMETA", function_loader.CreatePassthroughColorLutMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPassthroughFB passthrough{};
    deserialize(&passthrough, d_ctx);
    XrPassthroughColorLutCreateInfoMETA* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrPassthroughColorLutMETA* colorLut{};
    deserialize_ptr(&colorLut, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreatePassthroughColorLutMETA(passthrough, createInfo, colorLut);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(colorLut, 1, s_ctx);
    msg_out.flush();

    cleanup(&passthrough);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(colorLut, 1);
}

void FunctionDispatch::handle_xrDestroyPassthroughColorLutMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyPassthroughColorLutMETA", function_loader.DestroyPassthroughColorLutMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPassthroughColorLutMETA colorLut{};
    deserialize(&colorLut, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyPassthroughColorLutMETA(colorLut);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&colorLut);
}

void FunctionDispatch::handle_xrUpdatePassthroughColorLutMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUpdatePassthroughColorLutMETA", function_loader.UpdatePassthroughColorLutMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrPassthroughColorLutMETA colorLut{};
    deserialize(&colorLut, d_ctx);
    XrPassthroughColorLutUpdateInfoMETA* updateInfo{};
    deserialize_ptr(&updateInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.UpdatePassthroughColorLutMETA(colorLut, updateInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&colorLut);
    cleanup_ptr(updateInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_passthrough_color_lut
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_preferences
void FunctionDispatch::handle_xrGetPassthroughPreferencesMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetPassthroughPreferencesMETA", function_loader.GetPassthroughPreferencesMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPassthroughPreferencesMETA* preferences{};
    deserialize_ptr(&preferences, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetPassthroughPreferencesMETA(session, preferences);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(preferences, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(preferences, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_passthrough_preferences
#ifdef XRTRANSPORT_EXT_XR_META_performance_metrics
void FunctionDispatch::handle_xrEnumeratePerformanceMetricsCounterPathsMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumeratePerformanceMetricsCounterPathsMETA", function_loader.EnumeratePerformanceMetricsCounterPathsMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    uint32_t counterPathCapacityInput{};
    deserialize(&counterPathCapacityInput, d_ctx);
    uint32_t* counterPathCountOutput{};
    deserialize_ptr(&counterPathCountOutput, d_ctx);
    XrPath* counterPaths{};
    deserialize_ptr(&counterPaths, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumeratePerformanceMetricsCounterPathsMETA(instance, counterPathCapacityInput, counterPathCountOutput, counterPaths);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(counterPathCountOutput, 1, s_ctx);
    serialize_ptr(counterPaths, counterPathCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&counterPathCapacityInput);
    cleanup_ptr(counterPathCountOutput, 1);
    cleanup_ptr(counterPaths, counterPathCapacityInput);
}

void FunctionDispatch::handle_xrGetPerformanceMetricsStateMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetPerformanceMetricsStateMETA", function_loader.GetPerformanceMetricsStateMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPerformanceMetricsStateMETA* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetPerformanceMetricsStateMETA(session, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrQueryPerformanceMetricsCounterMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQueryPerformanceMetricsCounterMETA", function_loader.QueryPerformanceMetricsCounterMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath counterPath{};
    deserialize(&counterPath, d_ctx);
    XrPerformanceMetricsCounterMETA* counter{};
    deserialize_ptr(&counter, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.QueryPerformanceMetricsCounterMETA(session, counterPath, counter);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(counter, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&counterPath);
    cleanup_ptr(counter, 1);
}

void FunctionDispatch::handle_xrSetPerformanceMetricsStateMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetPerformanceMetricsStateMETA", function_loader.SetPerformanceMetricsStateMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPerformanceMetricsStateMETA* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetPerformanceMetricsStateMETA(session, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(state, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_performance_metrics
#ifdef XRTRANSPORT_EXT_XR_META_recommended_layer_resolution
void FunctionDispatch::handle_xrGetRecommendedLayerResolutionMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetRecommendedLayerResolutionMETA", function_loader.GetRecommendedLayerResolutionMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrRecommendedLayerResolutionGetInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrRecommendedLayerResolutionMETA* resolution{};
    deserialize_ptr(&resolution, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetRecommendedLayerResolutionMETA(session, info, resolution);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(resolution, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(resolution, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_recommended_layer_resolution
#ifdef XRTRANSPORT_EXT_XR_META_simultaneous_hands_and_controllers
void FunctionDispatch::handle_xrPauseSimultaneousHandsAndControllersTrackingMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPauseSimultaneousHandsAndControllersTrackingMETA", function_loader.PauseSimultaneousHandsAndControllersTrackingMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSimultaneousHandsAndControllersTrackingPauseInfoMETA* pauseInfo{};
    deserialize_ptr(&pauseInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PauseSimultaneousHandsAndControllersTrackingMETA(session, pauseInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(pauseInfo, 1);
}

void FunctionDispatch::handle_xrResumeSimultaneousHandsAndControllersTrackingMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrResumeSimultaneousHandsAndControllersTrackingMETA", function_loader.ResumeSimultaneousHandsAndControllersTrackingMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSimultaneousHandsAndControllersTrackingResumeInfoMETA* resumeInfo{};
    deserialize_ptr(&resumeInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ResumeSimultaneousHandsAndControllersTrackingMETA(session, resumeInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(resumeInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_simultaneous_hands_and_controllers
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_mesh
void FunctionDispatch::handle_xrGetSpaceTriangleMeshMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpaceTriangleMeshMETA", function_loader.GetSpaceTriangleMeshMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrSpaceTriangleMeshGetInfoMETA* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrSpaceTriangleMeshMETA* triangleMeshOutput{};
    deserialize_ptr(&triangleMeshOutput, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpaceTriangleMeshMETA(space, getInfo, triangleMeshOutput);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(triangleMeshOutput, 1, s_ctx);
    msg_out.flush();

    cleanup(&space);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(triangleMeshOutput, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_mesh
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_sharing
void FunctionDispatch::handle_xrShareSpacesMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrShareSpacesMETA", function_loader.ShareSpacesMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrShareSpacesInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrAsyncRequestIdFB* requestId{};
    deserialize_ptr(&requestId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ShareSpacesMETA(session, info, requestId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(info->spaces, info->spaceCount, s_ctx);
    serialize_ptr(requestId, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
    cleanup_ptr(requestId, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_sharing
#ifdef XRTRANSPORT_EXT_XR_META_virtual_keyboard
void FunctionDispatch::handle_xrChangeVirtualKeyboardTextContextMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrChangeVirtualKeyboardTextContextMETA", function_loader.ChangeVirtualKeyboardTextContextMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    XrVirtualKeyboardTextContextChangeInfoMETA* changeInfo{};
    deserialize_ptr(&changeInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ChangeVirtualKeyboardTextContextMETA(keyboard, changeInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup_ptr(changeInfo, 1);
}

void FunctionDispatch::handle_xrCreateVirtualKeyboardMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateVirtualKeyboardMETA", function_loader.CreateVirtualKeyboardMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrVirtualKeyboardCreateInfoMETA* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrVirtualKeyboardMETA* keyboard{};
    deserialize_ptr(&keyboard, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateVirtualKeyboardMETA(session, createInfo, keyboard);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(keyboard, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(keyboard, 1);
}

void FunctionDispatch::handle_xrCreateVirtualKeyboardSpaceMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateVirtualKeyboardSpaceMETA", function_loader.CreateVirtualKeyboardSpaceMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    XrVirtualKeyboardSpaceCreateInfoMETA* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* keyboardSpace{};
    deserialize_ptr(&keyboardSpace, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateVirtualKeyboardSpaceMETA(session, keyboard, createInfo, keyboardSpace);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(keyboardSpace, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&keyboard);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(keyboardSpace, 1);
}

void FunctionDispatch::handle_xrDestroyVirtualKeyboardMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyVirtualKeyboardMETA", function_loader.DestroyVirtualKeyboardMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyVirtualKeyboardMETA(keyboard);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
}

void FunctionDispatch::handle_xrGetVirtualKeyboardDirtyTexturesMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVirtualKeyboardDirtyTexturesMETA", function_loader.GetVirtualKeyboardDirtyTexturesMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    uint32_t textureIdCapacityInput{};
    deserialize(&textureIdCapacityInput, d_ctx);
    uint32_t* textureIdCountOutput{};
    deserialize_ptr(&textureIdCountOutput, d_ctx);
    uint64_t* textureIds{};
    deserialize_ptr(&textureIds, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetVirtualKeyboardDirtyTexturesMETA(keyboard, textureIdCapacityInput, textureIdCountOutput, textureIds);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(textureIdCountOutput, 1, s_ctx);
    serialize_ptr(textureIds, textureIdCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup(&textureIdCapacityInput);
    cleanup_ptr(textureIdCountOutput, 1);
    cleanup_ptr(textureIds, textureIdCapacityInput);
}

void FunctionDispatch::handle_xrGetVirtualKeyboardModelAnimationStatesMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVirtualKeyboardModelAnimationStatesMETA", function_loader.GetVirtualKeyboardModelAnimationStatesMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    XrVirtualKeyboardModelAnimationStatesMETA* animationStates{};
    deserialize_ptr(&animationStates, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetVirtualKeyboardModelAnimationStatesMETA(keyboard, animationStates);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(animationStates, 1, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup_ptr(animationStates, 1);
}

void FunctionDispatch::handle_xrGetVirtualKeyboardScaleMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVirtualKeyboardScaleMETA", function_loader.GetVirtualKeyboardScaleMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    float* scale{};
    deserialize_ptr(&scale, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetVirtualKeyboardScaleMETA(keyboard, scale);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(scale, 1, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup_ptr(scale, 1);
}

void FunctionDispatch::handle_xrGetVirtualKeyboardTextureDataMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetVirtualKeyboardTextureDataMETA", function_loader.GetVirtualKeyboardTextureDataMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    uint64_t textureId{};
    deserialize(&textureId, d_ctx);
    XrVirtualKeyboardTextureDataMETA* textureData{};
    deserialize_ptr(&textureData, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetVirtualKeyboardTextureDataMETA(keyboard, textureId, textureData);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(textureData, 1, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup(&textureId);
    cleanup_ptr(textureData, 1);
}

void FunctionDispatch::handle_xrSendVirtualKeyboardInputMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSendVirtualKeyboardInputMETA", function_loader.SendVirtualKeyboardInputMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    XrVirtualKeyboardInputInfoMETA* info{};
    deserialize_ptr(&info, d_ctx);
    XrPosef* interactorRootPose{};
    deserialize_ptr(&interactorRootPose, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SendVirtualKeyboardInputMETA(keyboard, info, interactorRootPose);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(interactorRootPose, 1, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup_ptr(info, 1);
    cleanup_ptr(interactorRootPose, 1);
}

void FunctionDispatch::handle_xrSetVirtualKeyboardModelVisibilityMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetVirtualKeyboardModelVisibilityMETA", function_loader.SetVirtualKeyboardModelVisibilityMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    XrVirtualKeyboardModelVisibilitySetInfoMETA* modelVisibility{};
    deserialize_ptr(&modelVisibility, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetVirtualKeyboardModelVisibilityMETA(keyboard, modelVisibility);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup_ptr(modelVisibility, 1);
}

void FunctionDispatch::handle_xrSuggestVirtualKeyboardLocationMETA(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSuggestVirtualKeyboardLocationMETA", function_loader.SuggestVirtualKeyboardLocationMETA);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrVirtualKeyboardMETA keyboard{};
    deserialize(&keyboard, d_ctx);
    XrVirtualKeyboardLocationInfoMETA* locationInfo{};
    deserialize_ptr(&locationInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SuggestVirtualKeyboardLocationMETA(keyboard, locationInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&keyboard);
    cleanup_ptr(locationInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_META_virtual_keyboard
#ifdef XRTRANSPORT_EXT_XR_ML_compat
void FunctionDispatch::handle_xrCreateSpaceFromCoordinateFrameUIDML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpaceFromCoordinateFrameUIDML", function_loader.CreateSpaceFromCoordinateFrameUIDML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrCoordinateSpaceCreateInfoML* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpaceFromCoordinateFrameUIDML(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_compat
#ifdef XRTRANSPORT_EXT_XR_ML_facial_expression
void FunctionDispatch::handle_xrCreateFacialExpressionClientML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateFacialExpressionClientML", function_loader.CreateFacialExpressionClientML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFacialExpressionClientCreateInfoML* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrFacialExpressionClientML* facialExpressionClient{};
    deserialize_ptr(&facialExpressionClient, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateFacialExpressionClientML(session, createInfo, facialExpressionClient);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(facialExpressionClient, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(facialExpressionClient, 1);
}

void FunctionDispatch::handle_xrDestroyFacialExpressionClientML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyFacialExpressionClientML", function_loader.DestroyFacialExpressionClientML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrFacialExpressionClientML facialExpressionClient{};
    deserialize(&facialExpressionClient, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyFacialExpressionClientML(facialExpressionClient);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&facialExpressionClient);
}

void FunctionDispatch::handle_xrGetFacialExpressionBlendShapePropertiesML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetFacialExpressionBlendShapePropertiesML", function_loader.GetFacialExpressionBlendShapePropertiesML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrFacialExpressionClientML facialExpressionClient{};
    deserialize(&facialExpressionClient, d_ctx);
    XrFacialExpressionBlendShapeGetInfoML* blendShapeGetInfo{};
    deserialize_ptr(&blendShapeGetInfo, d_ctx);
    uint32_t blendShapeCount{};
    deserialize(&blendShapeCount, d_ctx);
    XrFacialExpressionBlendShapePropertiesML* blendShapes{};
    deserialize_ptr(&blendShapes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetFacialExpressionBlendShapePropertiesML(facialExpressionClient, blendShapeGetInfo, blendShapeCount, blendShapes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(blendShapes, blendShapeCount, s_ctx);
    msg_out.flush();

    cleanup(&facialExpressionClient);
    cleanup_ptr(blendShapeGetInfo, 1);
    cleanup(&blendShapeCount);
    cleanup_ptr(blendShapes, blendShapeCount);
}

#endif // XRTRANSPORT_EXT_XR_ML_facial_expression
#ifdef XRTRANSPORT_EXT_XR_ML_localization_map
void FunctionDispatch::handle_xrCreateExportedLocalizationMapML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateExportedLocalizationMapML", function_loader.CreateExportedLocalizationMapML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrUuidEXT* mapUuid{};
    deserialize_ptr(&mapUuid, d_ctx);
    XrExportedLocalizationMapML* map{};
    deserialize_ptr(&map, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateExportedLocalizationMapML(session, mapUuid, map);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(map, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(mapUuid, 1);
    cleanup_ptr(map, 1);
}

void FunctionDispatch::handle_xrDestroyExportedLocalizationMapML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyExportedLocalizationMapML", function_loader.DestroyExportedLocalizationMapML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrExportedLocalizationMapML map{};
    deserialize(&map, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyExportedLocalizationMapML(map);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&map);
}

void FunctionDispatch::handle_xrEnableLocalizationEventsML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnableLocalizationEventsML", function_loader.EnableLocalizationEventsML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrLocalizationEnableEventsInfoML* info{};
    deserialize_ptr(&info, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnableLocalizationEventsML(session, info);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(info, 1);
}

void FunctionDispatch::handle_xrGetExportedLocalizationMapDataML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetExportedLocalizationMapDataML", function_loader.GetExportedLocalizationMapDataML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrExportedLocalizationMapML map{};
    deserialize(&map, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetExportedLocalizationMapDataML(map, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&map);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

void FunctionDispatch::handle_xrImportLocalizationMapML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrImportLocalizationMapML", function_loader.ImportLocalizationMapML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrLocalizationMapImportInfoML* importInfo{};
    deserialize_ptr(&importInfo, d_ctx);
    XrUuidEXT* mapUuid{};
    deserialize_ptr(&mapUuid, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ImportLocalizationMapML(session, importInfo, mapUuid);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(importInfo->data, importInfo->size, s_ctx);
    serialize_ptr(mapUuid, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(importInfo, 1);
    cleanup_ptr(mapUuid, 1);
}

void FunctionDispatch::handle_xrQueryLocalizationMapsML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQueryLocalizationMapsML", function_loader.QueryLocalizationMapsML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrLocalizationMapQueryInfoBaseHeaderML* queryInfo{};
    deserialize_xr(&queryInfo, d_ctx);
    uint32_t mapCapacityInput{};
    deserialize(&mapCapacityInput, d_ctx);
    uint32_t* mapCountOutput{};
    deserialize_ptr(&mapCountOutput, d_ctx);
    XrLocalizationMapML* maps{};
    deserialize_ptr(&maps, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.QueryLocalizationMapsML(session, queryInfo, mapCapacityInput, mapCountOutput, maps);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(mapCountOutput, 1, s_ctx);
    serialize_ptr(maps, mapCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_xr(queryInfo);
    cleanup(&mapCapacityInput);
    cleanup_ptr(mapCountOutput, 1);
    cleanup_ptr(maps, mapCapacityInput);
}

void FunctionDispatch::handle_xrRequestMapLocalizationML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestMapLocalizationML", function_loader.RequestMapLocalizationML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrMapLocalizationRequestInfoML* requestInfo{};
    deserialize_ptr(&requestInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.RequestMapLocalizationML(session, requestInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(requestInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_localization_map
#ifdef XRTRANSPORT_EXT_XR_ML_marker_understanding
void FunctionDispatch::handle_xrCreateMarkerDetectorML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateMarkerDetectorML", function_loader.CreateMarkerDetectorML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrMarkerDetectorCreateInfoML* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrMarkerDetectorML* markerDetector{};
    deserialize_ptr(&markerDetector, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateMarkerDetectorML(session, createInfo, markerDetector);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(markerDetector, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(markerDetector, 1);
}

void FunctionDispatch::handle_xrCreateMarkerSpaceML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateMarkerSpaceML", function_loader.CreateMarkerSpaceML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrMarkerSpaceCreateInfoML* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateMarkerSpaceML(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrDestroyMarkerDetectorML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyMarkerDetectorML", function_loader.DestroyMarkerDetectorML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyMarkerDetectorML(markerDetector);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
}

void FunctionDispatch::handle_xrGetMarkerDetectorStateML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkerDetectorStateML", function_loader.GetMarkerDetectorStateML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    XrMarkerDetectorStateML* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetMarkerDetectorStateML(markerDetector, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetMarkerLengthML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkerLengthML", function_loader.GetMarkerLengthML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    XrMarkerML marker{};
    deserialize(&marker, d_ctx);
    float* meters{};
    deserialize_ptr(&meters, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetMarkerLengthML(markerDetector, marker, meters);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(meters, 1, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup(&marker);
    cleanup_ptr(meters, 1);
}

void FunctionDispatch::handle_xrGetMarkerNumberML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkerNumberML", function_loader.GetMarkerNumberML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    XrMarkerML marker{};
    deserialize(&marker, d_ctx);
    uint64_t* number{};
    deserialize_ptr(&number, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetMarkerNumberML(markerDetector, marker, number);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(number, 1, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup(&marker);
    cleanup_ptr(number, 1);
}

void FunctionDispatch::handle_xrGetMarkerReprojectionErrorML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkerReprojectionErrorML", function_loader.GetMarkerReprojectionErrorML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    XrMarkerML marker{};
    deserialize(&marker, d_ctx);
    float* reprojectionErrorMeters{};
    deserialize_ptr(&reprojectionErrorMeters, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetMarkerReprojectionErrorML(markerDetector, marker, reprojectionErrorMeters);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(reprojectionErrorMeters, 1, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup(&marker);
    cleanup_ptr(reprojectionErrorMeters, 1);
}

void FunctionDispatch::handle_xrGetMarkerStringML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkerStringML", function_loader.GetMarkerStringML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    XrMarkerML marker{};
    deserialize(&marker, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetMarkerStringML(markerDetector, marker, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup(&marker);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

void FunctionDispatch::handle_xrGetMarkersML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkersML", function_loader.GetMarkersML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    uint32_t markerCapacityInput{};
    deserialize(&markerCapacityInput, d_ctx);
    uint32_t* markerCountOutput{};
    deserialize_ptr(&markerCountOutput, d_ctx);
    XrMarkerML* markers{};
    deserialize_ptr(&markers, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetMarkersML(markerDetector, markerCapacityInput, markerCountOutput, markers);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(markerCountOutput, 1, s_ctx);
    serialize_ptr(markers, markerCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup(&markerCapacityInput);
    cleanup_ptr(markerCountOutput, 1);
    cleanup_ptr(markers, markerCapacityInput);
}

void FunctionDispatch::handle_xrSnapshotMarkerDetectorML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSnapshotMarkerDetectorML", function_loader.SnapshotMarkerDetectorML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrMarkerDetectorML markerDetector{};
    deserialize(&markerDetector, d_ctx);
    XrMarkerDetectorSnapshotInfoML* snapshotInfo{};
    deserialize_ptr(&snapshotInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SnapshotMarkerDetectorML(markerDetector, snapshotInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(snapshotInfo, 1, s_ctx);
    msg_out.flush();

    cleanup(&markerDetector);
    cleanup_ptr(snapshotInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_marker_understanding
#ifdef XRTRANSPORT_EXT_XR_ML_spatial_anchors
void FunctionDispatch::handle_xrCreateSpatialAnchorsAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorsAsyncML", function_loader.CreateSpatialAnchorsAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorsCreateInfoBaseHeaderML* createInfo{};
    deserialize_xr(&createInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialAnchorsAsyncML(session, createInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_xr(createInfo);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrCreateSpatialAnchorsCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorsCompleteML", function_loader.CreateSpatialAnchorsCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrCreateSpatialAnchorsCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialAnchorsCompleteML(session, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrGetSpatialAnchorStateML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpatialAnchorStateML", function_loader.GetSpatialAnchorStateML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpace anchor{};
    deserialize(&anchor, d_ctx);
    XrSpatialAnchorStateML* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpatialAnchorStateML(anchor, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&anchor);
    cleanup_ptr(state, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_spatial_anchors
#ifdef XRTRANSPORT_EXT_XR_ML_spatial_anchors_storage
void FunctionDispatch::handle_xrCreateSpatialAnchorsStorageML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorsStorageML", function_loader.CreateSpatialAnchorsStorageML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorsCreateStorageInfoML* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpatialAnchorsStorageML* storage{};
    deserialize_ptr(&storage, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialAnchorsStorageML(session, createInfo, storage);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(storage, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(storage, 1);
}

void FunctionDispatch::handle_xrDeleteSpatialAnchorsAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDeleteSpatialAnchorsAsyncML", function_loader.DeleteSpatialAnchorsAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrSpatialAnchorsDeleteInfoML* deleteInfo{};
    deserialize_ptr(&deleteInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DeleteSpatialAnchorsAsyncML(storage, deleteInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup_ptr(deleteInfo, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrDeleteSpatialAnchorsCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDeleteSpatialAnchorsCompleteML", function_loader.DeleteSpatialAnchorsCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrSpatialAnchorsDeleteCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DeleteSpatialAnchorsCompleteML(storage, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrDestroySpatialAnchorsStorageML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySpatialAnchorsStorageML", function_loader.DestroySpatialAnchorsStorageML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroySpatialAnchorsStorageML(storage);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&storage);
}

void FunctionDispatch::handle_xrPublishSpatialAnchorsAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPublishSpatialAnchorsAsyncML", function_loader.PublishSpatialAnchorsAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrSpatialAnchorsPublishInfoML* publishInfo{};
    deserialize_ptr(&publishInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PublishSpatialAnchorsAsyncML(storage, publishInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup_ptr(publishInfo, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrPublishSpatialAnchorsCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPublishSpatialAnchorsCompleteML", function_loader.PublishSpatialAnchorsCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrSpatialAnchorsPublishCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PublishSpatialAnchorsCompleteML(storage, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrQuerySpatialAnchorsAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQuerySpatialAnchorsAsyncML", function_loader.QuerySpatialAnchorsAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrSpatialAnchorsQueryInfoBaseHeaderML* queryInfo{};
    deserialize_xr(&queryInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.QuerySpatialAnchorsAsyncML(storage, queryInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup_xr(queryInfo);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrQuerySpatialAnchorsCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrQuerySpatialAnchorsCompleteML", function_loader.QuerySpatialAnchorsCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrSpatialAnchorsQueryCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.QuerySpatialAnchorsCompleteML(storage, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrUpdateSpatialAnchorsExpirationAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUpdateSpatialAnchorsExpirationAsyncML", function_loader.UpdateSpatialAnchorsExpirationAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrSpatialAnchorsUpdateExpirationInfoML* updateInfo{};
    deserialize_ptr(&updateInfo, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.UpdateSpatialAnchorsExpirationAsyncML(storage, updateInfo, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup_ptr(updateInfo, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrUpdateSpatialAnchorsExpirationCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUpdateSpatialAnchorsExpirationCompleteML", function_loader.UpdateSpatialAnchorsExpirationCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorsStorageML storage{};
    deserialize(&storage, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrSpatialAnchorsUpdateExpirationCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.UpdateSpatialAnchorsExpirationCompleteML(storage, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&storage);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_spatial_anchors_storage
#ifdef XRTRANSPORT_EXT_XR_ML_system_notifications
void FunctionDispatch::handle_xrSetSystemNotificationsML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetSystemNotificationsML", function_loader.SetSystemNotificationsML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemNotificationsSetInfoML* info{};
    deserialize_ptr(&info, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetSystemNotificationsML(instance, info);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(info, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_system_notifications
#ifdef XRTRANSPORT_EXT_XR_ML_user_calibration
void FunctionDispatch::handle_xrEnableUserCalibrationEventsML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnableUserCalibrationEventsML", function_loader.EnableUserCalibrationEventsML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrUserCalibrationEnableEventsInfoML* enableInfo{};
    deserialize_ptr(&enableInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnableUserCalibrationEventsML(instance, enableInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(enableInfo, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_user_calibration
#ifdef XRTRANSPORT_EXT_XR_ML_world_mesh_detection
void FunctionDispatch::handle_xrAllocateWorldMeshBufferML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrAllocateWorldMeshBufferML", function_loader.AllocateWorldMeshBufferML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrWorldMeshBufferSizeML* size{};
    deserialize_ptr(&size, d_ctx);
    XrWorldMeshBufferML* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.AllocateWorldMeshBufferML(detector, size, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(size->next, s_ctx);
    serialize_ptr(buffer, 1, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup_ptr(size, 1);
    cleanup_ptr(buffer, 1);
}

void FunctionDispatch::handle_xrCreateWorldMeshDetectorML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateWorldMeshDetectorML", function_loader.CreateWorldMeshDetectorML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrWorldMeshDetectorCreateInfoML* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrWorldMeshDetectorML* detector{};
    deserialize_ptr(&detector, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateWorldMeshDetectorML(session, createInfo, detector);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(detector, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(detector, 1);
}

void FunctionDispatch::handle_xrDestroyWorldMeshDetectorML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyWorldMeshDetectorML", function_loader.DestroyWorldMeshDetectorML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyWorldMeshDetectorML(detector);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&detector);
}

void FunctionDispatch::handle_xrFreeWorldMeshBufferML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrFreeWorldMeshBufferML", function_loader.FreeWorldMeshBufferML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrWorldMeshBufferML* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.FreeWorldMeshBufferML(detector, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_xr(buffer->next, s_ctx);
    serialize_ptr(buffer->buffer, buffer->bufferSize, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup_ptr(buffer, 1);
}

void FunctionDispatch::handle_xrGetWorldMeshBufferRecommendSizeML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetWorldMeshBufferRecommendSizeML", function_loader.GetWorldMeshBufferRecommendSizeML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrWorldMeshBufferRecommendedSizeInfoML* sizeInfo{};
    deserialize_ptr(&sizeInfo, d_ctx);
    XrWorldMeshBufferSizeML* size{};
    deserialize_ptr(&size, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetWorldMeshBufferRecommendSizeML(detector, sizeInfo, size);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(size, 1, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup_ptr(sizeInfo, 1);
    cleanup_ptr(size, 1);
}

void FunctionDispatch::handle_xrRequestWorldMeshAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestWorldMeshAsyncML", function_loader.RequestWorldMeshAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrWorldMeshGetInfoML* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrWorldMeshBufferML* buffer{};
    deserialize_ptr(&buffer, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.RequestWorldMeshAsyncML(detector, getInfo, buffer, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(getInfo->blocks, getInfo->blockCount, s_ctx);
    serialize_ptr(buffer, 1, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(buffer, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrRequestWorldMeshCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestWorldMeshCompleteML", function_loader.RequestWorldMeshCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrWorldMeshRequestCompletionInfoML* completionInfo{};
    deserialize_ptr(&completionInfo, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrWorldMeshRequestCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.RequestWorldMeshCompleteML(detector, completionInfo, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup_ptr(completionInfo, 1);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

void FunctionDispatch::handle_xrRequestWorldMeshStateAsyncML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestWorldMeshStateAsyncML", function_loader.RequestWorldMeshStateAsyncML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrWorldMeshStateRequestInfoML* stateRequest{};
    deserialize_ptr(&stateRequest, d_ctx);
    XrFutureEXT* future{};
    deserialize_ptr(&future, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.RequestWorldMeshStateAsyncML(detector, stateRequest, future);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(future, 1, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup_ptr(stateRequest, 1);
    cleanup_ptr(future, 1);
}

void FunctionDispatch::handle_xrRequestWorldMeshStateCompleteML(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestWorldMeshStateCompleteML", function_loader.RequestWorldMeshStateCompleteML);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrWorldMeshDetectorML detector{};
    deserialize(&detector, d_ctx);
    XrFutureEXT future{};
    deserialize(&future, d_ctx);
    XrWorldMeshStateRequestCompletionML* completion{};
    deserialize_ptr(&completion, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.RequestWorldMeshStateCompleteML(detector, future, completion);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(completion, 1, s_ctx);
    msg_out.flush();

    cleanup(&detector);
    cleanup(&future);
    cleanup_ptr(completion, 1);
}

#endif // XRTRANSPORT_EXT_XR_ML_world_mesh_detection
#ifdef XRTRANSPORT_EXT_XR_MNDX_force_feedback_curl
void FunctionDispatch::handle_xrApplyForceFeedbackCurlMNDX(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrApplyForceFeedbackCurlMNDX", function_loader.ApplyForceFeedbackCurlMNDX);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrHandTrackerEXT handTracker{};
    deserialize(&handTracker, d_ctx);
    XrForceFeedbackCurlApplyLocationsMNDX* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ApplyForceFeedbackCurlMNDX(handTracker, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations->locations, locations->locationCount, s_ctx);
    msg_out.flush();

    cleanup(&handTracker);
    cleanup_ptr(locations, 1);
}

#endif // XRTRANSPORT_EXT_XR_MNDX_force_feedback_curl
#ifdef XRTRANSPORT_EXT_XR_MSFT_composition_layer_reprojection
void FunctionDispatch::handle_xrEnumerateReprojectionModesMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateReprojectionModesMSFT", function_loader.EnumerateReprojectionModesMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrViewConfigurationType viewConfigurationType{};
    deserialize(&viewConfigurationType, d_ctx);
    uint32_t modeCapacityInput{};
    deserialize(&modeCapacityInput, d_ctx);
    uint32_t* modeCountOutput{};
    deserialize_ptr(&modeCountOutput, d_ctx);
    XrReprojectionModeMSFT* modes{};
    deserialize_ptr(&modes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateReprojectionModesMSFT(instance, systemId, viewConfigurationType, modeCapacityInput, modeCountOutput, modes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(modeCountOutput, 1, s_ctx);
    serialize_ptr(modes, modeCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&viewConfigurationType);
    cleanup(&modeCapacityInput);
    cleanup_ptr(modeCountOutput, 1);
    cleanup_ptr(modes, modeCapacityInput);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_composition_layer_reprojection
#ifdef XRTRANSPORT_EXT_XR_MSFT_controller_model
void FunctionDispatch::handle_xrGetControllerModelKeyMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetControllerModelKeyMSFT", function_loader.GetControllerModelKeyMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath topLevelUserPath{};
    deserialize(&topLevelUserPath, d_ctx);
    XrControllerModelKeyStateMSFT* controllerModelKeyState{};
    deserialize_ptr(&controllerModelKeyState, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetControllerModelKeyMSFT(session, topLevelUserPath, controllerModelKeyState);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(controllerModelKeyState, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&topLevelUserPath);
    cleanup_ptr(controllerModelKeyState, 1);
}

void FunctionDispatch::handle_xrGetControllerModelPropertiesMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetControllerModelPropertiesMSFT", function_loader.GetControllerModelPropertiesMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrControllerModelKeyMSFT modelKey{};
    deserialize(&modelKey, d_ctx);
    XrControllerModelPropertiesMSFT* properties{};
    deserialize_ptr(&properties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetControllerModelPropertiesMSFT(session, modelKey, properties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(properties, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&modelKey);
    cleanup_ptr(properties, 1);
}

void FunctionDispatch::handle_xrGetControllerModelStateMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetControllerModelStateMSFT", function_loader.GetControllerModelStateMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrControllerModelKeyMSFT modelKey{};
    deserialize(&modelKey, d_ctx);
    XrControllerModelStateMSFT* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetControllerModelStateMSFT(session, modelKey, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&modelKey);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrLoadControllerModelMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLoadControllerModelMSFT", function_loader.LoadControllerModelMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrControllerModelKeyMSFT modelKey{};
    deserialize(&modelKey, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    uint8_t* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.LoadControllerModelMSFT(session, modelKey, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&modelKey);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_controller_model
#ifdef XRTRANSPORT_EXT_XR_MSFT_hand_tracking_mesh
void FunctionDispatch::handle_xrCreateHandMeshSpaceMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateHandMeshSpaceMSFT", function_loader.CreateHandMeshSpaceMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrHandTrackerEXT handTracker{};
    deserialize(&handTracker, d_ctx);
    XrHandMeshSpaceCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateHandMeshSpaceMSFT(handTracker, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&handTracker);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrUpdateHandMeshMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUpdateHandMeshMSFT", function_loader.UpdateHandMeshMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrHandTrackerEXT handTracker{};
    deserialize(&handTracker, d_ctx);
    XrHandMeshUpdateInfoMSFT* updateInfo{};
    deserialize_ptr(&updateInfo, d_ctx);
    XrHandMeshMSFT* handMesh{};
    deserialize_ptr(&handMesh, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.UpdateHandMeshMSFT(handTracker, updateInfo, handMesh);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(handMesh, 1, s_ctx);
    msg_out.flush();

    cleanup(&handTracker);
    cleanup_ptr(updateInfo, 1);
    cleanup_ptr(handMesh, 1);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_hand_tracking_mesh
#ifdef XRTRANSPORT_EXT_XR_MSFT_perception_anchor_interop
void FunctionDispatch::handle_xrCreateSpatialAnchorFromPerceptionAnchorMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorFromPerceptionAnchorMSFT", function_loader.CreateSpatialAnchorFromPerceptionAnchorMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    IUnknown* perceptionAnchor{};
    deserialize_ptr(&perceptionAnchor, d_ctx);
    XrSpatialAnchorMSFT* anchor{};
    deserialize_ptr(&anchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialAnchorFromPerceptionAnchorMSFT(session, perceptionAnchor, anchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(perceptionAnchor, 1, s_ctx);
    serialize_ptr(anchor, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(perceptionAnchor, 1);
    cleanup_ptr(anchor, 1);
}

void FunctionDispatch::handle_xrTryGetPerceptionAnchorFromSpatialAnchorMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTryGetPerceptionAnchorFromSpatialAnchorMSFT", function_loader.TryGetPerceptionAnchorFromSpatialAnchorMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorMSFT anchor{};
    deserialize(&anchor, d_ctx);
    IUnknown** perceptionAnchor{};
    #error "auto-generator doesn't support double pointers (perceptionAnchor)"None

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.TryGetPerceptionAnchorFromSpatialAnchorMSFT(session, anchor, perceptionAnchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(perceptionAnchor, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&anchor);
    #error "auto-generator doesn't support double pointers (perceptionAnchor)"None
}

#endif // XRTRANSPORT_EXT_XR_MSFT_perception_anchor_interop
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_marker
void FunctionDispatch::handle_xrGetSceneMarkerDecodedStringMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSceneMarkerDecodedStringMSFT", function_loader.GetSceneMarkerDecodedStringMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);
    XrUuidMSFT* markerId{};
    deserialize_ptr(&markerId, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSceneMarkerDecodedStringMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&scene);
    cleanup_ptr(markerId, 1);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

void FunctionDispatch::handle_xrGetSceneMarkerRawDataMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSceneMarkerRawDataMSFT", function_loader.GetSceneMarkerRawDataMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);
    XrUuidMSFT* markerId{};
    deserialize_ptr(&markerId, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    uint8_t* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSceneMarkerRawDataMSFT(scene, markerId, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&scene);
    cleanup_ptr(markerId, 1);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_scene_marker
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_understanding
void FunctionDispatch::handle_xrComputeNewSceneMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrComputeNewSceneMSFT", function_loader.ComputeNewSceneMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSceneObserverMSFT sceneObserver{};
    deserialize(&sceneObserver, d_ctx);
    XrNewSceneComputeInfoMSFT* computeInfo{};
    deserialize_ptr(&computeInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ComputeNewSceneMSFT(sceneObserver, computeInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&sceneObserver);
    cleanup_ptr(computeInfo, 1);
}

void FunctionDispatch::handle_xrCreateSceneMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSceneMSFT", function_loader.CreateSceneMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSceneObserverMSFT sceneObserver{};
    deserialize(&sceneObserver, d_ctx);
    XrSceneCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSceneMSFT* scene{};
    deserialize_ptr(&scene, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSceneMSFT(sceneObserver, createInfo, scene);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(scene, 1, s_ctx);
    msg_out.flush();

    cleanup(&sceneObserver);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(scene, 1);
}

void FunctionDispatch::handle_xrCreateSceneObserverMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSceneObserverMSFT", function_loader.CreateSceneObserverMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSceneObserverCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSceneObserverMSFT* sceneObserver{};
    deserialize_ptr(&sceneObserver, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSceneObserverMSFT(session, createInfo, sceneObserver);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(sceneObserver, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(sceneObserver, 1);
}

void FunctionDispatch::handle_xrDestroySceneMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySceneMSFT", function_loader.DestroySceneMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroySceneMSFT(scene);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&scene);
}

void FunctionDispatch::handle_xrDestroySceneObserverMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySceneObserverMSFT", function_loader.DestroySceneObserverMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSceneObserverMSFT sceneObserver{};
    deserialize(&sceneObserver, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroySceneObserverMSFT(sceneObserver);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&sceneObserver);
}

void FunctionDispatch::handle_xrEnumerateSceneComputeFeaturesMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateSceneComputeFeaturesMSFT", function_loader.EnumerateSceneComputeFeaturesMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    uint32_t featureCapacityInput{};
    deserialize(&featureCapacityInput, d_ctx);
    uint32_t* featureCountOutput{};
    deserialize_ptr(&featureCountOutput, d_ctx);
    XrSceneComputeFeatureMSFT* features{};
    deserialize_ptr(&features, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateSceneComputeFeaturesMSFT(instance, systemId, featureCapacityInput, featureCountOutput, features);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(featureCountOutput, 1, s_ctx);
    serialize_ptr(features, featureCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&featureCapacityInput);
    cleanup_ptr(featureCountOutput, 1);
    cleanup_ptr(features, featureCapacityInput);
}

void FunctionDispatch::handle_xrGetSceneComponentsMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSceneComponentsMSFT", function_loader.GetSceneComponentsMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);
    XrSceneComponentsGetInfoMSFT* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrSceneComponentsMSFT* components{};
    deserialize_ptr(&components, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSceneComponentsMSFT(scene, getInfo, components);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(components, 1, s_ctx);
    msg_out.flush();

    cleanup(&scene);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(components, 1);
}

void FunctionDispatch::handle_xrGetSceneComputeStateMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSceneComputeStateMSFT", function_loader.GetSceneComputeStateMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSceneObserverMSFT sceneObserver{};
    deserialize(&sceneObserver, d_ctx);
    XrSceneComputeStateMSFT* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSceneComputeStateMSFT(sceneObserver, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&sceneObserver);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetSceneMeshBuffersMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSceneMeshBuffersMSFT", function_loader.GetSceneMeshBuffersMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);
    XrSceneMeshBuffersGetInfoMSFT* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrSceneMeshBuffersMSFT* buffers{};
    deserialize_ptr(&buffers, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSceneMeshBuffersMSFT(scene, getInfo, buffers);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(buffers, 1, s_ctx);
    msg_out.flush();

    cleanup(&scene);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(buffers, 1);
}

void FunctionDispatch::handle_xrLocateSceneComponentsMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateSceneComponentsMSFT", function_loader.LocateSceneComponentsMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);
    XrSceneComponentsLocateInfoMSFT* locateInfo{};
    deserialize_ptr(&locateInfo, d_ctx);
    XrSceneComponentLocationsMSFT* locations{};
    deserialize_ptr(&locations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.LocateSceneComponentsMSFT(scene, locateInfo, locations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(locations, 1, s_ctx);
    msg_out.flush();

    cleanup(&scene);
    cleanup_ptr(locateInfo, 1);
    cleanup_ptr(locations, 1);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_scene_understanding
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_understanding_serialization
void FunctionDispatch::handle_xrDeserializeSceneMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDeserializeSceneMSFT", function_loader.DeserializeSceneMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSceneObserverMSFT sceneObserver{};
    deserialize(&sceneObserver, d_ctx);
    XrSceneDeserializeInfoMSFT* deserializeInfo{};
    deserialize_ptr(&deserializeInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DeserializeSceneMSFT(sceneObserver, deserializeInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&sceneObserver);
    cleanup_ptr(deserializeInfo, 1);
}

void FunctionDispatch::handle_xrGetSerializedSceneFragmentDataMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSerializedSceneFragmentDataMSFT", function_loader.GetSerializedSceneFragmentDataMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSceneMSFT scene{};
    deserialize(&scene, d_ctx);
    XrSerializedSceneFragmentDataGetInfoMSFT* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    uint32_t countInput{};
    deserialize(&countInput, d_ctx);
    uint32_t* readOutput{};
    deserialize_ptr(&readOutput, d_ctx);
    uint8_t* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSerializedSceneFragmentDataMSFT(scene, getInfo, countInput, readOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(readOutput, 1, s_ctx);
    serialize_ptr(buffer, countInput, s_ctx);
    msg_out.flush();

    cleanup(&scene);
    cleanup_ptr(getInfo, 1);
    cleanup(&countInput);
    cleanup_ptr(readOutput, 1);
    cleanup_ptr(buffer, countInput);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_scene_understanding_serialization
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_anchor
void FunctionDispatch::handle_xrCreateSpatialAnchorMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorMSFT", function_loader.CreateSpatialAnchorMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpatialAnchorMSFT* anchor{};
    deserialize_ptr(&anchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialAnchorMSFT(session, createInfo, anchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(anchor, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(anchor, 1);
}

void FunctionDispatch::handle_xrCreateSpatialAnchorSpaceMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorSpaceMSFT", function_loader.CreateSpatialAnchorSpaceMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorSpaceCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialAnchorSpaceMSFT(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrDestroySpatialAnchorMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySpatialAnchorMSFT", function_loader.DestroySpatialAnchorMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorMSFT anchor{};
    deserialize(&anchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroySpatialAnchorMSFT(anchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&anchor);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_anchor
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_anchor_persistence
void FunctionDispatch::handle_xrClearSpatialAnchorStoreMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrClearSpatialAnchorStoreMSFT", function_loader.ClearSpatialAnchorStoreMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore{};
    deserialize(&spatialAnchorStore, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ClearSpatialAnchorStoreMSFT(spatialAnchorStore);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&spatialAnchorStore);
}

void FunctionDispatch::handle_xrCreateSpatialAnchorFromPersistedNameMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorFromPersistedNameMSFT", function_loader.CreateSpatialAnchorFromPersistedNameMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT* spatialAnchorCreateInfo{};
    deserialize_ptr(&spatialAnchorCreateInfo, d_ctx);
    XrSpatialAnchorMSFT* spatialAnchor{};
    deserialize_ptr(&spatialAnchor, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialAnchorFromPersistedNameMSFT(session, spatialAnchorCreateInfo, spatialAnchor);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(spatialAnchor, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(spatialAnchorCreateInfo, 1);
    cleanup_ptr(spatialAnchor, 1);
}

void FunctionDispatch::handle_xrCreateSpatialAnchorStoreConnectionMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialAnchorStoreConnectionMSFT", function_loader.CreateSpatialAnchorStoreConnectionMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialAnchorStoreConnectionMSFT* spatialAnchorStore{};
    deserialize_ptr(&spatialAnchorStore, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialAnchorStoreConnectionMSFT(session, spatialAnchorStore);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(spatialAnchorStore, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(spatialAnchorStore, 1);
}

void FunctionDispatch::handle_xrDestroySpatialAnchorStoreConnectionMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySpatialAnchorStoreConnectionMSFT", function_loader.DestroySpatialAnchorStoreConnectionMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore{};
    deserialize(&spatialAnchorStore, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroySpatialAnchorStoreConnectionMSFT(spatialAnchorStore);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&spatialAnchorStore);
}

void FunctionDispatch::handle_xrEnumeratePersistedSpatialAnchorNamesMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumeratePersistedSpatialAnchorNamesMSFT", function_loader.EnumeratePersistedSpatialAnchorNamesMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore{};
    deserialize(&spatialAnchorStore, d_ctx);
    uint32_t spatialAnchorNameCapacityInput{};
    deserialize(&spatialAnchorNameCapacityInput, d_ctx);
    uint32_t* spatialAnchorNameCountOutput{};
    deserialize_ptr(&spatialAnchorNameCountOutput, d_ctx);
    XrSpatialAnchorPersistenceNameMSFT* spatialAnchorNames{};
    deserialize_ptr(&spatialAnchorNames, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumeratePersistedSpatialAnchorNamesMSFT(spatialAnchorStore, spatialAnchorNameCapacityInput, spatialAnchorNameCountOutput, spatialAnchorNames);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(spatialAnchorNameCountOutput, 1, s_ctx);
    serialize_ptr(spatialAnchorNames, spatialAnchorNameCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&spatialAnchorStore);
    cleanup(&spatialAnchorNameCapacityInput);
    cleanup_ptr(spatialAnchorNameCountOutput, 1);
    cleanup_ptr(spatialAnchorNames, spatialAnchorNameCapacityInput);
}

void FunctionDispatch::handle_xrPersistSpatialAnchorMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPersistSpatialAnchorMSFT", function_loader.PersistSpatialAnchorMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore{};
    deserialize(&spatialAnchorStore, d_ctx);
    XrSpatialAnchorPersistenceInfoMSFT* spatialAnchorPersistenceInfo{};
    deserialize_ptr(&spatialAnchorPersistenceInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&spatialAnchorStore);
    cleanup_ptr(spatialAnchorPersistenceInfo, 1);
}

void FunctionDispatch::handle_xrUnpersistSpatialAnchorMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrUnpersistSpatialAnchorMSFT", function_loader.UnpersistSpatialAnchorMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore{};
    deserialize(&spatialAnchorStore, d_ctx);
    XrSpatialAnchorPersistenceNameMSFT* spatialAnchorPersistenceName{};
    deserialize_ptr(&spatialAnchorPersistenceName, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.UnpersistSpatialAnchorMSFT(spatialAnchorStore, spatialAnchorPersistenceName);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&spatialAnchorStore);
    cleanup_ptr(spatialAnchorPersistenceName, 1);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_anchor_persistence
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_graph_bridge
void FunctionDispatch::handle_xrCreateSpatialGraphNodeSpaceMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSpatialGraphNodeSpaceMSFT", function_loader.CreateSpatialGraphNodeSpaceMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialGraphNodeSpaceCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSpatialGraphNodeSpaceMSFT(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrDestroySpatialGraphNodeBindingMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySpatialGraphNodeBindingMSFT", function_loader.DestroySpatialGraphNodeBindingMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialGraphNodeBindingMSFT nodeBinding{};
    deserialize(&nodeBinding, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroySpatialGraphNodeBindingMSFT(nodeBinding);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&nodeBinding);
}

void FunctionDispatch::handle_xrGetSpatialGraphNodeBindingPropertiesMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSpatialGraphNodeBindingPropertiesMSFT", function_loader.GetSpatialGraphNodeBindingPropertiesMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpatialGraphNodeBindingMSFT nodeBinding{};
    deserialize(&nodeBinding, d_ctx);
    XrSpatialGraphNodeBindingPropertiesGetInfoMSFT* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrSpatialGraphNodeBindingPropertiesMSFT* properties{};
    deserialize_ptr(&properties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSpatialGraphNodeBindingPropertiesMSFT(nodeBinding, getInfo, properties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(properties, 1, s_ctx);
    msg_out.flush();

    cleanup(&nodeBinding);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(properties, 1);
}

void FunctionDispatch::handle_xrTryCreateSpatialGraphStaticNodeBindingMSFT(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrTryCreateSpatialGraphStaticNodeBindingMSFT", function_loader.TryCreateSpatialGraphStaticNodeBindingMSFT);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpatialGraphStaticNodeBindingCreateInfoMSFT* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpatialGraphNodeBindingMSFT* nodeBinding{};
    deserialize_ptr(&nodeBinding, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.TryCreateSpatialGraphStaticNodeBindingMSFT(session, createInfo, nodeBinding);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(nodeBinding, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(nodeBinding, 1);
}

#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_graph_bridge
#ifdef XRTRANSPORT_EXT_XR_OCULUS_audio_device_guid
void FunctionDispatch::handle_xrGetAudioInputDeviceGuidOculus(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetAudioInputDeviceGuidOculus", function_loader.GetAudioInputDeviceGuidOculus);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS]{};
    deserialize_array(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetAudioInputDeviceGuidOculus(instance, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_array(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS);
}

void FunctionDispatch::handle_xrGetAudioOutputDeviceGuidOculus(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetAudioOutputDeviceGuidOculus", function_loader.GetAudioOutputDeviceGuidOculus);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    wchar_t buffer[XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS]{};
    deserialize_array(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetAudioOutputDeviceGuidOculus(instance, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_array(buffer, XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS);
}

#endif // XRTRANSPORT_EXT_XR_OCULUS_audio_device_guid
#ifdef XRTRANSPORT_EXT_XR_OCULUS_external_camera
void FunctionDispatch::handle_xrEnumerateExternalCamerasOCULUS(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateExternalCamerasOCULUS", function_loader.EnumerateExternalCamerasOCULUS);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint32_t cameraCapacityInput{};
    deserialize(&cameraCapacityInput, d_ctx);
    uint32_t* cameraCountOutput{};
    deserialize_ptr(&cameraCountOutput, d_ctx);
    XrExternalCameraOCULUS* cameras{};
    deserialize_ptr(&cameras, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateExternalCamerasOCULUS(session, cameraCapacityInput, cameraCountOutput, cameras);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(cameraCountOutput, 1, s_ctx);
    serialize_ptr(cameras, cameraCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&cameraCapacityInput);
    cleanup_ptr(cameraCountOutput, 1);
    cleanup_ptr(cameras, cameraCapacityInput);
}

#endif // XRTRANSPORT_EXT_XR_OCULUS_external_camera
#ifdef XRTRANSPORT_EXT_XR_QCOM_tracking_optimization_settings
void FunctionDispatch::handle_xrSetTrackingOptimizationSettingsHintQCOM(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetTrackingOptimizationSettingsHintQCOM", function_loader.SetTrackingOptimizationSettingsHintQCOM);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrTrackingOptimizationSettingsDomainQCOM domain{};
    deserialize(&domain, d_ctx);
    XrTrackingOptimizationSettingsHintQCOM hint{};
    deserialize(&hint, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetTrackingOptimizationSettingsHintQCOM(session, domain, hint);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&domain);
    cleanup(&hint);
}

#endif // XRTRANSPORT_EXT_XR_QCOM_tracking_optimization_settings
#ifdef XRTRANSPORT_EXT_XR_VARJO_environment_depth_estimation
void FunctionDispatch::handle_xrSetEnvironmentDepthEstimationVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetEnvironmentDepthEstimationVARJO", function_loader.SetEnvironmentDepthEstimationVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrBool32 enabled{};
    deserialize(&enabled, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetEnvironmentDepthEstimationVARJO(session, enabled);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&enabled);
}

#endif // XRTRANSPORT_EXT_XR_VARJO_environment_depth_estimation
#ifdef XRTRANSPORT_EXT_XR_VARJO_marker_tracking
void FunctionDispatch::handle_xrCreateMarkerSpaceVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateMarkerSpaceVARJO", function_loader.CreateMarkerSpaceVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrMarkerSpaceCreateInfoVARJO* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateMarkerSpaceVARJO(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrGetMarkerSizeVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetMarkerSizeVARJO", function_loader.GetMarkerSizeVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint64_t markerId{};
    deserialize(&markerId, d_ctx);
    XrExtent2Df* size{};
    deserialize_ptr(&size, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetMarkerSizeVARJO(session, markerId, size);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(size, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&markerId);
    cleanup_ptr(size, 1);
}

void FunctionDispatch::handle_xrSetMarkerTrackingPredictionVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetMarkerTrackingPredictionVARJO", function_loader.SetMarkerTrackingPredictionVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint64_t markerId{};
    deserialize(&markerId, d_ctx);
    XrBool32 enable{};
    deserialize(&enable, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetMarkerTrackingPredictionVARJO(session, markerId, enable);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&markerId);
    cleanup(&enable);
}

void FunctionDispatch::handle_xrSetMarkerTrackingTimeoutVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetMarkerTrackingTimeoutVARJO", function_loader.SetMarkerTrackingTimeoutVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint64_t markerId{};
    deserialize(&markerId, d_ctx);
    XrDuration timeout{};
    deserialize(&timeout, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetMarkerTrackingTimeoutVARJO(session, markerId, timeout);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&markerId);
    cleanup(&timeout);
}

void FunctionDispatch::handle_xrSetMarkerTrackingVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetMarkerTrackingVARJO", function_loader.SetMarkerTrackingVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrBool32 enabled{};
    deserialize(&enabled, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetMarkerTrackingVARJO(session, enabled);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&enabled);
}

#endif // XRTRANSPORT_EXT_XR_VARJO_marker_tracking
#ifdef XRTRANSPORT_EXT_XR_VARJO_view_offset
void FunctionDispatch::handle_xrSetViewOffsetVARJO(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSetViewOffsetVARJO", function_loader.SetViewOffsetVARJO);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    float offset{};
    deserialize(&offset, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SetViewOffsetVARJO(session, offset);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&offset);
}

#endif // XRTRANSPORT_EXT_XR_VARJO_view_offset
void FunctionDispatch::handle_xrAcquireSwapchainImage(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrAcquireSwapchainImage", function_loader.AcquireSwapchainImage);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);
    XrSwapchainImageAcquireInfo* acquireInfo{};
    deserialize_ptr(&acquireInfo, d_ctx);
    uint32_t* index{};
    deserialize_ptr(&index, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.AcquireSwapchainImage(swapchain, acquireInfo, index);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(index, 1, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup_ptr(acquireInfo, 1);
    cleanup_ptr(index, 1);
}

void FunctionDispatch::handle_xrApplyHapticFeedback(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrApplyHapticFeedback", function_loader.ApplyHapticFeedback);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrHapticActionInfo* hapticActionInfo{};
    deserialize_ptr(&hapticActionInfo, d_ctx);
    XrHapticBaseHeader* hapticFeedback{};
    deserialize_xr(&hapticFeedback, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ApplyHapticFeedback(session, hapticActionInfo, hapticFeedback);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(hapticActionInfo, 1);
    cleanup_xr(hapticFeedback);
}

void FunctionDispatch::handle_xrAttachSessionActionSets(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrAttachSessionActionSets", function_loader.AttachSessionActionSets);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSessionActionSetsAttachInfo* attachInfo{};
    deserialize_ptr(&attachInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.AttachSessionActionSets(session, attachInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(attachInfo, 1);
}

void FunctionDispatch::handle_xrBeginFrame(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrBeginFrame", function_loader.BeginFrame);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFrameBeginInfo* frameBeginInfo{};
    deserialize_ptr(&frameBeginInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.BeginFrame(session, frameBeginInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(frameBeginInfo, 1);
}

void FunctionDispatch::handle_xrBeginSession(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrBeginSession", function_loader.BeginSession);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSessionBeginInfo* beginInfo{};
    deserialize_ptr(&beginInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.BeginSession(session, beginInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(beginInfo, 1);
}

void FunctionDispatch::handle_xrCreateAction(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateAction", function_loader.CreateAction);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrActionSet actionSet{};
    deserialize(&actionSet, d_ctx);
    XrActionCreateInfo* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrAction* action{};
    deserialize_ptr(&action, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateAction(actionSet, createInfo, action);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(action, 1, s_ctx);
    msg_out.flush();

    cleanup(&actionSet);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(action, 1);
}

void FunctionDispatch::handle_xrCreateActionSet(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateActionSet", function_loader.CreateActionSet);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrActionSetCreateInfo* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrActionSet* actionSet{};
    deserialize_ptr(&actionSet, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateActionSet(instance, createInfo, actionSet);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(actionSet, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(actionSet, 1);
}

void FunctionDispatch::handle_xrCreateActionSpace(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateActionSpace", function_loader.CreateActionSpace);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrActionSpaceCreateInfo* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateActionSpace(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrCreateInstance(MessageLockIn msg_in) {
    // redirect to supplied xrCreateInstance handler
    create_instance_handler(std::move(msg_in));
}

void FunctionDispatch::handle_xrCreateReferenceSpace(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateReferenceSpace", function_loader.CreateReferenceSpace);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrReferenceSpaceCreateInfo* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSpace* space{};
    deserialize_ptr(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateReferenceSpace(session, createInfo, space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(space, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(space, 1);
}

void FunctionDispatch::handle_xrCreateSession(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSession", function_loader.CreateSession);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSessionCreateInfo* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSession* session{};
    deserialize_ptr(&session, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSession(instance, createInfo, session);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(session, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(session, 1);
}

void FunctionDispatch::handle_xrCreateSwapchain(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrCreateSwapchain", function_loader.CreateSwapchain);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSwapchainCreateInfo* createInfo{};
    deserialize_ptr(&createInfo, d_ctx);
    XrSwapchain* swapchain{};
    deserialize_ptr(&swapchain, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.CreateSwapchain(session, createInfo, swapchain);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(swapchain, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(createInfo, 1);
    cleanup_ptr(swapchain, 1);
}

void FunctionDispatch::handle_xrDestroyAction(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyAction", function_loader.DestroyAction);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrAction action{};
    deserialize(&action, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyAction(action);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&action);
}

void FunctionDispatch::handle_xrDestroyActionSet(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroyActionSet", function_loader.DestroyActionSet);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrActionSet actionSet{};
    deserialize(&actionSet, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroyActionSet(actionSet);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&actionSet);
}

void FunctionDispatch::handle_xrDestroyInstance(MessageLockIn msg_in) {
    // redirect to supplied xrDestroyInstance handler
    destroy_instance_handler(std::move(msg_in));
}

void FunctionDispatch::handle_xrDestroySession(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySession", function_loader.DestroySession);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroySession(session);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
}

void FunctionDispatch::handle_xrDestroySpace(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySpace", function_loader.DestroySpace);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpace space{};
    deserialize(&space, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroySpace(space);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&space);
}

void FunctionDispatch::handle_xrDestroySwapchain(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrDestroySwapchain", function_loader.DestroySwapchain);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.DestroySwapchain(swapchain);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
}

void FunctionDispatch::handle_xrEndFrame(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEndFrame", function_loader.EndFrame);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFrameEndInfo* frameEndInfo{};
    deserialize_ptr(&frameEndInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EndFrame(session, frameEndInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(frameEndInfo, 1);
}

void FunctionDispatch::handle_xrEndSession(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEndSession", function_loader.EndSession);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EndSession(session);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
}

void FunctionDispatch::handle_xrEnumerateApiLayerProperties(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateApiLayerProperties", function_loader.EnumerateApiLayerProperties);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    uint32_t propertyCapacityInput{};
    deserialize(&propertyCapacityInput, d_ctx);
    uint32_t* propertyCountOutput{};
    deserialize_ptr(&propertyCountOutput, d_ctx);
    XrApiLayerProperties* properties{};
    deserialize_ptr(&properties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateApiLayerProperties(propertyCapacityInput, propertyCountOutput, properties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(propertyCountOutput, 1, s_ctx);
    serialize_ptr(properties, propertyCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&propertyCapacityInput);
    cleanup_ptr(propertyCountOutput, 1);
    cleanup_ptr(properties, propertyCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateBoundSourcesForAction(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateBoundSourcesForAction", function_loader.EnumerateBoundSourcesForAction);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrBoundSourcesForActionEnumerateInfo* enumerateInfo{};
    deserialize_ptr(&enumerateInfo, d_ctx);
    uint32_t sourceCapacityInput{};
    deserialize(&sourceCapacityInput, d_ctx);
    uint32_t* sourceCountOutput{};
    deserialize_ptr(&sourceCountOutput, d_ctx);
    XrPath* sources{};
    deserialize_ptr(&sources, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateBoundSourcesForAction(session, enumerateInfo, sourceCapacityInput, sourceCountOutput, sources);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(sourceCountOutput, 1, s_ctx);
    serialize_ptr(sources, sourceCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(enumerateInfo, 1);
    cleanup(&sourceCapacityInput);
    cleanup_ptr(sourceCountOutput, 1);
    cleanup_ptr(sources, sourceCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateEnvironmentBlendModes(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateEnvironmentBlendModes", function_loader.EnumerateEnvironmentBlendModes);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrViewConfigurationType viewConfigurationType{};
    deserialize(&viewConfigurationType, d_ctx);
    uint32_t environmentBlendModeCapacityInput{};
    deserialize(&environmentBlendModeCapacityInput, d_ctx);
    uint32_t* environmentBlendModeCountOutput{};
    deserialize_ptr(&environmentBlendModeCountOutput, d_ctx);
    XrEnvironmentBlendMode* environmentBlendModes{};
    deserialize_ptr(&environmentBlendModes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateEnvironmentBlendModes(instance, systemId, viewConfigurationType, environmentBlendModeCapacityInput, environmentBlendModeCountOutput, environmentBlendModes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(environmentBlendModeCountOutput, 1, s_ctx);
    serialize_ptr(environmentBlendModes, environmentBlendModeCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&viewConfigurationType);
    cleanup(&environmentBlendModeCapacityInput);
    cleanup_ptr(environmentBlendModeCountOutput, 1);
    cleanup_ptr(environmentBlendModes, environmentBlendModeCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateInstanceExtensionProperties(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateInstanceExtensionProperties", function_loader.EnumerateInstanceExtensionProperties);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    char* layerName{};
    deserialize_ptr(&layerName, d_ctx);
    uint32_t propertyCapacityInput{};
    deserialize(&propertyCapacityInput, d_ctx);
    uint32_t* propertyCountOutput{};
    deserialize_ptr(&propertyCountOutput, d_ctx);
    XrExtensionProperties* properties{};
    deserialize_ptr(&properties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateInstanceExtensionProperties(layerName, propertyCapacityInput, propertyCountOutput, properties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(propertyCountOutput, 1, s_ctx);
    serialize_ptr(properties, propertyCapacityInput, s_ctx);
    msg_out.flush();

    cleanup_ptr(layerName, count_null_terminated(layerName));
    cleanup(&propertyCapacityInput);
    cleanup_ptr(propertyCountOutput, 1);
    cleanup_ptr(properties, propertyCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateReferenceSpaces(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateReferenceSpaces", function_loader.EnumerateReferenceSpaces);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint32_t spaceCapacityInput{};
    deserialize(&spaceCapacityInput, d_ctx);
    uint32_t* spaceCountOutput{};
    deserialize_ptr(&spaceCountOutput, d_ctx);
    XrReferenceSpaceType* spaces{};
    deserialize_ptr(&spaces, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateReferenceSpaces(session, spaceCapacityInput, spaceCountOutput, spaces);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(spaceCountOutput, 1, s_ctx);
    serialize_ptr(spaces, spaceCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&spaceCapacityInput);
    cleanup_ptr(spaceCountOutput, 1);
    cleanup_ptr(spaces, spaceCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateSwapchainFormats(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateSwapchainFormats", function_loader.EnumerateSwapchainFormats);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    uint32_t formatCapacityInput{};
    deserialize(&formatCapacityInput, d_ctx);
    uint32_t* formatCountOutput{};
    deserialize_ptr(&formatCountOutput, d_ctx);
    int64_t* formats{};
    deserialize_ptr(&formats, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateSwapchainFormats(session, formatCapacityInput, formatCountOutput, formats);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(formatCountOutput, 1, s_ctx);
    serialize_ptr(formats, formatCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&formatCapacityInput);
    cleanup_ptr(formatCountOutput, 1);
    cleanup_ptr(formats, formatCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateSwapchainImages(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateSwapchainImages", function_loader.EnumerateSwapchainImages);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);
    uint32_t imageCapacityInput{};
    deserialize(&imageCapacityInput, d_ctx);
    uint32_t* imageCountOutput{};
    deserialize_ptr(&imageCountOutput, d_ctx);
    XrSwapchainImageBaseHeader* images{};
    deserialize_xr_array(&images, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateSwapchainImages(swapchain, imageCapacityInput, imageCountOutput, images);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(imageCountOutput, 1, s_ctx);
    serialize_xr_array(images, imageCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup(&imageCapacityInput);
    cleanup_ptr(imageCountOutput, 1);
    cleanup_xr_array(images, imageCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateViewConfigurationViews(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateViewConfigurationViews", function_loader.EnumerateViewConfigurationViews);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrViewConfigurationType viewConfigurationType{};
    deserialize(&viewConfigurationType, d_ctx);
    uint32_t viewCapacityInput{};
    deserialize(&viewCapacityInput, d_ctx);
    uint32_t* viewCountOutput{};
    deserialize_ptr(&viewCountOutput, d_ctx);
    XrViewConfigurationView* views{};
    deserialize_ptr(&views, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateViewConfigurationViews(instance, systemId, viewConfigurationType, viewCapacityInput, viewCountOutput, views);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(viewCountOutput, 1, s_ctx);
    serialize_ptr(views, viewCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&viewConfigurationType);
    cleanup(&viewCapacityInput);
    cleanup_ptr(viewCountOutput, 1);
    cleanup_ptr(views, viewCapacityInput);
}

void FunctionDispatch::handle_xrEnumerateViewConfigurations(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrEnumerateViewConfigurations", function_loader.EnumerateViewConfigurations);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    uint32_t viewConfigurationTypeCapacityInput{};
    deserialize(&viewConfigurationTypeCapacityInput, d_ctx);
    uint32_t* viewConfigurationTypeCountOutput{};
    deserialize_ptr(&viewConfigurationTypeCountOutput, d_ctx);
    XrViewConfigurationType* viewConfigurationTypes{};
    deserialize_ptr(&viewConfigurationTypes, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.EnumerateViewConfigurations(instance, systemId, viewConfigurationTypeCapacityInput, viewConfigurationTypeCountOutput, viewConfigurationTypes);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(viewConfigurationTypeCountOutput, 1, s_ctx);
    serialize_ptr(viewConfigurationTypes, viewConfigurationTypeCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&viewConfigurationTypeCapacityInput);
    cleanup_ptr(viewConfigurationTypeCountOutput, 1);
    cleanup_ptr(viewConfigurationTypes, viewConfigurationTypeCapacityInput);
}

void FunctionDispatch::handle_xrGetActionStateBoolean(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetActionStateBoolean", function_loader.GetActionStateBoolean);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrActionStateGetInfo* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrActionStateBoolean* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetActionStateBoolean(session, getInfo, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetActionStateFloat(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetActionStateFloat", function_loader.GetActionStateFloat);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrActionStateGetInfo* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrActionStateFloat* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetActionStateFloat(session, getInfo, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetActionStatePose(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetActionStatePose", function_loader.GetActionStatePose);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrActionStateGetInfo* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrActionStatePose* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetActionStatePose(session, getInfo, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetActionStateVector2f(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetActionStateVector2f", function_loader.GetActionStateVector2f);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrActionStateGetInfo* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrActionStateVector2f* state{};
    deserialize_ptr(&state, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetActionStateVector2f(session, getInfo, state);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(state, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(state, 1);
}

void FunctionDispatch::handle_xrGetCurrentInteractionProfile(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetCurrentInteractionProfile", function_loader.GetCurrentInteractionProfile);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrPath topLevelUserPath{};
    deserialize(&topLevelUserPath, d_ctx);
    XrInteractionProfileState* interactionProfile{};
    deserialize_ptr(&interactionProfile, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetCurrentInteractionProfile(session, topLevelUserPath, interactionProfile);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(interactionProfile, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&topLevelUserPath);
    cleanup_ptr(interactionProfile, 1);
}

void FunctionDispatch::handle_xrGetInputSourceLocalizedName(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetInputSourceLocalizedName", function_loader.GetInputSourceLocalizedName);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrInputSourceLocalizedNameGetInfo* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetInputSourceLocalizedName(session, getInfo, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(getInfo, 1);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

void FunctionDispatch::handle_xrGetInstanceProperties(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetInstanceProperties", function_loader.GetInstanceProperties);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrInstanceProperties* instanceProperties{};
    deserialize_ptr(&instanceProperties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetInstanceProperties(instance, instanceProperties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(instanceProperties, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(instanceProperties, 1);
}

void FunctionDispatch::handle_xrGetReferenceSpaceBoundsRect(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetReferenceSpaceBoundsRect", function_loader.GetReferenceSpaceBoundsRect);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrReferenceSpaceType referenceSpaceType{};
    deserialize(&referenceSpaceType, d_ctx);
    XrExtent2Df* bounds{};
    deserialize_ptr(&bounds, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetReferenceSpaceBoundsRect(session, referenceSpaceType, bounds);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bounds, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup(&referenceSpaceType);
    cleanup_ptr(bounds, 1);
}

void FunctionDispatch::handle_xrGetSystem(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSystem", function_loader.GetSystem);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemGetInfo* getInfo{};
    deserialize_ptr(&getInfo, d_ctx);
    XrSystemId* systemId{};
    deserialize_ptr(&systemId, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSystem(instance, getInfo, systemId);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(systemId, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(getInfo, 1);
    cleanup_ptr(systemId, 1);
}

void FunctionDispatch::handle_xrGetSystemProperties(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetSystemProperties", function_loader.GetSystemProperties);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrSystemProperties* properties{};
    deserialize_ptr(&properties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetSystemProperties(instance, systemId, properties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(properties, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup_ptr(properties, 1);
}

void FunctionDispatch::handle_xrGetViewConfigurationProperties(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrGetViewConfigurationProperties", function_loader.GetViewConfigurationProperties);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrSystemId systemId{};
    deserialize(&systemId, d_ctx);
    XrViewConfigurationType viewConfigurationType{};
    deserialize(&viewConfigurationType, d_ctx);
    XrViewConfigurationProperties* configurationProperties{};
    deserialize_ptr(&configurationProperties, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.GetViewConfigurationProperties(instance, systemId, viewConfigurationType, configurationProperties);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(configurationProperties, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&systemId);
    cleanup(&viewConfigurationType);
    cleanup_ptr(configurationProperties, 1);
}

void FunctionDispatch::handle_xrLocateSpace(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateSpace", function_loader.LocateSpace);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSpace space{};
    deserialize(&space, d_ctx);
    XrSpace baseSpace{};
    deserialize(&baseSpace, d_ctx);
    XrTime time{};
    deserialize_time(&time, d_ctx);
    XrSpaceLocation* location{};
    deserialize_ptr(&location, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.LocateSpace(space, baseSpace, time, location);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(location, 1, s_ctx);
    msg_out.flush();

    cleanup(&space);
    cleanup(&baseSpace);
    cleanup(&time);
    cleanup_ptr(location, 1);
}

void FunctionDispatch::handle_xrLocateSpaces(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateSpaces", function_loader.LocateSpaces);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrSpacesLocateInfo* locateInfo{};
    deserialize_ptr(&locateInfo, d_ctx);
    XrSpaceLocations* spaceLocations{};
    deserialize_ptr(&spaceLocations, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.LocateSpaces(session, locateInfo, spaceLocations);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(spaceLocations, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(locateInfo, 1);
    cleanup_ptr(spaceLocations, 1);
}

void FunctionDispatch::handle_xrLocateViews(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrLocateViews", function_loader.LocateViews);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrViewLocateInfo* viewLocateInfo{};
    deserialize_ptr(&viewLocateInfo, d_ctx);
    XrViewState* viewState{};
    deserialize_ptr(&viewState, d_ctx);
    uint32_t viewCapacityInput{};
    deserialize(&viewCapacityInput, d_ctx);
    uint32_t* viewCountOutput{};
    deserialize_ptr(&viewCountOutput, d_ctx);
    XrView* views{};
    deserialize_ptr(&views, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.LocateViews(session, viewLocateInfo, viewState, viewCapacityInput, viewCountOutput, views);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(viewState, 1, s_ctx);
    serialize_ptr(viewCountOutput, 1, s_ctx);
    serialize_ptr(views, viewCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(viewLocateInfo, 1);
    cleanup_ptr(viewState, 1);
    cleanup(&viewCapacityInput);
    cleanup_ptr(viewCountOutput, 1);
    cleanup_ptr(views, viewCapacityInput);
}

void FunctionDispatch::handle_xrPathToString(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPathToString", function_loader.PathToString);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrPath path{};
    deserialize(&path, d_ctx);
    uint32_t bufferCapacityInput{};
    deserialize(&bufferCapacityInput, d_ctx);
    uint32_t* bufferCountOutput{};
    deserialize_ptr(&bufferCountOutput, d_ctx);
    char* buffer{};
    deserialize_ptr(&buffer, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PathToString(instance, path, bufferCapacityInput, bufferCountOutput, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(bufferCountOutput, 1, s_ctx);
    serialize_ptr(buffer, bufferCapacityInput, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&path);
    cleanup(&bufferCapacityInput);
    cleanup_ptr(bufferCountOutput, 1);
    cleanup_ptr(buffer, bufferCapacityInput);
}

void FunctionDispatch::handle_xrPollEvent(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrPollEvent", function_loader.PollEvent);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrEventDataBuffer* eventData{};
    deserialize_ptr(&eventData, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.PollEvent(instance, eventData);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(eventData, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(eventData, 1);
}

void FunctionDispatch::handle_xrReleaseSwapchainImage(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrReleaseSwapchainImage", function_loader.ReleaseSwapchainImage);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);
    XrSwapchainImageReleaseInfo* releaseInfo{};
    deserialize_ptr(&releaseInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ReleaseSwapchainImage(swapchain, releaseInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup_ptr(releaseInfo, 1);
}

void FunctionDispatch::handle_xrRequestExitSession(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrRequestExitSession", function_loader.RequestExitSession);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.RequestExitSession(session);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
}

void FunctionDispatch::handle_xrResultToString(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrResultToString", function_loader.ResultToString);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrResult value{};
    deserialize(&value, d_ctx);
    char buffer[XR_MAX_RESULT_STRING_SIZE]{};
    deserialize_array(buffer, XR_MAX_RESULT_STRING_SIZE, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.ResultToString(instance, value, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(buffer, XR_MAX_RESULT_STRING_SIZE, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&value);
    cleanup_array(buffer, XR_MAX_RESULT_STRING_SIZE);
}

void FunctionDispatch::handle_xrStopHapticFeedback(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStopHapticFeedback", function_loader.StopHapticFeedback);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrHapticActionInfo* hapticActionInfo{};
    deserialize_ptr(&hapticActionInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.StopHapticFeedback(session, hapticActionInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(hapticActionInfo, 1);
}

void FunctionDispatch::handle_xrStringToPath(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStringToPath", function_loader.StringToPath);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    char* pathString{};
    deserialize_ptr(&pathString, d_ctx);
    XrPath* path{};
    deserialize_ptr(&path, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.StringToPath(instance, pathString, path);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(path, 1, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(pathString, count_null_terminated(pathString));
    cleanup_ptr(path, 1);
}

void FunctionDispatch::handle_xrStructureTypeToString(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrStructureTypeToString", function_loader.StructureTypeToString);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrStructureType value{};
    deserialize(&value, d_ctx);
    char buffer[XR_MAX_STRUCTURE_NAME_SIZE]{};
    deserialize_array(buffer, XR_MAX_STRUCTURE_NAME_SIZE, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.StructureTypeToString(instance, value, buffer);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(buffer, XR_MAX_STRUCTURE_NAME_SIZE, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup(&value);
    cleanup_array(buffer, XR_MAX_STRUCTURE_NAME_SIZE);
}

void FunctionDispatch::handle_xrSuggestInteractionProfileBindings(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSuggestInteractionProfileBindings", function_loader.SuggestInteractionProfileBindings);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrInstance instance{};
    deserialize(&instance, d_ctx);
    XrInteractionProfileSuggestedBinding* suggestedBindings{};
    deserialize_ptr(&suggestedBindings, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SuggestInteractionProfileBindings(instance, suggestedBindings);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&instance);
    cleanup_ptr(suggestedBindings, 1);
}

void FunctionDispatch::handle_xrSyncActions(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrSyncActions", function_loader.SyncActions);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrActionsSyncInfo* syncInfo{};
    deserialize_ptr(&syncInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.SyncActions(session, syncInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(syncInfo, 1);
}

void FunctionDispatch::handle_xrWaitFrame(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrWaitFrame", function_loader.WaitFrame);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSession session{};
    deserialize(&session, d_ctx);
    XrFrameWaitInfo* frameWaitInfo{};
    deserialize_ptr(&frameWaitInfo, d_ctx);
    XrFrameState* frameState{};
    deserialize_ptr(&frameState, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.WaitFrame(session, frameWaitInfo, frameState);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    serialize_ptr(frameState, 1, s_ctx);
    msg_out.flush();

    cleanup(&session);
    cleanup_ptr(frameWaitInfo, 1);
    cleanup_ptr(frameState, 1);
}

void FunctionDispatch::handle_xrWaitSwapchainImage(MessageLockIn msg_in) {
    function_loader.ensure_function_loaded("xrWaitSwapchainImage", function_loader.WaitSwapchainImage);
    // by this point, the function id has already been read, now read the params
    DeserializeContext d_ctx(msg_in.buffer);
    XrSwapchain swapchain{};
    deserialize(&swapchain, d_ctx);
    XrSwapchainImageWaitInfo* waitInfo{};
    deserialize_ptr(&waitInfo, d_ctx);

    XrTime start_time = start_runtime_timer();
    XrResult _result = function_loader.WaitSwapchainImage(swapchain, waitInfo);
    XrDuration runtime_duration = end_runtime_timer(start_time);
    
    auto msg_out = transport.start_message(XRTP_MSG_FUNCTION_RETURN);
    SerializeContext s_ctx(msg_out.buffer);
    serialize(&_result, s_ctx);
    serialize(&runtime_duration, s_ctx);
    msg_out.flush();

    cleanup(&swapchain);
    cleanup_ptr(waitInfo, 1);
}



std::unordered_map<uint32_t, FunctionDispatch::Handler> FunctionDispatch::handlers = {
#ifdef XRTRANSPORT_EXT_XR_ALMALENCE_digital_lens_control
    {197001, &FunctionDispatch::handle_xrSetDigitalLensControlALMALENCE},
#endif // XRTRANSPORT_EXT_XR_ALMALENCE_digital_lens_control
#ifdef XRTRANSPORT_EXT_XR_BD_body_tracking
    {386001, &FunctionDispatch::handle_xrCreateBodyTrackerBD},
    {386002, &FunctionDispatch::handle_xrDestroyBodyTrackerBD},
    {386003, &FunctionDispatch::handle_xrLocateBodyJointsBD},
#endif // XRTRANSPORT_EXT_XR_BD_body_tracking
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_anchor
    {391001, &FunctionDispatch::handle_xrCreateSpatialAnchorAsyncBD},
    {391002, &FunctionDispatch::handle_xrCreateSpatialAnchorCompleteBD},
    {391003, &FunctionDispatch::handle_xrPersistSpatialAnchorAsyncBD},
    {391004, &FunctionDispatch::handle_xrPersistSpatialAnchorCompleteBD},
    {391005, &FunctionDispatch::handle_xrUnpersistSpatialAnchorAsyncBD},
    {391006, &FunctionDispatch::handle_xrUnpersistSpatialAnchorCompleteBD},
#endif // XRTRANSPORT_EXT_XR_BD_spatial_anchor
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_anchor_sharing
    {392001, &FunctionDispatch::handle_xrDownloadSharedSpatialAnchorAsyncBD},
    {392002, &FunctionDispatch::handle_xrDownloadSharedSpatialAnchorCompleteBD},
    {392003, &FunctionDispatch::handle_xrShareSpatialAnchorAsyncBD},
    {392004, &FunctionDispatch::handle_xrShareSpatialAnchorCompleteBD},
#endif // XRTRANSPORT_EXT_XR_BD_spatial_anchor_sharing
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_scene
    {393001, &FunctionDispatch::handle_xrCaptureSceneAsyncBD},
    {393002, &FunctionDispatch::handle_xrCaptureSceneCompleteBD},
#endif // XRTRANSPORT_EXT_XR_BD_spatial_scene
#ifdef XRTRANSPORT_EXT_XR_BD_spatial_sensing
    {390001, &FunctionDispatch::handle_xrCreateAnchorSpaceBD},
    {390002, &FunctionDispatch::handle_xrCreateSenseDataProviderBD},
    {390003, &FunctionDispatch::handle_xrCreateSpatialEntityAnchorBD},
    {390004, &FunctionDispatch::handle_xrDestroyAnchorBD},
    {390005, &FunctionDispatch::handle_xrDestroySenseDataProviderBD},
    {390006, &FunctionDispatch::handle_xrDestroySenseDataSnapshotBD},
    {390007, &FunctionDispatch::handle_xrEnumerateSpatialEntityComponentTypesBD},
    {390008, &FunctionDispatch::handle_xrGetAnchorUuidBD},
    {390009, &FunctionDispatch::handle_xrGetQueriedSenseDataBD},
    {390010, &FunctionDispatch::handle_xrGetSenseDataProviderStateBD},
    {390011, &FunctionDispatch::handle_xrGetSpatialEntityComponentDataBD},
    {390012, &FunctionDispatch::handle_xrGetSpatialEntityUuidBD},
    {390013, &FunctionDispatch::handle_xrQuerySenseDataAsyncBD},
    {390014, &FunctionDispatch::handle_xrQuerySenseDataCompleteBD},
    {390015, &FunctionDispatch::handle_xrStartSenseDataProviderAsyncBD},
    {390016, &FunctionDispatch::handle_xrStartSenseDataProviderCompleteBD},
    {390017, &FunctionDispatch::handle_xrStopSenseDataProviderBD},
#endif // XRTRANSPORT_EXT_XR_BD_spatial_sensing
#ifdef XRTRANSPORT_EXT_XR_EXT_conformance_automation
    {48001, &FunctionDispatch::handle_xrSetInputDeviceActiveEXT},
    {48002, &FunctionDispatch::handle_xrSetInputDeviceLocationEXT},
    {48003, &FunctionDispatch::handle_xrSetInputDeviceStateBoolEXT},
    {48004, &FunctionDispatch::handle_xrSetInputDeviceStateFloatEXT},
    {48005, &FunctionDispatch::handle_xrSetInputDeviceStateVector2fEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_conformance_automation
#ifdef XRTRANSPORT_EXT_XR_EXT_debug_utils
    {20001, &FunctionDispatch::handle_xrCreateDebugUtilsMessengerEXT},
    {20002, &FunctionDispatch::handle_xrDestroyDebugUtilsMessengerEXT},
    {20003, &FunctionDispatch::handle_xrSessionBeginDebugUtilsLabelRegionEXT},
    {20004, &FunctionDispatch::handle_xrSessionEndDebugUtilsLabelRegionEXT},
    {20005, &FunctionDispatch::handle_xrSessionInsertDebugUtilsLabelEXT},
    {20006, &FunctionDispatch::handle_xrSetDebugUtilsObjectNameEXT},
    {20007, &FunctionDispatch::handle_xrSubmitDebugUtilsMessageEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_debug_utils
#ifdef XRTRANSPORT_EXT_XR_EXT_future
    {470001, &FunctionDispatch::handle_xrCancelFutureEXT},
    {470002, &FunctionDispatch::handle_xrPollFutureEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_future
#ifdef XRTRANSPORT_EXT_XR_EXT_hand_tracking
    {52001, &FunctionDispatch::handle_xrCreateHandTrackerEXT},
    {52002, &FunctionDispatch::handle_xrDestroyHandTrackerEXT},
    {52003, &FunctionDispatch::handle_xrLocateHandJointsEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_hand_tracking
#ifdef XRTRANSPORT_EXT_XR_EXT_performance_settings
    {16001, &FunctionDispatch::handle_xrPerfSettingsSetPerformanceLevelEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_performance_settings
#ifdef XRTRANSPORT_EXT_XR_EXT_plane_detection
    {430001, &FunctionDispatch::handle_xrBeginPlaneDetectionEXT},
    {430002, &FunctionDispatch::handle_xrCreatePlaneDetectorEXT},
    {430003, &FunctionDispatch::handle_xrDestroyPlaneDetectorEXT},
    {430004, &FunctionDispatch::handle_xrGetPlaneDetectionStateEXT},
    {430005, &FunctionDispatch::handle_xrGetPlaneDetectionsEXT},
    {430006, &FunctionDispatch::handle_xrGetPlanePolygonBufferEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_plane_detection
#ifdef XRTRANSPORT_EXT_XR_EXT_thermal_query
    {17001, &FunctionDispatch::handle_xrThermalGetTemperatureTrendEXT},
#endif // XRTRANSPORT_EXT_XR_EXT_thermal_query
#ifdef XRTRANSPORT_EXT_XR_FB_body_tracking
    {77001, &FunctionDispatch::handle_xrCreateBodyTrackerFB},
    {77002, &FunctionDispatch::handle_xrDestroyBodyTrackerFB},
    {77003, &FunctionDispatch::handle_xrGetBodySkeletonFB},
    {77004, &FunctionDispatch::handle_xrLocateBodyJointsFB},
#endif // XRTRANSPORT_EXT_XR_FB_body_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_color_space
    {109001, &FunctionDispatch::handle_xrEnumerateColorSpacesFB},
    {109002, &FunctionDispatch::handle_xrSetColorSpaceFB},
#endif // XRTRANSPORT_EXT_XR_FB_color_space
#ifdef XRTRANSPORT_EXT_XR_FB_display_refresh_rate
    {102001, &FunctionDispatch::handle_xrEnumerateDisplayRefreshRatesFB},
    {102002, &FunctionDispatch::handle_xrGetDisplayRefreshRateFB},
    {102003, &FunctionDispatch::handle_xrRequestDisplayRefreshRateFB},
#endif // XRTRANSPORT_EXT_XR_FB_display_refresh_rate
#ifdef XRTRANSPORT_EXT_XR_FB_eye_tracking_social
    {203001, &FunctionDispatch::handle_xrCreateEyeTrackerFB},
    {203002, &FunctionDispatch::handle_xrDestroyEyeTrackerFB},
    {203003, &FunctionDispatch::handle_xrGetEyeGazesFB},
#endif // XRTRANSPORT_EXT_XR_FB_eye_tracking_social
#ifdef XRTRANSPORT_EXT_XR_FB_face_tracking
    {202001, &FunctionDispatch::handle_xrCreateFaceTrackerFB},
    {202002, &FunctionDispatch::handle_xrDestroyFaceTrackerFB},
    {202003, &FunctionDispatch::handle_xrGetFaceExpressionWeightsFB},
#endif // XRTRANSPORT_EXT_XR_FB_face_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_face_tracking2
    {288001, &FunctionDispatch::handle_xrCreateFaceTracker2FB},
    {288002, &FunctionDispatch::handle_xrDestroyFaceTracker2FB},
    {288003, &FunctionDispatch::handle_xrGetFaceExpressionWeights2FB},
#endif // XRTRANSPORT_EXT_XR_FB_face_tracking2
#ifdef XRTRANSPORT_EXT_XR_FB_foveation
    {115001, &FunctionDispatch::handle_xrCreateFoveationProfileFB},
    {115002, &FunctionDispatch::handle_xrDestroyFoveationProfileFB},
#endif // XRTRANSPORT_EXT_XR_FB_foveation
#ifdef XRTRANSPORT_EXT_XR_FB_hand_tracking_mesh
    {111001, &FunctionDispatch::handle_xrGetHandMeshFB},
#endif // XRTRANSPORT_EXT_XR_FB_hand_tracking_mesh
#ifdef XRTRANSPORT_EXT_XR_FB_haptic_pcm
    {210001, &FunctionDispatch::handle_xrGetDeviceSampleRateFB},
#endif // XRTRANSPORT_EXT_XR_FB_haptic_pcm
#ifdef XRTRANSPORT_EXT_XR_FB_keyboard_tracking
    {117001, &FunctionDispatch::handle_xrCreateKeyboardSpaceFB},
    {117002, &FunctionDispatch::handle_xrQuerySystemTrackedKeyboardFB},
#endif // XRTRANSPORT_EXT_XR_FB_keyboard_tracking
#ifdef XRTRANSPORT_EXT_XR_FB_passthrough
    {119001, &FunctionDispatch::handle_xrCreateGeometryInstanceFB},
    {119002, &FunctionDispatch::handle_xrCreatePassthroughFB},
    {119003, &FunctionDispatch::handle_xrCreatePassthroughLayerFB},
    {119004, &FunctionDispatch::handle_xrDestroyGeometryInstanceFB},
    {119005, &FunctionDispatch::handle_xrDestroyPassthroughFB},
    {119006, &FunctionDispatch::handle_xrDestroyPassthroughLayerFB},
    {119007, &FunctionDispatch::handle_xrGeometryInstanceSetTransformFB},
    {119008, &FunctionDispatch::handle_xrPassthroughLayerPauseFB},
    {119009, &FunctionDispatch::handle_xrPassthroughLayerResumeFB},
    {119010, &FunctionDispatch::handle_xrPassthroughLayerSetStyleFB},
    {119011, &FunctionDispatch::handle_xrPassthroughPauseFB},
    {119012, &FunctionDispatch::handle_xrPassthroughStartFB},
#endif // XRTRANSPORT_EXT_XR_FB_passthrough
#ifdef XRTRANSPORT_EXT_XR_FB_passthrough_keyboard_hands
    {204001, &FunctionDispatch::handle_xrPassthroughLayerSetKeyboardHandsIntensityFB},
#endif // XRTRANSPORT_EXT_XR_FB_passthrough_keyboard_hands
#ifdef XRTRANSPORT_EXT_XR_FB_render_model
    {120001, &FunctionDispatch::handle_xrEnumerateRenderModelPathsFB},
    {120002, &FunctionDispatch::handle_xrGetRenderModelPropertiesFB},
    {120003, &FunctionDispatch::handle_xrLoadRenderModelFB},
#endif // XRTRANSPORT_EXT_XR_FB_render_model
#ifdef XRTRANSPORT_EXT_XR_FB_scene
    {176001, &FunctionDispatch::handle_xrGetSpaceBoundary2DFB},
    {176002, &FunctionDispatch::handle_xrGetSpaceBoundingBox2DFB},
    {176003, &FunctionDispatch::handle_xrGetSpaceBoundingBox3DFB},
    {176004, &FunctionDispatch::handle_xrGetSpaceRoomLayoutFB},
    {176005, &FunctionDispatch::handle_xrGetSpaceSemanticLabelsFB},
#endif // XRTRANSPORT_EXT_XR_FB_scene
#ifdef XRTRANSPORT_EXT_XR_FB_scene_capture
    {199001, &FunctionDispatch::handle_xrRequestSceneCaptureFB},
#endif // XRTRANSPORT_EXT_XR_FB_scene_capture
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity
    {114001, &FunctionDispatch::handle_xrCreateSpatialAnchorFB},
    {114002, &FunctionDispatch::handle_xrEnumerateSpaceSupportedComponentsFB},
    {114003, &FunctionDispatch::handle_xrGetSpaceComponentStatusFB},
    {114004, &FunctionDispatch::handle_xrGetSpaceUuidFB},
    {114005, &FunctionDispatch::handle_xrSetSpaceComponentStatusFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_container
    {200001, &FunctionDispatch::handle_xrGetSpaceContainerFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_container
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_query
    {157001, &FunctionDispatch::handle_xrQuerySpacesFB},
    {157002, &FunctionDispatch::handle_xrRetrieveSpaceQueryResultsFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_query
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_sharing
    {170001, &FunctionDispatch::handle_xrShareSpacesFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_sharing
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_storage
    {159001, &FunctionDispatch::handle_xrEraseSpaceFB},
    {159002, &FunctionDispatch::handle_xrSaveSpaceFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_storage
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_storage_batch
    {239001, &FunctionDispatch::handle_xrSaveSpaceListFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_storage_batch
#ifdef XRTRANSPORT_EXT_XR_FB_spatial_entity_user
    {242001, &FunctionDispatch::handle_xrCreateSpaceUserFB},
    {242002, &FunctionDispatch::handle_xrDestroySpaceUserFB},
    {242003, &FunctionDispatch::handle_xrGetSpaceUserIdFB},
#endif // XRTRANSPORT_EXT_XR_FB_spatial_entity_user
#ifdef XRTRANSPORT_EXT_XR_FB_swapchain_update_state
    {72001, &FunctionDispatch::handle_xrGetSwapchainStateFB},
    {72002, &FunctionDispatch::handle_xrUpdateSwapchainFB},
#endif // XRTRANSPORT_EXT_XR_FB_swapchain_update_state
#ifdef XRTRANSPORT_EXT_XR_FB_triangle_mesh
    {118001, &FunctionDispatch::handle_xrCreateTriangleMeshFB},
    {118002, &FunctionDispatch::handle_xrDestroyTriangleMeshFB},
    {118003, &FunctionDispatch::handle_xrTriangleMeshBeginUpdateFB},
    {118004, &FunctionDispatch::handle_xrTriangleMeshBeginVertexBufferUpdateFB},
    {118005, &FunctionDispatch::handle_xrTriangleMeshEndUpdateFB},
    {118006, &FunctionDispatch::handle_xrTriangleMeshEndVertexBufferUpdateFB},
    {118007, &FunctionDispatch::handle_xrTriangleMeshGetIndexBufferFB},
    {118008, &FunctionDispatch::handle_xrTriangleMeshGetVertexBufferFB},
#endif // XRTRANSPORT_EXT_XR_FB_triangle_mesh
#ifdef XRTRANSPORT_EXT_XR_HTCX_vive_tracker_interaction
    {104001, &FunctionDispatch::handle_xrEnumerateViveTrackerPathsHTCX},
#endif // XRTRANSPORT_EXT_XR_HTCX_vive_tracker_interaction
#ifdef XRTRANSPORT_EXT_XR_HTC_anchor
    {320001, &FunctionDispatch::handle_xrCreateSpatialAnchorHTC},
    {320002, &FunctionDispatch::handle_xrGetSpatialAnchorNameHTC},
#endif // XRTRANSPORT_EXT_XR_HTC_anchor
#ifdef XRTRANSPORT_EXT_XR_HTC_body_tracking
    {321001, &FunctionDispatch::handle_xrCreateBodyTrackerHTC},
    {321002, &FunctionDispatch::handle_xrDestroyBodyTrackerHTC},
    {321003, &FunctionDispatch::handle_xrGetBodySkeletonHTC},
    {321004, &FunctionDispatch::handle_xrLocateBodyJointsHTC},
#endif // XRTRANSPORT_EXT_XR_HTC_body_tracking
#ifdef XRTRANSPORT_EXT_XR_HTC_facial_tracking
    {105001, &FunctionDispatch::handle_xrCreateFacialTrackerHTC},
    {105002, &FunctionDispatch::handle_xrDestroyFacialTrackerHTC},
    {105003, &FunctionDispatch::handle_xrGetFacialExpressionsHTC},
#endif // XRTRANSPORT_EXT_XR_HTC_facial_tracking
#ifdef XRTRANSPORT_EXT_XR_HTC_foveation
    {319001, &FunctionDispatch::handle_xrApplyFoveationHTC},
#endif // XRTRANSPORT_EXT_XR_HTC_foveation
#ifdef XRTRANSPORT_EXT_XR_HTC_passthrough
    {318001, &FunctionDispatch::handle_xrCreatePassthroughHTC},
    {318002, &FunctionDispatch::handle_xrDestroyPassthroughHTC},
#endif // XRTRANSPORT_EXT_XR_HTC_passthrough
#ifdef XRTRANSPORT_EXT_XR_KHR_D3D11_enable
    {28001, &FunctionDispatch::handle_xrGetD3D11GraphicsRequirementsKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_D3D11_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_D3D12_enable
    {29001, &FunctionDispatch::handle_xrGetD3D12GraphicsRequirementsKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_D3D12_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_android_surface_swapchain
    {5001, &FunctionDispatch::handle_xrCreateSwapchainAndroidSurfaceKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_android_surface_swapchain
#ifdef XRTRANSPORT_EXT_XR_KHR_android_thread_settings
    {4001, &FunctionDispatch::handle_xrSetAndroidApplicationThreadKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_android_thread_settings
#ifdef XRTRANSPORT_EXT_XR_KHR_convert_timespec_time
    {37001, &FunctionDispatch::handle_xrConvertTimeToTimespecTimeKHR},
    {37002, &FunctionDispatch::handle_xrConvertTimespecTimeToTimeKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_convert_timespec_time
#ifdef XRTRANSPORT_EXT_XR_KHR_extended_struct_name_lengths
    {149001, &FunctionDispatch::handle_xrStructureTypeToString2KHR},
#endif // XRTRANSPORT_EXT_XR_KHR_extended_struct_name_lengths
#ifdef XRTRANSPORT_EXT_XR_KHR_loader_init
    {89001, &FunctionDispatch::handle_xrInitializeLoaderKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_loader_init
#ifdef XRTRANSPORT_EXT_XR_KHR_metal_enable
    {30001, &FunctionDispatch::handle_xrGetMetalGraphicsRequirementsKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_metal_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_opengl_enable
    {24001, &FunctionDispatch::handle_xrGetOpenGLGraphicsRequirementsKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_opengl_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_opengl_es_enable
    {25001, &FunctionDispatch::handle_xrGetOpenGLESGraphicsRequirementsKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_opengl_es_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_visibility_mask
    {32001, &FunctionDispatch::handle_xrGetVisibilityMaskKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_visibility_mask
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_enable
    {26001, &FunctionDispatch::handle_xrGetVulkanDeviceExtensionsKHR},
    {26002, &FunctionDispatch::handle_xrGetVulkanGraphicsDeviceKHR},
    {26003, &FunctionDispatch::handle_xrGetVulkanGraphicsRequirementsKHR},
    {26004, &FunctionDispatch::handle_xrGetVulkanInstanceExtensionsKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_enable
#ifdef XRTRANSPORT_EXT_XR_KHR_vulkan_enable2
    {91001, &FunctionDispatch::handle_xrCreateVulkanDeviceKHR},
    {91002, &FunctionDispatch::handle_xrCreateVulkanInstanceKHR},
    {91003, &FunctionDispatch::handle_xrGetVulkanGraphicsDevice2KHR},
#endif // XRTRANSPORT_EXT_XR_KHR_vulkan_enable2
#ifdef XRTRANSPORT_EXT_XR_KHR_win32_convert_performance_counter_time
    {36001, &FunctionDispatch::handle_xrConvertTimeToWin32PerformanceCounterKHR},
    {36002, &FunctionDispatch::handle_xrConvertWin32PerformanceCounterToTimeKHR},
#endif // XRTRANSPORT_EXT_XR_KHR_win32_convert_performance_counter_time
#ifdef XRTRANSPORT_EXT_XR_META_colocation_discovery
    {572001, &FunctionDispatch::handle_xrStartColocationAdvertisementMETA},
    {572002, &FunctionDispatch::handle_xrStartColocationDiscoveryMETA},
    {572003, &FunctionDispatch::handle_xrStopColocationAdvertisementMETA},
    {572004, &FunctionDispatch::handle_xrStopColocationDiscoveryMETA},
#endif // XRTRANSPORT_EXT_XR_META_colocation_discovery
#ifdef XRTRANSPORT_EXT_XR_META_environment_depth
    {292001, &FunctionDispatch::handle_xrAcquireEnvironmentDepthImageMETA},
    {292002, &FunctionDispatch::handle_xrCreateEnvironmentDepthProviderMETA},
    {292003, &FunctionDispatch::handle_xrCreateEnvironmentDepthSwapchainMETA},
    {292004, &FunctionDispatch::handle_xrDestroyEnvironmentDepthProviderMETA},
    {292005, &FunctionDispatch::handle_xrDestroyEnvironmentDepthSwapchainMETA},
    {292006, &FunctionDispatch::handle_xrEnumerateEnvironmentDepthSwapchainImagesMETA},
    {292007, &FunctionDispatch::handle_xrGetEnvironmentDepthSwapchainStateMETA},
    {292008, &FunctionDispatch::handle_xrSetEnvironmentDepthHandRemovalMETA},
    {292009, &FunctionDispatch::handle_xrStartEnvironmentDepthProviderMETA},
    {292010, &FunctionDispatch::handle_xrStopEnvironmentDepthProviderMETA},
#endif // XRTRANSPORT_EXT_XR_META_environment_depth
#ifdef XRTRANSPORT_EXT_XR_META_foveation_eye_tracked
    {201001, &FunctionDispatch::handle_xrGetFoveationEyeTrackedStateMETA},
#endif // XRTRANSPORT_EXT_XR_META_foveation_eye_tracked
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_color_lut
    {267001, &FunctionDispatch::handle_xrCreatePassthroughColorLutMETA},
    {267002, &FunctionDispatch::handle_xrDestroyPassthroughColorLutMETA},
    {267003, &FunctionDispatch::handle_xrUpdatePassthroughColorLutMETA},
#endif // XRTRANSPORT_EXT_XR_META_passthrough_color_lut
#ifdef XRTRANSPORT_EXT_XR_META_passthrough_preferences
    {218001, &FunctionDispatch::handle_xrGetPassthroughPreferencesMETA},
#endif // XRTRANSPORT_EXT_XR_META_passthrough_preferences
#ifdef XRTRANSPORT_EXT_XR_META_performance_metrics
    {233001, &FunctionDispatch::handle_xrEnumeratePerformanceMetricsCounterPathsMETA},
    {233002, &FunctionDispatch::handle_xrGetPerformanceMetricsStateMETA},
    {233003, &FunctionDispatch::handle_xrQueryPerformanceMetricsCounterMETA},
    {233004, &FunctionDispatch::handle_xrSetPerformanceMetricsStateMETA},
#endif // XRTRANSPORT_EXT_XR_META_performance_metrics
#ifdef XRTRANSPORT_EXT_XR_META_recommended_layer_resolution
    {255001, &FunctionDispatch::handle_xrGetRecommendedLayerResolutionMETA},
#endif // XRTRANSPORT_EXT_XR_META_recommended_layer_resolution
#ifdef XRTRANSPORT_EXT_XR_META_simultaneous_hands_and_controllers
    {533001, &FunctionDispatch::handle_xrPauseSimultaneousHandsAndControllersTrackingMETA},
    {533002, &FunctionDispatch::handle_xrResumeSimultaneousHandsAndControllersTrackingMETA},
#endif // XRTRANSPORT_EXT_XR_META_simultaneous_hands_and_controllers
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_mesh
    {270001, &FunctionDispatch::handle_xrGetSpaceTriangleMeshMETA},
#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_mesh
#ifdef XRTRANSPORT_EXT_XR_META_spatial_entity_sharing
    {291001, &FunctionDispatch::handle_xrShareSpacesMETA},
#endif // XRTRANSPORT_EXT_XR_META_spatial_entity_sharing
#ifdef XRTRANSPORT_EXT_XR_META_virtual_keyboard
    {220001, &FunctionDispatch::handle_xrChangeVirtualKeyboardTextContextMETA},
    {220002, &FunctionDispatch::handle_xrCreateVirtualKeyboardMETA},
    {220003, &FunctionDispatch::handle_xrCreateVirtualKeyboardSpaceMETA},
    {220004, &FunctionDispatch::handle_xrDestroyVirtualKeyboardMETA},
    {220005, &FunctionDispatch::handle_xrGetVirtualKeyboardDirtyTexturesMETA},
    {220006, &FunctionDispatch::handle_xrGetVirtualKeyboardModelAnimationStatesMETA},
    {220007, &FunctionDispatch::handle_xrGetVirtualKeyboardScaleMETA},
    {220008, &FunctionDispatch::handle_xrGetVirtualKeyboardTextureDataMETA},
    {220009, &FunctionDispatch::handle_xrSendVirtualKeyboardInputMETA},
    {220010, &FunctionDispatch::handle_xrSetVirtualKeyboardModelVisibilityMETA},
    {220011, &FunctionDispatch::handle_xrSuggestVirtualKeyboardLocationMETA},
#endif // XRTRANSPORT_EXT_XR_META_virtual_keyboard
#ifdef XRTRANSPORT_EXT_XR_ML_compat
    {138001, &FunctionDispatch::handle_xrCreateSpaceFromCoordinateFrameUIDML},
#endif // XRTRANSPORT_EXT_XR_ML_compat
#ifdef XRTRANSPORT_EXT_XR_ML_facial_expression
    {483001, &FunctionDispatch::handle_xrCreateFacialExpressionClientML},
    {483002, &FunctionDispatch::handle_xrDestroyFacialExpressionClientML},
    {483003, &FunctionDispatch::handle_xrGetFacialExpressionBlendShapePropertiesML},
#endif // XRTRANSPORT_EXT_XR_ML_facial_expression
#ifdef XRTRANSPORT_EXT_XR_ML_localization_map
    {140001, &FunctionDispatch::handle_xrCreateExportedLocalizationMapML},
    {140002, &FunctionDispatch::handle_xrDestroyExportedLocalizationMapML},
    {140003, &FunctionDispatch::handle_xrEnableLocalizationEventsML},
    {140004, &FunctionDispatch::handle_xrGetExportedLocalizationMapDataML},
    {140005, &FunctionDispatch::handle_xrImportLocalizationMapML},
    {140006, &FunctionDispatch::handle_xrQueryLocalizationMapsML},
    {140007, &FunctionDispatch::handle_xrRequestMapLocalizationML},
#endif // XRTRANSPORT_EXT_XR_ML_localization_map
#ifdef XRTRANSPORT_EXT_XR_ML_marker_understanding
    {139001, &FunctionDispatch::handle_xrCreateMarkerDetectorML},
    {139002, &FunctionDispatch::handle_xrCreateMarkerSpaceML},
    {139003, &FunctionDispatch::handle_xrDestroyMarkerDetectorML},
    {139004, &FunctionDispatch::handle_xrGetMarkerDetectorStateML},
    {139005, &FunctionDispatch::handle_xrGetMarkerLengthML},
    {139006, &FunctionDispatch::handle_xrGetMarkerNumberML},
    {139007, &FunctionDispatch::handle_xrGetMarkerReprojectionErrorML},
    {139008, &FunctionDispatch::handle_xrGetMarkerStringML},
    {139009, &FunctionDispatch::handle_xrGetMarkersML},
    {139010, &FunctionDispatch::handle_xrSnapshotMarkerDetectorML},
#endif // XRTRANSPORT_EXT_XR_ML_marker_understanding
#ifdef XRTRANSPORT_EXT_XR_ML_spatial_anchors
    {141001, &FunctionDispatch::handle_xrCreateSpatialAnchorsAsyncML},
    {141002, &FunctionDispatch::handle_xrCreateSpatialAnchorsCompleteML},
    {141003, &FunctionDispatch::handle_xrGetSpatialAnchorStateML},
#endif // XRTRANSPORT_EXT_XR_ML_spatial_anchors
#ifdef XRTRANSPORT_EXT_XR_ML_spatial_anchors_storage
    {142001, &FunctionDispatch::handle_xrCreateSpatialAnchorsStorageML},
    {142002, &FunctionDispatch::handle_xrDeleteSpatialAnchorsAsyncML},
    {142003, &FunctionDispatch::handle_xrDeleteSpatialAnchorsCompleteML},
    {142004, &FunctionDispatch::handle_xrDestroySpatialAnchorsStorageML},
    {142005, &FunctionDispatch::handle_xrPublishSpatialAnchorsAsyncML},
    {142006, &FunctionDispatch::handle_xrPublishSpatialAnchorsCompleteML},
    {142007, &FunctionDispatch::handle_xrQuerySpatialAnchorsAsyncML},
    {142008, &FunctionDispatch::handle_xrQuerySpatialAnchorsCompleteML},
    {142009, &FunctionDispatch::handle_xrUpdateSpatialAnchorsExpirationAsyncML},
    {142010, &FunctionDispatch::handle_xrUpdateSpatialAnchorsExpirationCompleteML},
#endif // XRTRANSPORT_EXT_XR_ML_spatial_anchors_storage
#ifdef XRTRANSPORT_EXT_XR_ML_system_notifications
    {474001, &FunctionDispatch::handle_xrSetSystemNotificationsML},
#endif // XRTRANSPORT_EXT_XR_ML_system_notifications
#ifdef XRTRANSPORT_EXT_XR_ML_user_calibration
    {473001, &FunctionDispatch::handle_xrEnableUserCalibrationEventsML},
#endif // XRTRANSPORT_EXT_XR_ML_user_calibration
#ifdef XRTRANSPORT_EXT_XR_ML_world_mesh_detection
    {475001, &FunctionDispatch::handle_xrAllocateWorldMeshBufferML},
    {475002, &FunctionDispatch::handle_xrCreateWorldMeshDetectorML},
    {475003, &FunctionDispatch::handle_xrDestroyWorldMeshDetectorML},
    {475004, &FunctionDispatch::handle_xrFreeWorldMeshBufferML},
    {475005, &FunctionDispatch::handle_xrGetWorldMeshBufferRecommendSizeML},
    {475006, &FunctionDispatch::handle_xrRequestWorldMeshAsyncML},
    {475007, &FunctionDispatch::handle_xrRequestWorldMeshCompleteML},
    {475008, &FunctionDispatch::handle_xrRequestWorldMeshStateAsyncML},
    {475009, &FunctionDispatch::handle_xrRequestWorldMeshStateCompleteML},
#endif // XRTRANSPORT_EXT_XR_ML_world_mesh_detection
#ifdef XRTRANSPORT_EXT_XR_MNDX_force_feedback_curl
    {376001, &FunctionDispatch::handle_xrApplyForceFeedbackCurlMNDX},
#endif // XRTRANSPORT_EXT_XR_MNDX_force_feedback_curl
#ifdef XRTRANSPORT_EXT_XR_MSFT_composition_layer_reprojection
    {67001, &FunctionDispatch::handle_xrEnumerateReprojectionModesMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_composition_layer_reprojection
#ifdef XRTRANSPORT_EXT_XR_MSFT_controller_model
    {56001, &FunctionDispatch::handle_xrGetControllerModelKeyMSFT},
    {56002, &FunctionDispatch::handle_xrGetControllerModelPropertiesMSFT},
    {56003, &FunctionDispatch::handle_xrGetControllerModelStateMSFT},
    {56004, &FunctionDispatch::handle_xrLoadControllerModelMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_controller_model
#ifdef XRTRANSPORT_EXT_XR_MSFT_hand_tracking_mesh
    {53001, &FunctionDispatch::handle_xrCreateHandMeshSpaceMSFT},
    {53002, &FunctionDispatch::handle_xrUpdateHandMeshMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_hand_tracking_mesh
#ifdef XRTRANSPORT_EXT_XR_MSFT_perception_anchor_interop
    {57001, &FunctionDispatch::handle_xrCreateSpatialAnchorFromPerceptionAnchorMSFT},
    {57002, &FunctionDispatch::handle_xrTryGetPerceptionAnchorFromSpatialAnchorMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_perception_anchor_interop
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_marker
    {148001, &FunctionDispatch::handle_xrGetSceneMarkerDecodedStringMSFT},
    {148002, &FunctionDispatch::handle_xrGetSceneMarkerRawDataMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_scene_marker
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_understanding
    {98001, &FunctionDispatch::handle_xrComputeNewSceneMSFT},
    {98002, &FunctionDispatch::handle_xrCreateSceneMSFT},
    {98003, &FunctionDispatch::handle_xrCreateSceneObserverMSFT},
    {98004, &FunctionDispatch::handle_xrDestroySceneMSFT},
    {98005, &FunctionDispatch::handle_xrDestroySceneObserverMSFT},
    {98006, &FunctionDispatch::handle_xrEnumerateSceneComputeFeaturesMSFT},
    {98007, &FunctionDispatch::handle_xrGetSceneComponentsMSFT},
    {98008, &FunctionDispatch::handle_xrGetSceneComputeStateMSFT},
    {98009, &FunctionDispatch::handle_xrGetSceneMeshBuffersMSFT},
    {98010, &FunctionDispatch::handle_xrLocateSceneComponentsMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_scene_understanding
#ifdef XRTRANSPORT_EXT_XR_MSFT_scene_understanding_serialization
    {99001, &FunctionDispatch::handle_xrDeserializeSceneMSFT},
    {99002, &FunctionDispatch::handle_xrGetSerializedSceneFragmentDataMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_scene_understanding_serialization
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_anchor
    {40001, &FunctionDispatch::handle_xrCreateSpatialAnchorMSFT},
    {40002, &FunctionDispatch::handle_xrCreateSpatialAnchorSpaceMSFT},
    {40003, &FunctionDispatch::handle_xrDestroySpatialAnchorMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_anchor
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_anchor_persistence
    {143001, &FunctionDispatch::handle_xrClearSpatialAnchorStoreMSFT},
    {143002, &FunctionDispatch::handle_xrCreateSpatialAnchorFromPersistedNameMSFT},
    {143003, &FunctionDispatch::handle_xrCreateSpatialAnchorStoreConnectionMSFT},
    {143004, &FunctionDispatch::handle_xrDestroySpatialAnchorStoreConnectionMSFT},
    {143005, &FunctionDispatch::handle_xrEnumeratePersistedSpatialAnchorNamesMSFT},
    {143006, &FunctionDispatch::handle_xrPersistSpatialAnchorMSFT},
    {143007, &FunctionDispatch::handle_xrUnpersistSpatialAnchorMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_anchor_persistence
#ifdef XRTRANSPORT_EXT_XR_MSFT_spatial_graph_bridge
    {50001, &FunctionDispatch::handle_xrCreateSpatialGraphNodeSpaceMSFT},
    {50002, &FunctionDispatch::handle_xrDestroySpatialGraphNodeBindingMSFT},
    {50003, &FunctionDispatch::handle_xrGetSpatialGraphNodeBindingPropertiesMSFT},
    {50004, &FunctionDispatch::handle_xrTryCreateSpatialGraphStaticNodeBindingMSFT},
#endif // XRTRANSPORT_EXT_XR_MSFT_spatial_graph_bridge
#ifdef XRTRANSPORT_EXT_XR_OCULUS_audio_device_guid
    {160001, &FunctionDispatch::handle_xrGetAudioInputDeviceGuidOculus},
    {160002, &FunctionDispatch::handle_xrGetAudioOutputDeviceGuidOculus},
#endif // XRTRANSPORT_EXT_XR_OCULUS_audio_device_guid
#ifdef XRTRANSPORT_EXT_XR_OCULUS_external_camera
    {227001, &FunctionDispatch::handle_xrEnumerateExternalCamerasOCULUS},
#endif // XRTRANSPORT_EXT_XR_OCULUS_external_camera
#ifdef XRTRANSPORT_EXT_XR_QCOM_tracking_optimization_settings
    {307001, &FunctionDispatch::handle_xrSetTrackingOptimizationSettingsHintQCOM},
#endif // XRTRANSPORT_EXT_XR_QCOM_tracking_optimization_settings
#ifdef XRTRANSPORT_EXT_XR_VARJO_environment_depth_estimation
    {124001, &FunctionDispatch::handle_xrSetEnvironmentDepthEstimationVARJO},
#endif // XRTRANSPORT_EXT_XR_VARJO_environment_depth_estimation
#ifdef XRTRANSPORT_EXT_XR_VARJO_marker_tracking
    {125001, &FunctionDispatch::handle_xrCreateMarkerSpaceVARJO},
    {125002, &FunctionDispatch::handle_xrGetMarkerSizeVARJO},
    {125003, &FunctionDispatch::handle_xrSetMarkerTrackingPredictionVARJO},
    {125004, &FunctionDispatch::handle_xrSetMarkerTrackingTimeoutVARJO},
    {125005, &FunctionDispatch::handle_xrSetMarkerTrackingVARJO},
#endif // XRTRANSPORT_EXT_XR_VARJO_marker_tracking
#ifdef XRTRANSPORT_EXT_XR_VARJO_view_offset
    {126001, &FunctionDispatch::handle_xrSetViewOffsetVARJO},
#endif // XRTRANSPORT_EXT_XR_VARJO_view_offset
    {1, &FunctionDispatch::handle_xrAcquireSwapchainImage},
    {2, &FunctionDispatch::handle_xrApplyHapticFeedback},
    {3, &FunctionDispatch::handle_xrAttachSessionActionSets},
    {4, &FunctionDispatch::handle_xrBeginFrame},
    {5, &FunctionDispatch::handle_xrBeginSession},
    {6, &FunctionDispatch::handle_xrCreateAction},
    {7, &FunctionDispatch::handle_xrCreateActionSet},
    {8, &FunctionDispatch::handle_xrCreateActionSpace},
    {9, &FunctionDispatch::handle_xrCreateInstance},
    {10, &FunctionDispatch::handle_xrCreateReferenceSpace},
    {11, &FunctionDispatch::handle_xrCreateSession},
    {12, &FunctionDispatch::handle_xrCreateSwapchain},
    {13, &FunctionDispatch::handle_xrDestroyAction},
    {14, &FunctionDispatch::handle_xrDestroyActionSet},
    {15, &FunctionDispatch::handle_xrDestroyInstance},
    {16, &FunctionDispatch::handle_xrDestroySession},
    {17, &FunctionDispatch::handle_xrDestroySpace},
    {18, &FunctionDispatch::handle_xrDestroySwapchain},
    {19, &FunctionDispatch::handle_xrEndFrame},
    {20, &FunctionDispatch::handle_xrEndSession},
    {21, &FunctionDispatch::handle_xrEnumerateApiLayerProperties},
    {22, &FunctionDispatch::handle_xrEnumerateBoundSourcesForAction},
    {23, &FunctionDispatch::handle_xrEnumerateEnvironmentBlendModes},
    {24, &FunctionDispatch::handle_xrEnumerateInstanceExtensionProperties},
    {25, &FunctionDispatch::handle_xrEnumerateReferenceSpaces},
    {26, &FunctionDispatch::handle_xrEnumerateSwapchainFormats},
    {27, &FunctionDispatch::handle_xrEnumerateSwapchainImages},
    {28, &FunctionDispatch::handle_xrEnumerateViewConfigurationViews},
    {29, &FunctionDispatch::handle_xrEnumerateViewConfigurations},
    {30, &FunctionDispatch::handle_xrGetActionStateBoolean},
    {31, &FunctionDispatch::handle_xrGetActionStateFloat},
    {32, &FunctionDispatch::handle_xrGetActionStatePose},
    {33, &FunctionDispatch::handle_xrGetActionStateVector2f},
    {34, &FunctionDispatch::handle_xrGetCurrentInteractionProfile},
    {35, &FunctionDispatch::handle_xrGetInputSourceLocalizedName},
    {36, &FunctionDispatch::handle_xrGetInstanceProperties},
    {37, &FunctionDispatch::handle_xrGetReferenceSpaceBoundsRect},
    {38, &FunctionDispatch::handle_xrGetSystem},
    {39, &FunctionDispatch::handle_xrGetSystemProperties},
    {40, &FunctionDispatch::handle_xrGetViewConfigurationProperties},
    {41, &FunctionDispatch::handle_xrLocateSpace},
    {42, &FunctionDispatch::handle_xrLocateSpaces},
    {43, &FunctionDispatch::handle_xrLocateViews},
    {44, &FunctionDispatch::handle_xrPathToString},
    {45, &FunctionDispatch::handle_xrPollEvent},
    {46, &FunctionDispatch::handle_xrReleaseSwapchainImage},
    {47, &FunctionDispatch::handle_xrRequestExitSession},
    {48, &FunctionDispatch::handle_xrResultToString},
    {49, &FunctionDispatch::handle_xrStopHapticFeedback},
    {50, &FunctionDispatch::handle_xrStringToPath},
    {51, &FunctionDispatch::handle_xrStructureTypeToString},
    {52, &FunctionDispatch::handle_xrSuggestInteractionProfileBindings},
    {53, &FunctionDispatch::handle_xrSyncActions},
    {54, &FunctionDispatch::handle_xrWaitFrame},
    {55, &FunctionDispatch::handle_xrWaitSwapchainImage},

};

} // namespace xrtransport
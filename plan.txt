xrtransport will consist of a base runtime which is designed to completely transparently forward OpenXR calls
for the base API, along with any extensions it is configured to support at compile time. Obviously this will not
work by itself due to graphics considerations and platform-specific behavior. To get around this, API layers 
should be built on top of this base runtime to support specific client-server pairs, e.g. (Android/OpenGL ->
Windows/Vulkan)

xrEnumerateSwapchainImages needs to be custom implementation. The size of each element of its images parameter
is determined by which graphics extension is enabled which will need to be kept track of locally

TODO next: add a cleanup case for a pointer to a single header

New idea: remove all (and I mean ALL) logic from the serializer and deserializer methods. For instance, instead
of checking for marker and finding the right deserializer for an xr struct, just call deserialize(next). This
will greatly simplify all of the serializers/deserializers which will just consist of calling serializer/
deserialize down the tree. The one exception to this is that the generator should detect if the type is void*
and the name is next and call a special function: `deserialize_next`. This is because we don't want an overload
for void* because there are a few cases where there is a void* that is not an xr struct. Header struct
serializers will simply dispatch to the lookup table. Then serialize can be called directly on the header struct
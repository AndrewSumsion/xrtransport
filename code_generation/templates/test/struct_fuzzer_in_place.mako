/*
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file was automatically generated by the code_generation module.
 * Any changes made to this file will be lost when regenerated.
 *
 * To modify this file, edit the corresponding template in:
 * code_generation/templates/test/struct_fuzzer_in_place.mako
 */

#include <catch2/catch_test_macros.hpp>

#include "xrtransport/serialization/serializer.h"
#include "xrtransport/serialization/deserializer.h"
#include "xrtransport/asio_compat.h"

#include <cassert>
#include <cstring>
#include <vector>

using namespace xrtransport;

// ASIO-compatible stream buffer for testing
// Effectively a simple dynamic-size FIFO queue
class TestStreamBuffer : public SyncDuplexStream {
private:
    std::vector<char> buffer_;
    std::size_t read_pos_ = 0;
    bool blocking_mode_ = true;

public:
    TestStreamBuffer() = default;

    // NonBlockingStream interface
    void blocking_mode(bool mode) override {
        blocking_mode_ = mode;
    }

    bool blocking_mode() const override {
        return blocking_mode_;
    }

    std::size_t available() override {
        return buffer_.size() - read_pos_;
    }

    std::size_t available(asio::error_code& ec) override {
        ec.clear();
        return buffer_.size() - read_pos_;
    }

    // SyncReadStream interface
    std::size_t read_some(const asio::mutable_buffer& buffers) override {
        asio::error_code ec;
        return read_some(buffers, ec);
    }

    std::size_t read_some(const asio::mutable_buffer& buffers, asio::error_code& ec) override {
        ec.clear();

        char* data = static_cast<char*>(buffers.data());
        std::size_t size = buffers.size();

        std::size_t available = buffer_.size() - read_pos_;
        std::size_t to_read = std::min(size, available);

        if (to_read > 0) {
            std::copy(buffer_.begin() + read_pos_,
                     buffer_.begin() + read_pos_ + to_read,
                     data);
            read_pos_ += to_read;
        }

        return to_read;
    }

    // SyncWriteStream interface
    std::size_t write_some(const asio::const_buffer& buffers) override {
        asio::error_code ec;
        return write_some(buffers, ec);
    }

    std::size_t write_some(const asio::const_buffer& buffers, asio::error_code& ec) override {
        ec.clear();

        const char* data = static_cast<const char*>(buffers.data());
        std::size_t size = buffers.size();

        buffer_.insert(buffer_.end(), data, data + size);
        return size;
    }

    // Helper methods for testing
    void reset_read() {
        read_pos_ = 0;
    }

    void clear() {
        buffer_.clear();
        read_pos_ = 0;
    }

    std::size_t size() const {
        return buffer_.size();
    }
};

TEST_CASE("In-place deserialization round-trip test", "[serialization][in-place]") {
    //
    // Struct initialization
    //
<% plans = [struct_generator.generate_plan() for _ in range(1000)] %>
% for i, plan in enumerate(plans):
    ${struct_generator.init_struct(plan, f"item{i}", "    ")}
% endfor

    //
    // Serialize all structs
    //
    TestStreamBuffer buffer;

% for i, plan in enumerate(plans):
    serialize(&item${i}, buffer);
% endfor

    //
    // Zero out existing structs
    //
% for i, plan in enumerate(plans):
${struct_generator.zero_struct(plan, f"item{i}", "    ")}
% endfor

    //
    // Deserialize all structs in-place
    //
    buffer.reset_read();

% for i, plan in enumerate(plans):
    deserialize(&item${i}, buffer, true);
% endfor

    //
    // Struct comparison
    //
% for i, plan in enumerate(plans):
${struct_generator.compare_struct(plan, f"item{i}", "    ")}
% endfor
}
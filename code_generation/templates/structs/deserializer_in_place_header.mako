/*
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file was automatically generated by the code_generation module.
 * Any changes made to this file will be lost when regenerated.
 *
 * To modify this file, edit the corresponding template in:
 * code_generation/templates/structs/deserializer_in_place_header.mako
 */

<%namespace name="utils" file="utils.mako"/>

<%def name="forward_deserializer_in_place(struct)">
void deserialize_in_place(${struct.name}* s, std::istream& in);
</%def>

#ifndef XRTRANSPORT_DESERIALIZER_IN_PLACE_GENERATED_H
#define XRTRANSPORT_DESERIALIZER_IN_PLACE_GENERATED_H

#include "openxr/openxr.h"

#include <iostream>
#include <cstdint>
#include <unordered_map>
#include <cassert>
#include <cstring>
#include <type_traits>

namespace xrtransport {

// Forward declarations (in-place deserializers)
<%utils:for_grouped_structs args="struct">
${forward_deserializer_in_place(struct)}
</%utils:for_grouped_structs>

// Struct deserializer lookup for in-place deserialization
// Only to be used with OpenXR pNext structs
using StructDeserializerInPlace = void(*)(XrBaseOutStructure*, std::istream&);
#define STRUCT_DESERIALIZER_IN_PLACE_PTR(t) (reinterpret_cast<StructDeserializerInPlace>(static_cast<void(*)(t*, std::istream&)>(&deserialize_in_place)))

extern std::unordered_map<XrStructureType, StructDeserializerInPlace> deserializer_in_place_lookup_table;

StructDeserializerInPlace deserializer_in_place_lookup(XrStructureType struct_type);

// Generic in-place deserializers
template <typename T>
void deserialize_in_place(T* x, std::istream& in) {
    static_assert(
        !std::is_class<T>::value,
        "T must be a supported type"
    );
    in.read(reinterpret_cast<char*>(const_cast<typename std::remove_const<T>::type*>(x)), sizeof(T));
}

template <typename T>
void deserialize_in_place_array(T* x, std::size_t len, std::istream& in) {
    for (std::size_t i = 0; i < len; i++) {
        deserialize_in_place(&x[i], in);
    }
}

// For in-place deserialization, pointers must already point to valid memory
// For weird const-correctness reasons, we need a const version too
template <typename T>
void deserialize_in_place_ptr(T** x, std::istream& in) {
    std::uint32_t len{};
    deserialize_in_place(&len, in);
    if (len && *x != nullptr) {
        deserialize_in_place_array(*x, len, in);
    } else if (len && *x == nullptr) {
        // TODO: proper error handling
        assert(false && "Attempted to deserialize in-place into null pointer");
    }
    // If len == 0, pointer should remain as-is (could be null or pointing to valid memory)
}

template <typename T>
void deserialize_in_place_ptr(const T** x, std::istream& in) {
    std::uint32_t len{};
    deserialize_in_place(&len, in);
    if (len && *x != nullptr) {
        deserialize_in_place_array(const_cast<T*>(*x), len, in);
    } else if (len && *x == nullptr) {
        // TODO: proper error handling
        assert(false && "Attempted to deserialize in-place into null pointer");
    }
    // If len == 0, pointer should remain as-is (could be null or pointing to valid memory)
}

void deserialize_in_place_xr(const void** p_s, std::istream& in);
void deserialize_in_place_xr(void** p_s, std::istream& in);

} // namespace xrtransport

#endif // XRTRANSPORT_DESERIALIZER_IN_PLACE_GENERATED_H
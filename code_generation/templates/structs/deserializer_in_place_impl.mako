/*
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file was automatically generated by the code_generation module.
 * Any changes made to this file will be lost when regenerated.
 *
 * To modify this file, edit the corresponding template in:
 * code_generation/templates/structs/deserializer_in_place_impl.mako
 */

<%namespace name="utils" file="utils.mako"/>

<%def name="deserialize_in_place_member(member, binding_prefix='s->')">
<% member_struct = spec.find_struct(member.type) %>
## First, check for cases that must be manually implemented
% if member.pointer and member.array:
    #error "auto-generator doesn't support array of pointers (${binding_prefix}${member.name})"
    <% return %>
% endif
% if member.pointer and member.pointer != "*":
    #error "auto-generator doesn't support double pointers (${binding_prefix}${member.name})"
    <% return %>
% endif
% if member.len and "," in member.len:
    #error "auto-generator doesn't support multi-variable lengths (${binding_prefix}${member.name})"
    <% return %>
% endif
% if member.pointer and member.len and member_struct and member_struct.header:
    #error "auto-generator doesn't support arrays of header structs (${binding_prefix}${member.name})"
    <% return %>
% endif
## Now handle valid members
% if (member.type == "void" and member.pointer == "*" and member.name == "next") or (member_struct and member_struct.header):
    deserialize_in_place_xr(&${binding_prefix}next, in);
% elif member.pointer:
    deserialize_in_place_ptr(&${binding_prefix}${member.name}, in);
% elif member.array:
    deserialize_in_place_array(${binding_prefix}${member.name}, ${member.array}, in);
% else:
    deserialize_in_place(&${binding_prefix}${member.name}, in);
% endif
</%def>

<%def name="deserializer_in_place(struct)">
void deserialize_in_place(${struct.name}* s, std::istream& in) {
    % for member in struct.members:
        ${deserialize_in_place_member(member)}
    % endfor
}
</%def>

#include "xrtransport/generated/deserializer_in_place.h"

namespace xrtransport {

std::unordered_map<XrStructureType, StructDeserializerInPlace> deserializer_in_place_lookup_table = {
<%utils:for_grouped_structs xr_structs_only="True" args="struct">
    {${struct.xr_type}, STRUCT_DESERIALIZER_IN_PLACE_PTR(${struct.name})},
</%utils:for_grouped_structs>
};

StructDeserializerInPlace deserializer_in_place_lookup(XrStructureType struct_type) {
    assert(deserializer_in_place_lookup_table.find(struct_type) != deserializer_in_place_lookup_table.end());
    return deserializer_in_place_lookup_table[struct_type];
}

void deserialize_in_place_xr(const void** p_s, std::istream& in) {
    XrStructureType type{};
    deserialize_in_place(&type, in);
    if (!type) {
        if (*p_s != nullptr) {
            assert(false && "Incoming pNext chain is shorter than local chain");
        }
        else {
            // End of chain
            return;
        }
    }
    if (*p_s == nullptr) {
        assert(false && "Incoming pNext chain is longer than local chain");
    }
    XrBaseOutStructure* p_xr = static_cast<XrBaseOutStructure*>(const_cast<void*>(*p_s));
    if (p_xr->type != type) {
        assert(false && "Existing XR struct type does not match incoming struct");
    }
    deserializer_in_place_lookup(type)(p_xr, in);
}

void deserialize_in_place_xr(void** p_s, std::istream& in) {
    XrStructureType type{};
    deserialize_in_place(&type, in);
    if (!type) {
        if (*p_s != nullptr) {
            assert(false && "Incoming pNext chain is shorter than local chain");
        }
        else {
            // End of chain
            return;
        }
    }
    if (*p_s == nullptr) {
        assert(false && "Incoming pNext chain is longer than local chain");
    }
    XrBaseOutStructure* p_xr = static_cast<XrBaseOutStructure*>(const_cast<void*>(*p_s));
    if (p_xr->type != type) {
        assert(false && "Existing XR struct type does not match incoming struct");
    }
    deserializer_in_place_lookup(type)(p_xr, in);
}

// In-place deserializers
<%utils:for_grouped_structs args="struct">
% if not struct.custom:
${deserializer_in_place(struct)}
% endif
</%utils:for_grouped_structs>

} // namespace xrtransport
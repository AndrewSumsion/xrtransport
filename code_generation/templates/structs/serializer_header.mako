/*
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 *
 * This file was automatically generated by the code_generation module.
 * Any changes made to this file will be lost when regenerated.
 *
 * To modify this file, edit the corresponding template in:
 * code_generation/templates/structs/serializer_header.mako
 */

<%namespace name="utils" file="utils.mako"/>

<%def name="forward_serializer(struct)">
void serialize(const ${struct.name}* s, SyncWriteStream& out);
</%def>

#ifndef XRTRANSPORT_SERIALIZER_GENERATED_H
#define XRTRANSPORT_SERIALIZER_GENERATED_H

#include "openxr/openxr.h"
#include "xrtransport/asio_compat.h"
#include "struct_size.h"

#include "asio/write.hpp"

#include <cstdint>
#include <unordered_map>
#include <cassert>
#include <cstring>

namespace xrtransport {

// Forward declarations
<%utils:for_grouped_structs args="struct">
${forward_serializer(struct)}
</%utils:for_grouped_structs>

// Only to be used with OpenXR pNext structs
using StructSerializer = void(*)(const XrBaseInStructure*, SyncWriteStream&);
#define STRUCT_SERIALIZER_PTR(t) (reinterpret_cast<StructSerializer>(static_cast<void(*)(const t*, SyncWriteStream&)>(&serialize)))

extern std::unordered_map<XrStructureType, StructSerializer> serializer_lookup_table;

StructSerializer serializer_lookup(XrStructureType struct_type);

// Generic serializers
template <typename T>
void serialize(const T* x, SyncWriteStream& out) {
    static_assert(
        !std::is_class<T>::value,
        "T must be a supported type"
    );
    asio::write(out, asio::const_buffer(x, sizeof(T)));
}

template <typename T>
void serialize_array(const T* x, std::size_t len, SyncWriteStream& out) {
    for (std::size_t i = 0; i < len; i++) {
        serialize(&x[i], out);
    }
}

template <typename T>
void serialize_ptr(const T* x, std::size_t len, SyncWriteStream& out) {
    std::uint32_t marker = x != nullptr ? len : 0;
    serialize(&marker, out);
    if (marker) {
        serialize_array(x, len, out);
    }
}

template <typename T>
void serialize_xr(const T* untyped, SyncWriteStream& out) {
    const XrBaseInStructure* x = reinterpret_cast<const XrBaseInStructure*>(untyped);
    XrStructureType type = x != nullptr ? x->type : XR_TYPE_UNKNOWN;
    serialize(&type, out);
    if (type != XR_TYPE_UNKNOWN) {
        serializer_lookup(type)(x, out);
    }
}

template <typename T>
void serialize_xr_array(const T* untyped, std::size_t len, SyncWriteStream& out) {
    const XrBaseInStructure* first = reinterpret_cast<const XrBaseInStructure*>(untyped);
    std::uint32_t count = first != nullptr ? len : 0;
    serialize(&count, out);
    if (count) {
        XrStructureType type = first->type;
        serialize(&type, out);
        std::size_t struct_size = size_lookup(type);
        StructSerializer serializer = serializer_lookup(type);
        const char* buffer = reinterpret_cast<const char*>(first);
        for(std::uint32_t i = 0; i < count; i++) {
            serializer(reinterpret_cast<const XrBaseInStructure*>(buffer), out);
            buffer += struct_size;
        }
    }
}

} // namespace xrtransport

#endif // XRTRANSPORT_SERIALIZER_GENERATED_H
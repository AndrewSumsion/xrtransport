# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

xrtransport is a transparent remote OpenXR runtime system that enables OpenXR applications to run remotely by creating a client-server architecture with automatic serialization/deserialization. The primary use case is running Meta Quest applications on PC through Android emulation while forwarding OpenXR calls to the host's HMD hardware.

## Key Development Commands

### Code Generation (Required Before Building)
```bash
# Generate serialization/deserialization code from OpenXR specification
./regenerate.sh
```

Or manually:
```bash
python3 -m code_generation OpenXR-SDK/specification/registry/xr.xml include/xrtransport src/xrtransport test
```

This command must be run whenever:
- The OpenXR specification changes
- Custom struct handling is modified
- New extensions are added

**Note**: Code generation outputs to modular directories: serialization code to `include/xrtransport/serialization/` and `src/xrtransport/serialization/`, reflection metadata to `include/xrtransport/reflection/`, and tests to `test/serialization/`.

### Building and Testing
```bash
# Build project from root
mkdir build && cd build
cmake ..
make

# Run serialization tests (Catch2-based)
cd test/serialization
./serialization_tests

# Run specific test categories
./serialization_tests "[serialization]"     # All serialization tests
./serialization_tests "[in-place]"          # In-place deserialization tests
./serialization_tests --list-tests          # List available tests
```

## Architecture Overview

### Core Components

**Code Generation System** (`code_generation/`):
- Modular architecture with organized components:
  - `structs/`: Serializer and deserializer generation
  - `reflection/`: Reflection metadata generation
  - `test/`: Test code generation (fuzzer)
  - `templates/`: Mako templates organized by function
- Parses OpenXR XML spec to extract all function signatures and struct definitions
- Auto-generates reflection metadata, serializers, and deserializers for all OpenXR types
- Direct code generation into final header files (no intermediate files)
- Entry point: `code_generation/__main__.py`

**Serialization Layer** (`include/xrtransport/serialization/` and `src/xrtransport/serialization/`):
- `serializer.h`/`deserializer.h`: Auto-generated headers for core binary serialization
- `serializer.cpp`/`deserializer.cpp`: Auto-generated implementations with ASIO stream support
- `custom_serializer.cpp`/`custom_deserializer.cpp`: Manual implementations for complex structs (XrInstanceCreateInfo, XrFrameEndInfo)

**Reflection Layer** (`include/xrtransport/reflection/`):
- `reflection_struct.h`: Auto-generated type metadata (regenerated by code gen)

**Transport Layer** (`include/xrtransport/transport/` and `src/xrtransport/transport/`):
- `transport.h`/`transport.cpp`: Message-based transport with async worker cycle and MessageLock RAII pattern

**ASIO Compatibility** (`include/xrtransport/asio_compat.h`):
- Abstract stream interfaces for both sync and async operations (SyncReadStream, SyncWriteStream, SyncDuplexStream, AsyncReadStream, AsyncWriteStream, AsyncDuplexStream, DuplexStream)
- Template-based concrete implementations for wrapping actual ASIO streams

**Network Protocol**:
- Stateful binary protocol with minimal metadata overhead
- Handshake with version negotiation
- Function calls: index + serialized arguments â†’ results + modified arguments
- Special markers for struct chains (pNext), pointers, and function headers

### Key Files to Understand

- `protocol.txt`: Network protocol specification
- `code_generation/spec_parser.py`: OpenXR XML parsing logic
- `code_generation/templates/`: Mako templates organized by function (structs/, reflection/, test/)
- `code_generation/structs/`: Serializer/deserializer generation modules
- `code_generation/reflection/`: Reflection metadata generation
- `supported_types.json`, `structs.json`, `functions.json`: Parsed OpenXR metadata
- `test/fuzzer.cpp`: Comprehensive serialization round-trip testing

### Development Workflow

1. **Always regenerate code after spec changes**: The serialization system is entirely auto-generated from the OpenXR specification
2. **Custom struct handling**: Add structs requiring manual serialization to `CUSTOM_STRUCTS` in `spec_parser.py`
3. **Protocol changes**: Update both serializer and deserializer simultaneously to maintain compatibility
4. **Testing**: The fuzzer provides comprehensive validation of serialization correctness

## Current Implementation Status

### âœ… Completed Components
- **Header/Implementation Split**: Successfully completed - serialization code properly separated into headers and implementations with static library linking
- **In-Place Deserialization**: Successfully integrated as `bool in_place` parameter in existing `deserialize()` functions
- **ASIO Stream Integration**: Refactored serialization system to use ASIO streams instead of iostreams for better network compatibility
- **Modular Code Generation**: Well-organized code generation system with separate modules for structs, reflection, and testing
- **Binary Protocol Foundation**: Core stateful binary protocol with function indexing and serialization

### ðŸš§ Currently In Progress
- **Enhanced Transport Protocol**: Next phase involves implementing the Transport class with MessageLock RAII pattern for thread-safe communication
- **Custom Message Types**: Extending protocol beyond simple function calls to support bidirectional custom messages

### ðŸ“‹ Missing Components (Planned Implementation)
Based on CLIENT_IMPLEMENTATION_PLAN.md, the remaining work is organized into phases:

**Phase 1**: Enhanced Protocol & Transport
- Transport class with worker thread and message handling
- MessageLockOut/MessageLockIn RAII classes for thread-safe stream access
- 2-byte message headers with FUNCTION_CALL/FUNCTION_RETURN distinction

**Phase 2**: Function Generation Infrastructure
- Auto-generate client-side OpenXR function implementations
- Function index generation matching server
- Integration with existing serialization infrastructure

**Phase 3**: Client Runtime Assembly
- OpenXR loader-compatible runtime with proper loader negotiation
- Connection management with Transport integration
- Build as .so compatible with Android OpenXR loader

**Future Work**:
- Server program interfacing with native OpenXR runtime
- Graphics API layers (Vulkan/OpenGL ES)
- Meta-specific extension layers

## Recent Development History

### Recent Commits (Latest First)
- **acf0823**: "refactored to use ASIO streams instead of iostreams" - Major refactoring to use ASIO for better network compatibility
- **8f07036**: "Added ASIO" - Initial ASIO integration
- **1694f73**: "updated plan" - Updated CLIENT_IMPLEMENTATION_PLAN.md
- **c7f3243**: "refactored separate deserialize_in_place into deserialize with flag" - Simplified in-place deserialization API
- **b1d949a**: "added in-place deserialization" - Initial in-place deserialization support

### Key Design Decisions Made
- **ASIO Stream Architecture**: Abstract stream interfaces (ReadStream, WriteStream, ReadWriteStream) for network transport flexibility
- **In-Place Deserialization**: Unified API with `bool in_place` parameter instead of separate function set
- **Header/Implementation Split**: Proper separation for compilation efficiency and library linking
- **Thread-Safe Transport Design**: Recursive mutex with MessageLock RAII pattern for safe concurrent access

### Important Notes

- **Time synchronization**: Client and server clocks need coordination (see `time_notes.txt`)
- **Memory management**: Careful handling of pointers and dynamic allocation across network boundaries
- **Extension support**: Architecture supports OpenXR extensions through auto-generation
- **MSVC compatibility**: Requires `/Zc:preprocessor` flag for macro handling
- **ASIO Integration**: All serialization now uses ASIO streams for network compatibility
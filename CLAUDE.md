# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

xrtransport is a transparent remote OpenXR runtime system that enables OpenXR applications to run remotely by creating a client-server architecture with automatic serialization/deserialization. The primary use case is running Meta Quest applications on PC through Android emulation while forwarding OpenXR calls to the host's HMD hardware.

## Key Development Commands

### Code Generation (Required Before Building)
```bash
# Generate serialization/deserialization code from OpenXR specification
python3 -m code_generation OpenXR-SDK/specification/registry/xr.xml include/xrtransport/generated test
```

This command must be run whenever:
- The OpenXR specification changes
- Custom struct handling is modified
- New extensions are added

### Building and Testing
```bash
# Build the fuzzer test
cd test
mkdir build && cd build
cmake ..
cmake --build .

# Run serialization tests
./fuzzer
# Should output: "Fuzzer passed"
```

## Architecture Overview

### Core Components

**Code Generation System** (`code_generation/`):
- Modular architecture with organized components:
  - `structs/`: Serializer and deserializer generation
  - `reflection/`: Reflection metadata generation
  - `test/`: Test code generation (fuzzer)
  - `templates/`: Mako templates organized by function
- Parses OpenXR XML spec to extract all function signatures and struct definitions
- Auto-generates reflection metadata, serializers, and deserializers for all OpenXR types
- Direct code generation into final header files (no intermediate files)
- Entry point: `code_generation/__main__.py`

**Serialization Layer** (`include/xrtransport/`):
- `serializer.h`/`deserializer.h`: Auto-generated core binary serialization for network transport
- `custom/serializer.h`/`custom/deserializer.h`: Manual implementations for complex structs (XrInstanceCreateInfo, XrFrameEndInfo)
- `reflection_struct.h`: Auto-generated type metadata (regenerated by code gen)

**Network Protocol**:
- Stateful binary protocol with minimal metadata overhead
- Handshake with version negotiation
- Function calls: index + serialized arguments â†’ results + modified arguments
- Special markers for struct chains (pNext), pointers, and function headers

### Key Files to Understand

- `protocol.txt`: Network protocol specification
- `code_generation/spec_parser.py`: OpenXR XML parsing logic
- `code_generation/templates/`: Mako templates organized by function (structs/, reflection/, test/)
- `code_generation/structs/`: Serializer/deserializer generation modules
- `code_generation/reflection/`: Reflection metadata generation
- `supported_types.json`, `structs.json`, `functions.json`: Parsed OpenXR metadata
- `test/fuzzer.cpp`: Comprehensive serialization round-trip testing

### Development Workflow

1. **Always regenerate code after spec changes**: The serialization system is entirely auto-generated from the OpenXR specification
2. **Custom struct handling**: Add structs requiring manual serialization to `CUSTOM_STRUCTS` in `spec_parser.py`
3. **Protocol changes**: Update both serializer and deserializer simultaneously to maintain compatibility
4. **Testing**: The fuzzer provides comprehensive validation of serialization correctness

### Missing Components (To Do)

- Client-side OpenXR runtime (loader-compatible)
- Server program interfacing with native OpenXR runtime
- Graphics API layers (Vulkan/OpenGL ES)
- Meta-specific extension layers

### Important Notes

- **Time synchronization**: Client and server clocks need coordination (see `time_notes.txt`)
- **Memory management**: Careful handling of pointers and dynamic allocation across network boundaries
- **Extension support**: Architecture supports OpenXR extensions through auto-generation
- **MSVC compatibility**: Requires `/Zc:preprocessor` flag for macro handling